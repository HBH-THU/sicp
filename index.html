<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Structure and Interpretation of Computer Programs (SICP)</title>
<!-- 2015-01-21 Wed 07:15 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Peter Danenberg" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Structure and Interpretation of Computer Programs (SICP)</h1>
<p>
We’re running an <a href="http://mitpress.mit.edu/sicp/full-text/book/book.html">SICP</a> reading group on Mondays from 5:30 to 7:00 at
<a href="https://map.googleplex.com/?q=type:confroom%2520location_id:US-MTV-2000-3-306">MTV-2000-3-Rancho San Antonio</a>!
</p>

<p>
<a href="https://www.google.com/calendar/event?action=TEMPLATE&tmeid=dm12dWxwMXNhYXU1dTFmcTJwbThmYWRvczhfMjAxNDA2MjRUMDAzMDAwWiBnb29nbGUuY29tX2VwNmRyYnFkbmV0Mmg3djc0MzU0M2RlY2cwQGc&tmsrc=google.com_ep6drbqdnet2h7v743543decg0%2540group.calendar.google.com">Add us to your calendar</a>, <a href="https://groups.google.com/a/google.com/forum/#!forum/sicp-reading-group">subscribe to the group</a> (for Googlers) or
<a href="http://csrg.org">visit the meetup</a> (for everyone).
</p>

<iframe src= "https://www.google.com/calendar/embed?showTitle=0&amp;showNav=0&amp;showPrint=0&amp;showTabs=0&amp;showCalendars=0&amp;mode=AGENDA&amp;height=256&amp;wkst=1&amp;bgcolor=%23FFFFFF&amp;src=google.com_ep6drbqdnet2h7v743543decg0%40group.calendar.google.com&amp;color=%2342104A&amp;ctz=America%2FLos_Angeles" style= " border-width:0 " width= "512" height= "256" frameborder= "0" scrolling= "no"></iframe>

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. <span class="done DONE">DONE</span> 1.1</a></li>
<li><a href="#sec-2">2. <span class="done DONE">DONE</span> 1.2</a></li>
<li><a href="#sec-3">3. <span class="done DONE">DONE</span> 1.3</a></li>
<li><a href="#sec-4">4. <span class="done DONE">DONE</span> 1.4</a></li>
<li><a href="#sec-5">5. <span class="done DONE">DONE</span> 1.5</a></li>
<li><a href="#sec-6">6. <span class="done DONE">DONE</span> 1.6</a></li>
<li><a href="#sec-7">7. <span class="done DONE">DONE</span> 1.7</a></li>
<li><a href="#sec-8">8. <span class="done DONE">DONE</span> 1.8</a></li>
<li><a href="#sec-9">9. <span class="done DONE">DONE</span> 1.9</a></li>
<li><a href="#sec-10">10. <span class="done DONE">DONE</span> 1.10</a></li>
<li><a href="#sec-11">11. <span class="done DONE">DONE</span> 1.11</a></li>
<li><a href="#sec-12">12. <span class="done DONE">DONE</span> 1.12</a></li>
<li><a href="#sec-13">13. <span class="done DONE">DONE</span> 1.13</a></li>
<li><a href="#sec-14">14. <span class="done DONE">DONE</span> 1.14</a></li>
<li><a href="#sec-15">15. <span class="done DONE">DONE</span> 1.15</a></li>
<li><a href="#sec-16">16. <span class="done DONE">DONE</span> 1.16</a></li>
<li><a href="#sec-17">17. <span class="done DONE">DONE</span> 1.17</a></li>
<li><a href="#sec-18">18. <span class="done DONE">DONE</span> 1.18</a></li>
<li><a href="#sec-19">19. <span class="done DONE">DONE</span> 1.19</a></li>
<li><a href="#sec-20">20. <span class="done DONE">DONE</span> 1.20</a></li>
<li><a href="#sec-21">21. <span class="todo TODO">TODO</span> 1.21</a></li>
<li><a href="#sec-22">22. <span class="todo TODO">TODO</span> 1.22</a></li>
<li><a href="#sec-23">23. <span class="todo TODO">TODO</span> 1.23</a></li>
<li><a href="#sec-24">24. <span class="todo TODO">TODO</span> 1.24</a></li>
<li><a href="#sec-25">25. <span class="todo TODO">TODO</span> 1.25</a></li>
<li><a href="#sec-26">26. <span class="todo TODO">TODO</span> 1.26</a></li>
<li><a href="#sec-27">27. <span class="todo TODO">TODO</span> 1.27</a></li>
<li><a href="#sec-28">28. <span class="todo TODO">TODO</span> 1.28</a></li>
<li><a href="#sec-29">29. <span class="done DONE">DONE</span> 1.29</a></li>
<li><a href="#sec-30">30. <span class="done DONE">DONE</span> 1.30</a></li>
<li><a href="#sec-31">31. <span class="done DONE">DONE</span> 1.31</a></li>
<li><a href="#sec-32">32. <span class="done DONE">DONE</span> 1.32</a></li>
<li><a href="#sec-33">33. <span class="done DONE">DONE</span> 1.33</a></li>
<li><a href="#sec-34">34. <span class="done DONE">DONE</span> 1.34</a></li>
<li><a href="#sec-35">35. <span class="done DONE">DONE</span> 1.35</a></li>
<li><a href="#sec-36">36. <span class="done DONE">DONE</span> 1.36</a></li>
<li><a href="#sec-37">37. <span class="done DONE">DONE</span> 1.37</a></li>
<li><a href="#sec-38">38. <span class="done DONE">DONE</span> 1.38</a></li>
<li><a href="#sec-39">39. <span class="done DONE">DONE</span> 1.39</a></li>
<li><a href="#sec-40">40. <span class="done DONE">DONE</span> 1.40</a></li>
<li><a href="#sec-41">41. <span class="done DONE">DONE</span> 1.41</a></li>
<li><a href="#sec-42">42. <span class="done DONE">DONE</span> 1.42</a></li>
<li><a href="#sec-43">43. <span class="done DONE">DONE</span> 1.43</a></li>
<li><a href="#sec-44">44. <span class="done DONE">DONE</span> 1.44</a></li>
<li><a href="#sec-45">45. <span class="done DONE">DONE</span> 1.45</a></li>
<li><a href="#sec-46">46. <span class="done DONE">DONE</span> 1.46</a></li>
<li><a href="#sec-47">47. <span class="done DONE">DONE</span> 2.1</a></li>
<li><a href="#sec-48">48. <span class="done DONE">DONE</span> 2.2</a></li>
<li><a href="#sec-49">49. <span class="done DONE">DONE</span> 2.3</a></li>
<li><a href="#sec-50">50. <span class="done DONE">DONE</span> 2.4</a></li>
<li><a href="#sec-51">51. <span class="done DONE">DONE</span> 2.5</a></li>
<li><a href="#sec-52">52. <span class="done DONE">DONE</span> 2.6</a></li>
<li><a href="#sec-53">53. <span class="done DONE">DONE</span> 2.7</a></li>
<li><a href="#sec-54">54. <span class="done DONE">DONE</span> 2.8</a></li>
<li><a href="#sec-55">55. <span class="done DONE">DONE</span> 2.9</a></li>
<li><a href="#sec-56">56. <span class="done DONE">DONE</span> 2.10</a></li>
<li><a href="#sec-57">57. <span class="done DONE">DONE</span> 2.11</a></li>
<li><a href="#sec-58">58. <span class="done DONE">DONE</span> 2.12</a></li>
<li><a href="#sec-59">59. <span class="done DONE">DONE</span> 2.13</a></li>
<li><a href="#sec-60">60. <span class="done DONE">DONE</span> 2.14</a></li>
<li><a href="#sec-61">61. <span class="done DONE">DONE</span> 2.15</a></li>
<li><a href="#sec-62">62. <span class="done DONE">DONE</span> 2.16</a>
<ul>
<li><a href="#sec-62-1">62.1. <span class="todo TODO">TODO</span> Implement simplification</a></li>
</ul>
</li>
<li><a href="#sec-63">63. <span class="done DONE">DONE</span> 2.17</a></li>
<li><a href="#sec-64">64. <span class="done DONE">DONE</span> 2.18</a></li>
<li><a href="#sec-65">65. <span class="done DONE">DONE</span> 2.19</a></li>
<li><a href="#sec-66">66. <span class="done DONE">DONE</span> 2.20</a></li>
<li><a href="#sec-67">67. <span class="done DONE">DONE</span> 2.21</a></li>
<li><a href="#sec-68">68. <span class="done DONE">DONE</span> 2.22</a></li>
<li><a href="#sec-69">69. <span class="done DONE">DONE</span> 2.23</a></li>
<li><a href="#sec-70">70. <span class="done DONE">DONE</span> 2.24</a></li>
<li><a href="#sec-71">71. <span class="done DONE">DONE</span> 2.25</a></li>
<li><a href="#sec-72">72. <span class="done DONE">DONE</span> 2.26</a></li>
<li><a href="#sec-73">73. <span class="done DONE">DONE</span> 2.27</a></li>
<li><a href="#sec-74">74. <span class="done DONE">DONE</span> 2.28</a></li>
<li><a href="#sec-75">75. <span class="done DONE">DONE</span> 2.29</a></li>
<li><a href="#sec-76">76. <span class="done DONE">DONE</span> 2.30</a></li>
<li><a href="#sec-77">77. <span class="done DONE">DONE</span> 2.31</a></li>
<li><a href="#sec-78">78. <span class="done DONE">DONE</span> 2.32</a></li>
<li><a href="#sec-79">79. <span class="done DONE">DONE</span> 2.33</a></li>
<li><a href="#sec-80">80. <span class="done DONE">DONE</span> 2.34</a></li>
<li><a href="#sec-81">81. <span class="done DONE">DONE</span> 2.35</a></li>
<li><a href="#sec-82">82. <span class="done DONE">DONE</span> 2.36</a></li>
<li><a href="#sec-83">83. <span class="done DONE">DONE</span> 2.37</a></li>
<li><a href="#sec-84">84. <span class="done DONE">DONE</span> 2.38</a></li>
<li><a href="#sec-85">85. <span class="done DONE">DONE</span> 2.39</a></li>
<li><a href="#sec-86">86. <span class="done DONE">DONE</span> 2.40</a></li>
<li><a href="#sec-87">87. <span class="done DONE">DONE</span> 2.41</a></li>
<li><a href="#sec-88">88. <span class="done DONE">DONE</span> 2.42</a></li>
<li><a href="#sec-89">89. <span class="done DONE">DONE</span> 2.43</a></li>
<li><a href="#sec-90">90. <span class="done DONE">DONE</span> 2.44</a></li>
<li><a href="#sec-91">91. <span class="done DONE">DONE</span> 2.45</a></li>
<li><a href="#sec-92">92. <span class="done DONE">DONE</span> 2.46</a></li>
<li><a href="#sec-93">93. <span class="done DONE">DONE</span> 2.47</a></li>
<li><a href="#sec-94">94. <span class="done DONE">DONE</span> 2.48</a></li>
<li><a href="#sec-95">95. <span class="done DONE">DONE</span> 2.49</a></li>
<li><a href="#sec-96">96. <span class="done DONE">DONE</span> 2.50</a></li>
<li><a href="#sec-97">97. <span class="done DONE">DONE</span> 2.51</a></li>
<li><a href="#sec-98">98. <span class="done DONE">DONE</span> 2.52</a></li>
<li><a href="#sec-99">99. <span class="done DONE">DONE</span> 2.53</a></li>
<li><a href="#sec-100">100. <span class="done DONE">DONE</span> 2.54</a></li>
<li><a href="#sec-101">101. <span class="done DONE">DONE</span> 2.55</a></li>
<li><a href="#sec-102">102. <span class="done DONE">DONE</span> 2.56</a></li>
<li><a href="#sec-103">103. <span class="done DONE">DONE</span> 2.57</a></li>
<li><a href="#sec-104">104. <span class="done DONE">DONE</span> 2.58</a></li>
<li><a href="#sec-105">105. <span class="done DONE">DONE</span> 2.59</a></li>
<li><a href="#sec-106">106. <span class="done DONE">DONE</span> 2.60</a></li>
<li><a href="#sec-107">107. <span class="done DONE">DONE</span> 2.61</a></li>
<li><a href="#sec-108">108. <span class="done DONE">DONE</span> 2.62</a></li>
<li><a href="#sec-109">109. <span class="done DONE">DONE</span> 2.63</a></li>
<li><a href="#sec-110">110. <span class="done DONE">DONE</span> 2.64</a>
<ul>
<li><a href="#sec-110-1">110.1. <span class="todo TODO">TODO</span> Some sort of power-law with nodes vs. invocations of partial-tree.</a></li>
</ul>
</li>
<li><a href="#sec-111">111. <span class="done DONE">DONE</span> 2.65</a></li>
<li><a href="#sec-112">112. <span class="done DONE">DONE</span> 2.66</a></li>
<li><a href="#sec-113">113. <span class="done DONE">DONE</span> 2.67</a></li>
<li><a href="#sec-114">114. <span class="done DONE">DONE</span> 2.68</a></li>
<li><a href="#sec-115">115. <span class="done DONE">DONE</span> 2.69</a></li>
<li><a href="#sec-116">116. <span class="done DONE">DONE</span> 2.70</a></li>
<li><a href="#sec-117">117. <span class="done DONE">DONE</span> 2.71</a></li>
<li><a href="#sec-118">118. <span class="done DONE">DONE</span> 2.72</a></li>
<li><a href="#sec-119">119. <span class="done DONE">DONE</span> 2.73</a></li>
<li><a href="#sec-120">120. <span class="done DONE">DONE</span> 2.74</a></li>
<li><a href="#sec-121">121. <span class="done DONE">DONE</span> 2.75</a></li>
<li><a href="#sec-122">122. <span class="done DONE">DONE</span> 2.76</a></li>
<li><a href="#sec-123">123. <span class="done DONE">DONE</span> 2.77</a></li>
<li><a href="#sec-124">124. <span class="done DONE">DONE</span> 2.78</a></li>
<li><a href="#sec-125">125. <span class="done DONE">DONE</span> 2.79</a></li>
<li><a href="#sec-126">126. <span class="done DONE">DONE</span> 2.80</a></li>
<li><a href="#sec-127">127. <span class="done DONE">DONE</span> 2.81</a></li>
<li><a href="#sec-128">128. <span class="done DONE">DONE</span> 2.82</a></li>
<li><a href="#sec-129">129. <span class="done DONE">DONE</span> 2.83</a></li>
<li><a href="#sec-130">130. <span class="done DONE">DONE</span> 2.84</a></li>
<li><a href="#sec-131">131. <span class="done DONE">DONE</span> 2.85</a></li>
<li><a href="#sec-132">132. <span class="done DONE">DONE</span> 2.86</a></li>
<li><a href="#sec-133">133. <span class="done DONE">DONE</span> 2.87</a></li>
<li><a href="#sec-134">134. <span class="done DONE">DONE</span> 2.88</a></li>
<li><a href="#sec-135">135. <span class="done DONE">DONE</span> 2.89</a></li>
<li><a href="#sec-136">136. <span class="done DONE">DONE</span> 2.90</a></li>
<li><a href="#sec-137">137. <span class="done DONE">DONE</span> 2.91</a></li>
<li><a href="#sec-138">138. <span class="todo TODO">TODO</span> 2.92</a></li>
<li><a href="#sec-139">139. <span class="done DONE">DONE</span> 2.93</a></li>
<li><a href="#sec-140">140. <span class="done DONE">DONE</span> 2.94</a></li>
<li><a href="#sec-141">141. <span class="done DONE">DONE</span> 2.95</a></li>
<li><a href="#sec-142">142. <span class="done DONE">DONE</span> 2.96</a></li>
<li><a href="#sec-143">143. <span class="done DONE">DONE</span> 2.97</a></li>
<li><a href="#sec-144">144. <span class="done DONE">DONE</span> 3.1</a></li>
<li><a href="#sec-145">145. <span class="done DONE">DONE</span> 3.2</a></li>
<li><a href="#sec-146">146. <span class="done DONE">DONE</span> 3.3</a></li>
<li><a href="#sec-147">147. <span class="done DONE">DONE</span> 3.4</a></li>
<li><a href="#sec-148">148. <span class="done DONE">DONE</span> 3.5</a></li>
<li><a href="#sec-149">149. <span class="done DONE">DONE</span> 3.6</a></li>
<li><a href="#sec-150">150. <span class="done DONE">DONE</span> 3.7</a></li>
<li><a href="#sec-151">151. <span class="done DONE">DONE</span> 3.8</a></li>
<li><a href="#sec-152">152. <span class="done DONE">DONE</span> 3.9</a></li>
<li><a href="#sec-153">153. <span class="done DONE">DONE</span> 3.10</a></li>
<li><a href="#sec-154">154. <span class="done DONE">DONE</span> 3.11</a></li>
<li><a href="#sec-155">155. <span class="done DONE">DONE</span> 3.12</a></li>
<li><a href="#sec-156">156. <span class="done DONE">DONE</span> 3.13</a></li>
<li><a href="#sec-157">157. <span class="done DONE">DONE</span> 3.14</a></li>
<li><a href="#sec-158">158. <span class="done DONE">DONE</span> 3.15</a></li>
<li><a href="#sec-159">159. <span class="done DONE">DONE</span> 3.16</a></li>
<li><a href="#sec-160">160. <span class="done DONE">DONE</span> 3.17</a></li>
<li><a href="#sec-161">161. <span class="done DONE">DONE</span> 3.18</a></li>
<li><a href="#sec-162">162. <span class="done DONE">DONE</span> 3.19</a></li>
<li><a href="#sec-163">163. <span class="done DONE">DONE</span> 3.20</a></li>
<li><a href="#sec-164">164. <span class="done DONE">DONE</span> 3.21</a></li>
<li><a href="#sec-165">165. <span class="done DONE">DONE</span> 3.22</a></li>
<li><a href="#sec-166">166. <span class="done DONE">DONE</span> 3.23</a></li>
<li><a href="#sec-167">167. <span class="done DONE">DONE</span> 3.24</a></li>
<li><a href="#sec-168">168. <span class="done DONE">DONE</span> 3.25</a></li>
<li><a href="#sec-169">169. <span class="done DONE">DONE</span> 3.26</a></li>
<li><a href="#sec-170">170. <span class="done DONE">DONE</span> 3.27</a></li>
<li><a href="#sec-171">171. <span class="done DONE">DONE</span> 3.28</a></li>
<li><a href="#sec-172">172. <span class="done DONE">DONE</span> 3.29</a></li>
<li><a href="#sec-173">173. <span class="done DONE">DONE</span> 3.30</a></li>
<li><a href="#sec-174">174. <span class="todo TODO">TODO</span> 3.31</a></li>
<li><a href="#sec-175">175. <span class="todo TODO">TODO</span> 3.32</a></li>
<li><a href="#sec-176">176. <span class="done DONE">DONE</span> 3.33</a></li>
<li><a href="#sec-177">177. <span class="done DONE">DONE</span> 3.34</a></li>
<li><a href="#sec-178">178. <span class="done DONE">DONE</span> 3.35</a></li>
<li><a href="#sec-179">179. <span class="done DONE">DONE</span> 3.36</a></li>
<li><a href="#sec-180">180. <span class="done DONE">DONE</span> 3.37</a></li>
<li><a href="#sec-181">181. <span class="done DONE">DONE</span> 3.38</a></li>
<li><a href="#sec-182">182. <span class="done DONE">DONE</span> 3.39</a></li>
<li><a href="#sec-183">183. <span class="done DONE">DONE</span> 3.40</a></li>
<li><a href="#sec-184">184. <span class="todo TODO">TODO</span> 3.41</a></li>
<li><a href="#sec-185">185. <span class="done DONE">DONE</span> 3.42</a></li>
<li><a href="#sec-186">186. <span class="done DONE">DONE</span> 3.43</a></li>
<li><a href="#sec-187">187. <span class="done DONE">DONE</span> 3.44</a></li>
<li><a href="#sec-188">188. <span class="done DONE">DONE</span> 3.45</a></li>
<li><a href="#sec-189">189. <span class="done DONE">DONE</span> 3.46</a></li>
<li><a href="#sec-190">190. <span class="done DONE">DONE</span> 3.47</a></li>
<li><a href="#sec-191">191. <span class="done DONE">DONE</span> 3.48</a></li>
<li><a href="#sec-192">192. <span class="done DONE">DONE</span> 3.49</a></li>
<li><a href="#sec-193">193. <span class="done DONE">DONE</span> 3.50</a></li>
<li><a href="#sec-194">194. <span class="done DONE">DONE</span> 3.51</a></li>
<li><a href="#sec-195">195. <span class="done DONE">DONE</span> 3.52</a></li>
<li><a href="#sec-196">196. <span class="done DONE">DONE</span> 3.53</a></li>
<li><a href="#sec-197">197. <span class="done DONE">DONE</span> 3.54</a></li>
<li><a href="#sec-198">198. <span class="done DONE">DONE</span> 3.55</a></li>
<li><a href="#sec-199">199. <span class="done DONE">DONE</span> 3.56</a></li>
<li><a href="#sec-200">200. <span class="done DONE">DONE</span> 3.57</a></li>
<li><a href="#sec-201">201. <span class="done DONE">DONE</span> 3.58</a></li>
<li><a href="#sec-202">202. <span class="done DONE">DONE</span> 3.59</a></li>
<li><a href="#sec-203">203. <span class="done DONE">DONE</span> 3.60</a></li>
<li><a href="#sec-204">204. <span class="done DONE">DONE</span> 3.61</a></li>
<li><a href="#sec-205">205. <span class="done DONE">DONE</span> 3.62</a></li>
<li><a href="#sec-206">206. <span class="done DONE">DONE</span> 3.63</a></li>
<li><a href="#sec-207">207. <span class="done DONE">DONE</span> 3.64</a></li>
<li><a href="#sec-208">208. <span class="done DONE">DONE</span> 3.65</a></li>
<li><a href="#sec-209">209. <span class="todo TODO">TODO</span> 3.66</a></li>
<li><a href="#sec-210">210. <span class="done DONE">DONE</span> 3.67</a></li>
<li><a href="#sec-211">211. <span class="done DONE">DONE</span> 3.68</a></li>
<li><a href="#sec-212">212. <span class="done DONE">DONE</span> 3.69</a></li>
<li><a href="#sec-213">213. <span class="done DONE">DONE</span> 3.70</a></li>
<li><a href="#sec-214">214. <span class="done DONE">DONE</span> 3.71</a></li>
<li><a href="#sec-215">215. <span class="done DONE">DONE</span> 3.72</a></li>
<li><a href="#sec-216">216. <span class="done DONE">DONE</span> 3.73</a></li>
<li><a href="#sec-217">217. <span class="done DONE">DONE</span> 3.74</a></li>
<li><a href="#sec-218">218. <span class="todo TODO">TODO</span> 3.75</a></li>
<li><a href="#sec-219">219. Notes</a>
<ul>
<li><a href="#sec-219-1">219.1. 1</a></li>
<li><a href="#sec-219-2">219.2. 2</a></li>
<li><a href="#sec-219-3">219.3. 3</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> <span class="done DONE">DONE</span> 1.1</h2>
<div class="outline-text-2" id="text-1">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(test 10 10)
(test 12 (+ 5 3 4))
(test 8 (- 9 1))
(test 3 (/ 6 2))
(test 6 (+ (* 2 4) (- 4 6)))
(<span class="org-keyword">define</span> <span class="org-function-name">a</span> 3)
(<span class="org-keyword">define</span> <span class="org-function-name">b</span> (+ a 1))
(test 19 (+ a b (* a b)))
(test #f (= a b))
(test 4
      (<span class="org-keyword">if</span> (<span class="org-keyword">and</span> (&gt; b a) (&lt; b (* a b)))
          b
          a))
(test 16
      (<span class="org-keyword">cond</span> ((= a 4) 6)
            ((= b 4) (+ 6 7 a))
            (<span class="org-keyword">else</span> 25)))
(test 6
      (+ 2 (<span class="org-keyword">if</span> (&gt; b a) b a)))
(test 16
      (* (<span class="org-keyword">cond</span> ((&gt; a b) a)
               ((&lt; a b) b)
               (<span class="org-keyword">else</span> -1))
         (+ a 1)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> <span class="done DONE">DONE</span> 1.2</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">

<pre class="src src-scheme">(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))
   (* 3 (- 5 2) (- 7 2)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> <span class="done DONE">DONE</span> 1.3</h2>
<div class="outline-text-2" id="text-3">
<p>
This feels a little cheap using sort:
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use data-structures test)

(<span class="org-keyword">define</span> (<span class="org-function-name">square</span> x x) (* x x))

(<span class="org-keyword">define</span> (<span class="org-function-name">sum-of-squares</span> x y)
  (+ (square x x) (square y y)))

(<span class="org-keyword">define</span> (<span class="org-function-name">sum-of-largest-two-squares</span> a b c)
  (apply sum-of-squares (cdr (sort (list a b c) &lt;))))

(test 13 (sum-of-largest-two-squares 1 2 3))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> <span class="done DONE">DONE</span> 1.4</h2>
<div class="outline-text-2" id="text-4">
<p>
<code>(if (&gt; b 0) + -)</code> evaluates to either the procedure <code>+</code> or <code>-</code>,
which is then applied to the operands <code>(a b)</code>.
</p>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> <span class="done DONE">DONE</span> 1.5</h2>
<div class="outline-text-2" id="text-5">
<p>
This is how you might emulate normal order evaluation using thunks:
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">normal-test</span> x y)
  ((<span class="org-keyword">if</span> (= (x) 0)
       (<span class="org-keyword">lambda</span> () 0)
       y)))

(<span class="org-keyword">define</span> (<span class="org-function-name">p</span>) (p))

(test 0 (normal-test (<span class="org-keyword">lambda</span> () 0) p))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> <span class="done DONE">DONE</span> 1.6</h2>
<div class="outline-text-2" id="text-6">
<p>
Since <code>new-if</code> is applicative, it evaluates the next <code>sqrt-iter</code>
regardless of whether <code>good-enough?</code> is true; this results in
infinite recursion.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp)

(<span class="org-keyword">define</span> (<span class="org-function-name">improve</span> guess x)
  (average guess (/ x guess)))

(<span class="org-keyword">define</span> (<span class="org-function-name">sqrt-iter</span> guess x)
  (<span class="org-keyword">if</span> (good-enough? (square guess) x)
      guess
      (sqrt-iter (improve guess x) x)))

(<span class="org-keyword">define</span> <span class="org-function-name">sqrt-newton</span>
  (case-lambda
   ((x) (sqrt-newton sqrt-iter x))
   ((sqrt-iter x) (sqrt-iter 1.0 x))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(include <span class="org-string">"sqrt.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">new-if</span> predicate then-clause else-clause)
  (<span class="org-keyword">cond</span> (predicate then-clause)
        (<span class="org-keyword">else</span> else-clause)))

(<span class="org-keyword">define</span> (<span class="org-function-name">sqrt-iter/new-if</span> guess x)
  (new-if (good-enough? (square guess) x)
          guess
          (sqrt-iter/new-if (improve guess x) x)))

(parameterize ((current-test-epsilon 0.0001)
               (epsilon 0.01))
  (test <span class="org-string">"Iterative square-root"</span> 3.0 (sqrt-newton 9)))

(test-assert
 <span class="org-string">"Iterative square-root with applicative conditional"</span>
 (not (terminates? (<span class="org-keyword">lambda</span> () (sqrt-newton sqrt-iter/new-if 9)))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> <span class="done DONE">DONE</span> 1.7</h2>
<div class="outline-text-2" id="text-7">
<p>
Due to compounded rounding-errors, 0.001 is already off by about
30%:
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(load <span class="org-string">"sqrt.scm"</span>)

(test
 <span class="org-string">"Na&#239;ve Newton-square-root off by 30% for 0.001"</span>
 0.304295
 (/ (abs (- (sqrt-newton 0.001)
            (sqrt 0.001)))
    (sqrt 0.001)))
</pre>
</div>

<p>
Whereas the delta-based square-root is still pretty good, even at
0.00001:
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> <span class="org-function-name">epsilon</span> (make-parameter 0.00001))

(<span class="org-keyword">define</span> (<span class="org-function-name">square</span> x) (* x x))

(<span class="org-keyword">define</span> (<span class="org-function-name">good-enough?</span> old-guess guess)
  (&lt; (abs (- old-guess guess)) (epsilon)))

(<span class="org-keyword">define</span> (<span class="org-function-name">average</span> x y) (/ (+ x y) 2))

(<span class="org-keyword">define</span> (<span class="org-function-name">improve</span> guess x)
  (average guess (/ x guess)))

(<span class="org-keyword">define</span> (<span class="org-function-name">sqrt-iter</span> old-guess guess x)
  (<span class="org-keyword">if</span> (good-enough? old-guess guess)
      guess
      (sqrt-iter guess (improve guess x) x)))

(<span class="org-keyword">define</span> (<span class="org-function-name">sqrt-newton-delta</span> x) (sqrt-iter 0.0 1.0 x))

(test <span class="org-string">"Square-root with delta-based `good-enough?'"</span>
      3.0
      (sqrt-newton-delta 9))

(test
 <span class="org-string">"Square-root-Newton-delta is pretty good."</span>
 (sqrt 0.00001)
 (sqrt-newton-delta 0.00001))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> <span class="done DONE">DONE</span> 1.8</h2>
<div class="outline-text-2" id="text-8">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> <span class="org-function-name">epsilon</span> (make-parameter 0.00001))

(<span class="org-keyword">define</span> (<span class="org-function-name">square</span> x) (* x x))

(<span class="org-keyword">define</span> (<span class="org-function-name">good-enough?</span> old-guess guess)
  (&lt; (abs (- old-guess guess)) (epsilon)))

(<span class="org-keyword">define</span> (<span class="org-function-name">average</span> x y) (/ (+ x y) 2))

(<span class="org-keyword">define</span> (<span class="org-function-name">improve-square</span> guess x)
  (average guess (/ x guess)))

(<span class="org-keyword">define</span> (<span class="org-function-name">improve-cube</span> guess x)
  (/ (+ (/ x (square guess)) (* 2 guess)) 3))

(<span class="org-keyword">define</span> (<span class="org-function-name">sqrt-iter</span> old-guess guess x improve)
  (<span class="org-keyword">if</span> (good-enough? old-guess guess)
      guess
      (sqrt-iter guess (improve guess x) x improve)))

(<span class="org-keyword">define</span> (<span class="org-function-name">sqrt-newton-delta</span> x) (sqrt-iter 0.0 1.0 x improve-square))

(<span class="org-keyword">define</span> (<span class="org-function-name">cbrt-newton-delta</span> x) (sqrt-iter 0.0 1.0 x improve-cube))

(test <span class="org-string">"Delta-based cube-root"</span>
      3.0
      (cbrt-newton-delta 27))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> <span class="done DONE">DONE</span> 1.9</h2>
<div class="outline-text-2" id="text-9">
<p>
This is a recursive process:
</p>

<div class="org-src-container">

<pre class="src src-scheme">(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
</pre>
</div>

<p>
This is an iterative process:
</p>

<div class="org-src-container">

<pre class="src src-scheme">(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> <span class="done DONE">DONE</span> 1.10</h2>
<div class="outline-text-2" id="text-10">
<p>
\(f(n) = 2n\); \(g(n) = 2^n\); and \(h(n) = 2 ^ {2 ^ {... ^ {n - 1}}}\).
</p>
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">A</span> x y)
  (<span class="org-keyword">cond</span> ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (<span class="org-keyword">else</span> (A (- x 1)
                 (A x (- y 1))))))

(test 1024 (A 1 10))
(test 65536 (A 2 4))
(test 65536 (A 3 3))

(<span class="org-keyword">define</span> (<span class="org-function-name">f</span> n) (A 0 n))
(<span class="org-keyword">define</span> (<span class="org-function-name">f-prime</span> n) (* 2 n))

(<span class="org-keyword">define</span> (<span class="org-function-name">g</span> n) (A 1 n))
(<span class="org-keyword">define</span> (<span class="org-function-name">g-prime</span> n)
   (expt 2 n))

 (<span class="org-keyword">define</span> (<span class="org-function-name">h</span> n) (A 2 n))
 (<span class="org-keyword">define</span> (<span class="org-function-name">h-prime</span> n)
   (<span class="org-keyword">if</span> (= n 1)
       2
       (expt 2 (h-prime (- n 1)))))

 (test <span class="org-string">"f(n) = f'(n)"</span> (f 10) (f-prime 10))
 (test <span class="org-string">"g(n) = g'(n)"</span> (g 10) (g-prime 10))
 (test <span class="org-string">"h(n) = h'(n)"</span> (h 4) (h-prime 4))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> <span class="done DONE">DONE</span> 1.11</h2>
<div class="outline-text-2" id="text-11">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">f</span> n)
  (<span class="org-keyword">if</span> (&lt; n 3)
      n
      (+ (f (- n 1))
         (* 2 (f (- n 2)))
         (* 3 (f (- n 3))))))

(test <span class="org-string">"Recursive f"</span> 796 (f 9))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">f</span> n)
  (f-iter 2 1 0 (- n 2)))

(<span class="org-keyword">define</span> (<span class="org-function-name">f-iter</span> a b c n)
  (<span class="org-keyword">if</span> (zero? n)
      a
      (f-iter (+ a (* 2 b) (* 3 c))
              a
              b
              (- n 1))))

(test <span class="org-string">"Iterative f"</span> 796 (f 9))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> <span class="done DONE">DONE</span> 1.12</h2>
<div class="outline-text-2" id="text-12">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">pascal</span> row element)
  (<span class="org-keyword">cond</span> ((<span class="org-keyword">or</span> (zero? element)
             (= row element))
         1)
        ((negative? row) 0)
        (<span class="org-keyword">else</span>
         (+ (pascal (- row 1)
                    (- element 1))
            (pascal (- row 1)
                    element)))))

(<span class="org-keyword">define</span> (<span class="org-function-name">pascal-row</span> row)
  (<span class="org-keyword">let</span> <span class="org-function-name">iter</span> ((element 0)
             (elements '()))
    (<span class="org-keyword">if</span> (&gt; element row)
        elements
        (iter (+ element 1)
              (cons (pascal row element) elements)))))

(test 2 (pascal 2 1))
(test 3 (pascal 3 1))
(test '(1 3 3 1) (pascal-row 3))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13"><span class="section-number-2">13</span> <span class="done DONE">DONE</span> 1.13</h2>
<div class="outline-text-2" id="text-13">
<p>
Prove that the base case holds:
</p>

\begin{align}
Fib(0) = (\phi^0 - \psi^0) = 0
\end{align}

<p>
Assume \(Fib(k)\) holds; then show that \(Fib(k + 1)\) holds:
</p>

\begin{align}
Fib(k + 1) = \frac{\phi^{k + 1} - \psi^{k + 1}}{\sqrt{5}}
\end{align}

<p>
And because \(Fib(k + 1) = Fib(k) + Fib(k - 1)\):
</p>

\begin{align}
Fib(k) + Fib(k - 1) &= \frac{\phi^{k + 1} - \psi^{k + 1}}{\sqrt{5}} \\

\frac{\phi^{k} - \psi^{k}}{\sqrt{5}} + \frac{\phi^{k - 1} -
\psi^{k - 1}}{\sqrt{5}} &= \frac{\phi^{k + 1} - \psi^{k + 1}}{\sqrt{5}} \\

\phi^{k} - \psi^{k} + \phi^{k - 1} - \psi^{k - 1} &= \phi^{k + 1} - \psi^{k + 1} \\

\phi^{k} + \phi^{k - 1} - \phi^{k + 1} &= \psi^{k} + \psi^{k - 1} -
\psi^{k + 1} \\

\phi^{k}(1 + \frac{1}{\phi} - \phi) &= \psi^{k}(1 + \frac{1}{\psi} -
\psi)

\end{align}

<p>
Because \(1 + \frac{1}{\phi} = \phi\) and, similarly, \(1 + \frac{1}{\psi} =
  \psi\):
</p>

\begin{align}
\phi^{k}(0) &= \psi^{k}(0) \\

0 &= 0
\end{align}
</div>
</div>
<div id="outline-container-sec-14" class="outline-2">
<h2 id="sec-14"><span class="section-number-2">14</span> <span class="done DONE">DONE</span> 1.14</h2>
<div class="outline-text-2" id="text-14">
<p>
Although most of these possibilities are pruned away by the
algorithm, worst case: has to try a complete \(k\)-ary tree (where \(k
  = 5\)) of length \(n\), where \(n\) is the longest change (i.e. \(n\)
pennies); it only has to store \(n\) calls, however, to the depth of
the tree.
</p>


<div class="figure">
<p><img src="1.14.png" alt="1.14.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-sec-15" class="outline-2">
<h2 id="sec-15"><span class="section-number-2">15</span> <span class="done DONE">DONE</span> 1.15</h2>
<div class="outline-text-2" id="text-15">
<p>
Number of steps is roughly the cubed-root of \(n\) (\(\sqrt[3]{n}\));
space is the same, too.
</p>

<p>
Some relationship to precision, too:
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> <span class="org-function-name">count</span> (make-parameter 0))

(<span class="org-keyword">define</span> (<span class="org-function-name">cube</span> x) (* x x x))
(<span class="org-keyword">define</span> (<span class="org-function-name">p</span> x) (- (* 3 x) (* 4 (cube x))))
(<span class="org-keyword">define</span> (<span class="org-function-name">sine</span> angle)
  (count (+ (count) 1))
  (<span class="org-keyword">if</span> (not (&gt; (abs angle) 0.1))
      angle
      (p (sine (/ angle 3.0)))))

(parameterize ((count 0))
  (sine 12.15)
  (test 6 (count)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-16" class="outline-2">
<h2 id="sec-16"><span class="section-number-2">16</span> <span class="done DONE">DONE</span> 1.16</h2>
<div class="outline-text-2" id="text-16">
<p>
The process works by taking advantage of squares when it can, and
reduces odds to twos when it must:
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">square</span> n) (* n n))

<span class="org-comment-delimiter">;; </span><span class="org-warning">TODO</span><span class="org-comment">: I'm uncomfortable with these special cases here; a better</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">way?</span>
(<span class="org-keyword">define</span> (<span class="org-function-name">fast-expt</span> b n)
  (<span class="org-keyword">cond</span> ((zero? n) 1)
        ((= n 1) b)
        (<span class="org-keyword">else</span> (fast-expt-iter b n 1))))

(<span class="org-keyword">define</span> (<span class="org-function-name">fast-expt-iter</span> b n a)
  (<span class="org-keyword">cond</span> ((= n 1) a)
        ((even? n)
         (fast-expt-iter b (/ n 2) (* (square b) a)))
        (<span class="org-keyword">else</span> (fast-expt-iter b (- n 1) (* b a)))))

(test 1 (fast-expt 2 0))
(test 2 (fast-expt 2 1))
(test 4 (fast-expt 2 2))
(test 8 (fast-expt 2 3))
(test 16 (fast-expt 2 4))
(test 32 (fast-expt 2 5))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-17" class="outline-2">
<h2 id="sec-17"><span class="section-number-2">17</span> <span class="done DONE">DONE</span> 1.17</h2>
<div class="outline-text-2" id="text-17">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">double</span> n) (* n 2))

(<span class="org-keyword">define</span> (<span class="org-function-name">halve</span> n) (/ n 2))

(<span class="org-keyword">define</span> (<span class="org-function-name">fast-*</span> a b)
  (<span class="org-keyword">cond</span> ((zero? b) 0)
        ((even? b) (double (fast-* a (halve b))))
        (<span class="org-keyword">else</span> (+ a (fast-* a (- b 1))))))

(test 20 (fast-* 4 5))
(test 56 (fast-* 8 7))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-18" class="outline-2">
<h2 id="sec-18"><span class="section-number-2">18</span> <span class="done DONE">DONE</span> 1.18</h2>
<div class="outline-text-2" id="text-18">
<p>
The invariant is \(c + ab\); the trick, however, is that doubling \(a\)
and halving \(b\) is a noöp with respect to \(c\):
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">double</span> n) (* n 2))

(<span class="org-keyword">define</span> (<span class="org-function-name">halve</span> n) (/ n 2))

(<span class="org-keyword">define</span> (<span class="org-function-name">fast-*</span> a b)
  (fast-*-iter a b 0))

(<span class="org-keyword">define</span> (<span class="org-function-name">fast-*-iter</span> a b c)
  (<span class="org-keyword">cond</span> ((= b 0) c)
        ((even? b) (fast-*-iter (double a) (halve b) c))
        (<span class="org-keyword">else</span> (fast-*-iter a (- b 1) (+ c a)))))

(test 20 (fast-* 4 5))
(test 56 (fast-* 7 8))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-19" class="outline-2">
<h2 id="sec-19"><span class="section-number-2">19</span> <span class="done DONE">DONE</span> 1.19</h2>
<div class="outline-text-2" id="text-19">
<p>
See <a href="http://ldc.usb.ve/~mosquera/Algoritmos/AlgoritmosI/Teoria/ene-mar-2008/Kaldewaij%2520-%2520Prentice%2520Hall%2520-%2520Programming.%2520The%2520Derivation%2520of%2520Algorithms.pdf">Kaldewaij, 1990</a> [<a href="papers/kaldewaij-programming.pdf">local</a>], page 88; where \(p^\prime = p^2 + q^2\)
and \(q^\prime = pq + qp + q^2\):
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">square</span> n) (* n n))

(<span class="org-keyword">define</span> (<span class="org-function-name">fib</span> n)
  (fib-iter 1 0 0 1 n))

(<span class="org-keyword">define</span> (<span class="org-function-name">fib-iter</span> a b p q count)
  (<span class="org-keyword">cond</span> ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   (+ (square p) (square q))
                   (+ (* 2 (* p q))
                      (square q))
                   (/ count 2)))
        (<span class="org-keyword">else</span> (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))

(test 55 (fib 10))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-20" class="outline-2">
<h2 id="sec-20"><span class="section-number-2">20</span> <span class="done DONE">DONE</span> 1.20</h2>
<div class="outline-text-2" id="text-20">
<p>
<code>remainder</code> is called 4 times:
</p>

<div class="org-src-container">

<pre class="src src-scheme">(gcd 206 40)
(gcd 40 (remainder 206 40))
(gcd 40 6)
(gcd 6 (remainder 40 6))
(gcd 6 4)
(gcd 4 (remainder 6 4))
(gcd 2 2)
(gcd 2 (remainder 2 2))
(gcd 2 0)
(display <span class="org-string">"hello, org"</span>)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> <span class="org-function-name">count</span> (make-parameter 0))

(<span class="org-keyword">define</span> (<span class="org-function-name">remainder-count</span> a b)
  (count (+ (count) 1))
  (remainder a b))

(<span class="org-keyword">define</span> (<span class="org-function-name">gcd</span> a b)
  (<span class="org-keyword">if</span> (= b 0)
      a
      (gcd b (remainder-count a b))))

(parameterize ((count 0))
  (gcd 206 40)
  (test 4 (count)))
</pre>
</div>

<p>
Using applicative, it’s called also called 4 times before
divide-by-zero on the fifth call:
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> <span class="org-function-name">count</span> (make-parameter 0))

(<span class="org-keyword">define</span> (<span class="org-function-name">remainder-count</span> a b)
  (count (+ (count) 1))
  (remainder a b))

(<span class="org-keyword">define</span> (<span class="org-function-name">new-if</span> predicate then-clause else-clause)
  (<span class="org-keyword">cond</span> (predicate then-clause)
        (<span class="org-keyword">else</span> else-clause)))

(<span class="org-keyword">define</span> (<span class="org-function-name">gcd</span> a b)
  (new-if (= b 0)
      a
      (gcd b (remainder-count a b))))

(trace remainder-count)

(parameterize ((count 0))
  (gcd 206 40)
  (test 4 (count)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-21" class="outline-2">
<h2 id="sec-21"><span class="section-number-2">21</span> <span class="todo TODO">TODO</span> 1.21</h2>
</div>
<div id="outline-container-sec-22" class="outline-2">
<h2 id="sec-22"><span class="section-number-2">22</span> <span class="todo TODO">TODO</span> 1.22</h2>
</div>
<div id="outline-container-sec-23" class="outline-2">
<h2 id="sec-23"><span class="section-number-2">23</span> <span class="todo TODO">TODO</span> 1.23</h2>
</div>
<div id="outline-container-sec-24" class="outline-2">
<h2 id="sec-24"><span class="section-number-2">24</span> <span class="todo TODO">TODO</span> 1.24</h2>
</div>
<div id="outline-container-sec-25" class="outline-2">
<h2 id="sec-25"><span class="section-number-2">25</span> <span class="todo TODO">TODO</span> 1.25</h2>
</div>
<div id="outline-container-sec-26" class="outline-2">
<h2 id="sec-26"><span class="section-number-2">26</span> <span class="todo TODO">TODO</span> 1.26</h2>
</div>
<div id="outline-container-sec-27" class="outline-2">
<h2 id="sec-27"><span class="section-number-2">27</span> <span class="todo TODO">TODO</span> 1.27</h2>
</div>
<div id="outline-container-sec-28" class="outline-2">
<h2 id="sec-28"><span class="section-number-2">28</span> <span class="todo TODO">TODO</span> 1.28</h2>
</div>
<div id="outline-container-sec-29" class="outline-2">
<h2 id="sec-29"><span class="section-number-2">29</span> <span class="done DONE">DONE</span> 1.29</h2>
<div class="outline-text-2" id="text-29">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">cube</span> x) (* x x x))

(<span class="org-keyword">define</span> (<span class="org-function-name">inc</span> n) (+ n 1))

(<span class="org-keyword">define</span> (<span class="org-function-name">sum</span> term a next b)
  (<span class="org-keyword">if</span> (&gt; a b)
      0
      (+ (term a)
         (sum term (next a) next b))))

(<span class="org-keyword">define</span> (<span class="org-function-name">integral</span> f a b dx)
  (<span class="org-keyword">define</span> (<span class="org-function-name">add-dx</span> x) (+ x dx))
  (* (sum f (+ a (/ dx 2.0)) add-dx b) dx))

(<span class="org-keyword">define</span> (<span class="org-function-name">simpsons-rule</span> f a b n)
  (<span class="org-keyword">let</span> ((h (/ (- b a) n)))
    (* (/ h 3)
       (sum (<span class="org-keyword">lambda</span> (k)
              (<span class="org-keyword">let</span> ((coefficient
                     (<span class="org-keyword">cond</span> ((<span class="org-keyword">or</span> (zero? k) (= k n)) 1)
                           ((odd? k ) 4)
                           (<span class="org-keyword">else</span> 2))))
                (* coefficient (f (+ a (* k h))))))
            0
            inc
            n))))

(test
 <span class="org-string">"Simpson's rule is correct for cube, 0, 1; even at n = 100."</span>
 0.25
 (simpsons-rule cube 0 1 100))

(test
 <span class="org-string">"Simpson's rule differs from the na&#239;ve integral a little."</span>
 0.000000124999999268072
 (abs
  (- (simpsons-rule cube 0 1 1000)
     (integral cube 0 1 0.001))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-30" class="outline-2">
<h2 id="sec-30"><span class="section-number-2">30</span> <span class="done DONE">DONE</span> 1.30</h2>
<div class="outline-text-2" id="text-30">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">inc</span> n) (+ n 1))

(<span class="org-keyword">define</span> (<span class="org-function-name">cube</span> x) (* x x x))

(<span class="org-keyword">define</span> (<span class="org-function-name">sum-cubes</span> a b)
  (sum cube a inc b))

(<span class="org-keyword">define</span> (<span class="org-function-name">sum</span> term a next b)
  (<span class="org-keyword">let</span> <span class="org-function-name">iter</span> ((a a)
             (result 0))
    (<span class="org-keyword">if</span> (&gt; a b)
        result
        (iter (next a) (+ result (term a))))))

(test <span class="org-string">"Iterative sum"</span>
      3025
      (sum-cubes 1 10))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-31" class="outline-2">
<h2 id="sec-31"><span class="section-number-2">31</span> <span class="done DONE">DONE</span> 1.31</h2>
<div class="outline-text-2" id="text-31">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">inc</span> n) (+ n 1))

(<span class="org-keyword">define</span> (<span class="org-function-name">product</span> term a next b)
  (<span class="org-keyword">if</span> (&gt; a b)
      1
      (* (term a) (product term (next a) next b))))

(<span class="org-keyword">define</span> (<span class="org-function-name">factorial</span> n)
  (product identity 1 inc n))

(test 120 (factorial 5))

(<span class="org-keyword">define</span> (<span class="org-function-name">pi</span> n)
  (<span class="org-keyword">define</span> (<span class="org-function-name">numerator-term</span> i)
    (* (ceiling (/ (+ i 2) 2)) 2))
  (<span class="org-keyword">define</span> (<span class="org-function-name">denominator-term</span> i)
    (+ 1 (* (floor (/ (+ i 2) 2)) 2)))
  (* 4 (/ (product numerator-term 0 inc n)
          (product denominator-term  0 inc n))))

(parameterize ((current-test-epsilon 0.1))
  (test 3.1 (pi 100)))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">inc</span> n) (+ n 1))

(<span class="org-keyword">define</span> (<span class="org-function-name">product</span> term a next b)
  (<span class="org-keyword">let</span> <span class="org-function-name">iter</span> ((a a)
             (result 1))
    (<span class="org-keyword">if</span> (&gt; a b)
        result
        (iter (next a) (* result (term a))))))

(<span class="org-keyword">define</span> (<span class="org-function-name">factorial</span> n)
  (product identity 1 inc n))

(test 120 (factorial 5))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-32" class="outline-2">
<h2 id="sec-32"><span class="section-number-2">32</span> <span class="done DONE">DONE</span> 1.32</h2>
<div class="outline-text-2" id="text-32">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">inc</span> n) (+ n 1))

(<span class="org-keyword">define</span> (<span class="org-function-name">accumulate</span> combiner null-value term a next b)
  (<span class="org-keyword">if</span> (&gt; a b)
      null-value
      (combiner (term a)
                (accumulate combiner
                            null-value
                            term
                            (next a)
                            next
                            b))))

(<span class="org-keyword">define</span> (<span class="org-function-name">sum</span> term a next b)
  (accumulate + 0 term a next b))

(<span class="org-keyword">define</span> (<span class="org-function-name">product</span> term a next b)
  (accumulate * 1 term a next b))

(test 15 (sum identity 0 inc 5))
(test 120 (product identity 1 inc 5))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">inc</span> n) (+ n 1))

(<span class="org-keyword">define</span> (<span class="org-function-name">accumulate</span> combiner null-value term a next b)
  (<span class="org-keyword">let</span> <span class="org-function-name">iter</span> ((a a)
             (result null-value))
    (<span class="org-keyword">if</span> (&gt; a b)
        result
        (iter (next a)
              (combiner result (term a))))))

(<span class="org-keyword">define</span> (<span class="org-function-name">sum</span> term a next b)
  (accumulate + 0 term a next b))

(<span class="org-keyword">define</span> (<span class="org-function-name">product</span> term a next b)
  (accumulate * 1 term a next b))

(test 15 (sum identity 0 inc 5))
(test 120 (product identity 1 inc 5))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-33" class="outline-2">
<h2 id="sec-33"><span class="section-number-2">33</span> <span class="done DONE">DONE</span> 1.33</h2>
<div class="outline-text-2" id="text-33">
<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">filtered-accumulate</span> predicate?
                             combiner
                             null-value
                             term
                             a
                             next
                             b)
  (<span class="org-keyword">if</span> (&gt; a b)
      null-value
      (<span class="org-keyword">let</span> ((term-a (term a)))
        (<span class="org-keyword">if</span> (predicate? term-a)
            (combiner term-a
                      (filtered-accumulate predicate?
                                           combiner
                                           null-value
                                           term
                                           (next a)
                                           next
                                           b))
            (filtered-accumulate predicate?
                                 combiner
                                 null-value
                                 term
                                 (next a)
                                 next
                                 b)))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(include <span class="org-string">"filtered-accumulate.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">square</span> x) (* x x))

(<span class="org-keyword">define</span> (<span class="org-function-name">expmod</span> base exp m)
  (<span class="org-keyword">cond</span> ((= exp 0) 1)
        ((even? exp)
         (remainder
          (square (expmod base (/ exp 2) m))
          m))
        (<span class="org-keyword">else</span>
         (remainder
          (* base (expmod base (- exp 1) m))
          m))))

(<span class="org-keyword">define</span> (<span class="org-function-name">fermat-test</span> n)
     (<span class="org-keyword">define</span> (<span class="org-function-name">try-it</span> a)
       (= (expmod a n n) a))
     (try-it (+ 1 (random (- n 1)))))

(<span class="org-keyword">define</span> (<span class="org-function-name">fast-prime?</span> n times)
  (<span class="org-keyword">cond</span> ((= times 0) #t)
        ((fermat-test n) (fast-prime? n (- times 1)))
        (<span class="org-keyword">else</span> #f)))

(<span class="org-keyword">define</span> (<span class="org-function-name">sum-primes</span> a b)
  (filtered-accumulate (cute fast-prime? &lt;&gt; 100)
                       +
                       0
                       identity
                       a
                       add1
                       b))

(test 17 (sum-primes 2 10))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">gcd</span> a b)
  (<span class="org-keyword">if</span> (= b 0)
      a
      (gcd b (remainder a b))))

(<span class="org-keyword">define</span> (<span class="org-function-name">sum-coprimes</span> n)
  (filtered-accumulate (<span class="org-keyword">lambda</span> (i) (= (gcd i n) 1))
                       +
                       0
                       identity
                       0
                       add1
                       (- n 1)))

(test 20 (sum-coprimes 10))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-34" class="outline-2">
<h2 id="sec-34"><span class="section-number-2">34</span> <span class="done DONE">DONE</span> 1.34</h2>
<div class="outline-text-2" id="text-34">
<p>
<code>(f f)</code> reduces to <code>(f 2)</code> which in turn reduces to <code>(2 2)</code>: it
tries to apply 2 as a procedure and fails.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">f</span> g) (g 2))

(test-error (f f))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-35" class="outline-2">
<h2 id="sec-35"><span class="section-number-2">35</span> <span class="done DONE">DONE</span> 1.35</h2>
<div class="outline-text-2" id="text-35">
<p>
Since \(\phi = 1 + \frac{1}{\phi}\), we are looking for the fixed
point of the function \(x \mapsto 1 + \frac{1}{x}\).
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> <span class="org-function-name">tolerance</span> (make-parameter 0.00001))

(<span class="org-keyword">define</span> (<span class="org-warning">fix</span>ed-point f first-guess)
  (<span class="org-keyword">define</span> (<span class="org-function-name">close-enough?</span> v1 v2)
    (&lt; (abs (- v1 v2))
       (tolerance)))
  (<span class="org-keyword">define</span> (<span class="org-function-name">try</span> guess)
    (<span class="org-keyword">let</span> ((next (f guess)))
      (<span class="org-keyword">if</span> (close-enough? guess next)
          next
          (try next))))
  (try first-guess))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(include <span class="org-string">"</span><span class="org-warning">fix</span><span class="org-string">ed-point.scm"</span>)

(test 1.61803 (<span class="org-warning">fix</span>ed-point (<span class="org-keyword">lambda</span> (x) (+ 1 (/ 1 x))) 1.6))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-36" class="outline-2">
<h2 id="sec-36"><span class="section-number-2">36</span> <span class="done DONE">DONE</span> 1.36</h2>
<div class="outline-text-2" id="text-36">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> <span class="org-function-name">tolerance</span> (make-parameter 0.00001))

(<span class="org-keyword">define</span> <span class="org-function-name">count</span> (make-parameter 0))

(<span class="org-keyword">define</span> (<span class="org-warning">fix</span>ed-point f first-guess)
  (<span class="org-keyword">define</span> (<span class="org-function-name">close-enough?</span> v1 v2)
    (&lt; (abs (- v1 v2))
       (tolerance)))
  (<span class="org-keyword">define</span> (<span class="org-function-name">try</span> guess)
    (count (+ (count) 1))
    (<span class="org-keyword">let</span> ((next (f guess)))
      (<span class="org-keyword">if</span> (close-enough? guess next)
          next
          (try next))))
  (try first-guess))

(parameterize ((count 0))
  (test 4.5555 (<span class="org-warning">fix</span>ed-point (<span class="org-keyword">lambda</span> (x) (/ (log 1000) (log x))) 4))
  (test 29 (count)))

(parameterize ((count 0))
  (test 4.5555 (<span class="org-warning">fix</span>ed-point (<span class="org-keyword">lambda</span> (x) (/ (+ x (/ (log 1000) (log x))) 2)) 4))
  (test 7 (count)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-37" class="outline-2">
<h2 id="sec-37"><span class="section-number-2">37</span> <span class="done DONE">DONE</span> 1.37</h2>
<div class="outline-text-2" id="text-37">
<div class="org-src-container">

<pre class="src src-scheme"><span class="org-comment-delimiter">;;; </span><span class="org-comment">Off by one?</span>
(<span class="org-keyword">define</span> (<span class="org-function-name">cont-frac</span> n d k)
  <span class="org-comment-delimiter">;; </span><span class="org-comment">i is necessary to evaluate the terms in order.</span>
  (<span class="org-keyword">let</span> <span class="org-function-name">iter</span> ((i 0))
    (<span class="org-keyword">if</span> (= i k)
        (/ (n i) (d i))
        (/ (n i) (+ (d i) (iter (+ i 1)))))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(include <span class="org-string">"cont-frac.scm"</span>)

<span class="org-comment-delimiter">;;; </span><span class="org-comment">The phi conjugate</span>
(<span class="org-keyword">define</span> <span class="org-function-name">phi</span> 0.618033989)

(test
 <span class="org-string">"k must be 11 to converge on Phi to within 0.00001."</span>
 11
 (<span class="org-keyword">let</span> <span class="org-function-name">iter</span> ((k 0))
   (<span class="org-keyword">let</span> ((cont-frac-phi (cont-frac (<span class="org-keyword">lambda</span> (i) 1.0) (<span class="org-keyword">lambda</span> (i) 1.0) k)))
     (<span class="org-keyword">if</span> (&lt; (abs (- phi cont-frac-phi)) 0.00001)
         k
         (iter (+ k 1))))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">cont-frac</span> n d k)
  (<span class="org-keyword">let</span> <span class="org-function-name">iter</span> ((result (/ (n 0) (d 0)))
             (i k))
    (<span class="org-keyword">if</span> (zero? i)
        result
        (iter (/ (n i) (+ (d i) result))
              (- i 1)))))

(test 0.61803 (cont-frac (<span class="org-keyword">lambda</span> (i) 1.0) (<span class="org-keyword">lambda</span> (i) 1.0) 13))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-38" class="outline-2">
<h2 id="sec-38"><span class="section-number-2">38</span> <span class="done DONE">DONE</span> 1.38</h2>
<div class="outline-text-2" id="text-38">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(include <span class="org-string">"cont-frac.scm"</span>)

(<span class="org-keyword">define</span> <span class="org-function-name">e</span> 2.71828182846)

(test (- e 2)
      (cont-frac (<span class="org-keyword">lambda</span> (i) 1.0)
                 (<span class="org-keyword">lambda</span> (i) (<span class="org-keyword">if</span> (zero? (modulo (+ i 2) 3))
                            (+ 2 (floor (* 2 (/ i 3))))
                            1.0))
                 7))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-39" class="outline-2">
<h2 id="sec-39"><span class="section-number-2">39</span> <span class="done DONE">DONE</span> 1.39</h2>
<div class="outline-text-2" id="text-39">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(include <span class="org-string">"cont-frac.scm"</span>)

(<span class="org-keyword">define</span> <span class="org-function-name">pi</span> 3.14159265359)

(<span class="org-keyword">define</span> (<span class="org-function-name">square</span> x) (* x x))

(<span class="org-keyword">define</span> (<span class="org-function-name">tan-cf</span> x)
  (cont-frac (<span class="org-keyword">lambda</span> (i) (<span class="org-keyword">if</span> (zero? i) x (- (square x))))
             (<span class="org-keyword">lambda</span> (i) (- (* 2 (+ i 1)) 1))
             3))

(test (tan (/ pi 4)) (tan-cf (/ pi 4)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-40" class="outline-2">
<h2 id="sec-40"><span class="section-number-2">40</span> <span class="done DONE">DONE</span> 1.40</h2>
<div class="outline-text-2" id="text-40">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(include <span class="org-string">"</span><span class="org-warning">fix</span><span class="org-string">ed-point.scm"</span>)

(<span class="org-keyword">define</span> <span class="org-function-name">dx</span> (make-parameter 0.00001))

(<span class="org-keyword">define</span> (<span class="org-function-name">deriv</span> g)
  (<span class="org-keyword">lambda</span> (x) (/ (- (g (+ x (dx))) (g x)) (dx))))

(<span class="org-keyword">define</span> (<span class="org-function-name">newton-transform</span> g)
  (<span class="org-keyword">lambda</span> (x) (- x (/ (g x) ((deriv g) x)))))

(<span class="org-keyword">define</span> (<span class="org-function-name">newtons-method</span> g guess)
  (<span class="org-warning">fix</span>ed-point (newton-transform g) guess))

(<span class="org-keyword">define</span> (<span class="org-function-name">cube</span> x) (* x x x))

(<span class="org-keyword">define</span> (<span class="org-function-name">square</span> x) (* x x))

(<span class="org-keyword">define</span> (<span class="org-function-name">cubic</span> a b c)
  (<span class="org-keyword">lambda</span> (x) (+ (cube x)
            (* a (square x))
            (* b x)
            c)))

(test 2.0 (newtons-method (cubic 3 -6 -8) 1))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-41" class="outline-2">
<h2 id="sec-41"><span class="section-number-2">41</span> <span class="done DONE">DONE</span> 1.41</h2>
<div class="outline-text-2" id="text-41">
<p>
The \(2^4\) (as opposed to \(2^3\)) occurs because you get something
like \(double^2(double^2(x))\).
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">inc</span> n) (+ n 1))

(<span class="org-keyword">define</span> (<span class="org-function-name">double</span> g) (<span class="org-keyword">lambda</span> (x) (g (g x))))

(test 21 (((double (double double)) inc) 5))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-42" class="outline-2">
<h2 id="sec-42"><span class="section-number-2">42</span> <span class="done DONE">DONE</span> 1.42</h2>
<div class="outline-text-2" id="text-42">
<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">compose</span> f g) (<span class="org-keyword">lambda</span> (x) (f (g x))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(include <span class="org-string">"compose.scm"</span>)

(test 49 ((compose square inc) 6))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-43" class="outline-2">
<h2 id="sec-43"><span class="section-number-2">43</span> <span class="done DONE">DONE</span> 1.43</h2>
<div class="outline-text-2" id="text-43">
<div class="org-src-container">

<pre class="src src-scheme">(include <span class="org-string">"compose.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">repeated</span> f n)
  (<span class="org-keyword">if</span> (zero? n)
      identity
      (compose f (repeated f (- n 1)))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(include <span class="org-string">"repeated.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">square</span> x) (* x x))

(test 625 ((repeated square 2) 5))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-44" class="outline-2">
<h2 id="sec-44"><span class="section-number-2">44</span> <span class="done DONE">DONE</span> 1.44</h2>
<div class="outline-text-2" id="text-44">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(include <span class="org-string">"repeated.scm"</span>)

(<span class="org-keyword">define</span> <span class="org-function-name">dx</span> (make-parameter 0.1))

(<span class="org-keyword">define</span> (<span class="org-function-name">smooth</span> f)
  (<span class="org-keyword">lambda</span> (x)
    (/ (+ (f (- x (dx)))
          (f x)
          (f (+ x (dx))))
       3)))

(<span class="org-keyword">define</span> (<span class="org-function-name">n-fold-smooth</span> f n)
  (repeated (smooth f) n))

(<span class="org-keyword">define</span> <span class="org-function-name">pi/2</span> (/ 3.14159265359 2))

(test 0.99667 ((smooth sin) pi/2))
(test 0.83687 ((n-fold-smooth sin 2) pi/2))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-45" class="outline-2">
<h2 id="sec-45"><span class="section-number-2">45</span> <span class="done DONE">DONE</span> 1.45</h2>
<div class="outline-text-2" id="text-45">
<p>
It appears as though you have to average-dampen \(\lfloor \log_2 n
  \rfloor\) times for the \(n^{th}\) root. Why?
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(include <span class="org-string">"</span><span class="org-warning">fix</span><span class="org-string">ed-point.scm"</span>)
(include <span class="org-string">"repeated.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">average</span> x y) (/ (+ x y) 2))

(<span class="org-keyword">define</span> (<span class="org-function-name">average-damp</span> f)
  (<span class="org-keyword">lambda</span> (x) (average x (f x))))

(<span class="org-keyword">define</span> (<span class="org-warning">fix</span>ed-point-of-transform g transform guess)
  (<span class="org-warning">fix</span>ed-point (transform g) guess))

(<span class="org-keyword">define</span> (<span class="org-function-name">sqrt</span> x)
  (<span class="org-warning">fix</span>ed-point-of-transform
   (<span class="org-keyword">lambda</span> (y) (/ x y))
   average-damp
   1.0))

(<span class="org-keyword">define</span> (<span class="org-function-name">nth-root</span> x n)
  (<span class="org-warning">fix</span>ed-point-of-transform
   (<span class="org-keyword">lambda</span> (y) (/ x (expt y (- n 1))))
   (repeated average-damp (floor (/ (log n) (log 2))))
   1.0))

(test 2.0 (nth-root 16 4))
(test 2.0 (nth-root 32 5))
(test 2.0 (nth-root 64 6))
(test 2.0 (nth-root 128 7))
(test 2.0 (nth-root 256 8))
(test 2.0 (nth-root 65536 16))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-46" class="outline-2">
<h2 id="sec-46"><span class="section-number-2">46</span> <span class="done DONE">DONE</span> 1.46</h2>
<div class="outline-text-2" id="text-46">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">iterative-improve</span> good-enough? improve)
  (<span class="org-keyword">lambda</span> (guess)
    (<span class="org-keyword">let</span> <span class="org-function-name">iter</span> ((guess guess))
      (<span class="org-keyword">if</span> (good-enough? guess)
          guess
          (iter (improve guess))))))

(<span class="org-keyword">define</span> <span class="org-function-name">epsilon</span> (make-parameter 0.00001))

(<span class="org-keyword">define</span> (<span class="org-function-name">square</span> x) (* x x))

(<span class="org-keyword">define</span> (<span class="org-function-name">average</span> x y) (/ (+ x y) 2))

(<span class="org-keyword">define</span> (<span class="org-function-name">sqrt-iter</span> guess x)
  ((iterative-improve
    (<span class="org-keyword">lambda</span> (guess)
      (&lt; (abs (- (square guess) x)) (epsilon)))
    (<span class="org-keyword">lambda</span> (guess)
      (average guess (/ x guess))))
   guess))

(<span class="org-keyword">define</span> (<span class="org-function-name">sqrt</span> x) (sqrt-iter 1.0 x))

(test 2.0 (sqrt 4))

(<span class="org-keyword">define</span> (<span class="org-warning">fix</span>ed-point f guess)
  ((iterative-improve
    (<span class="org-keyword">lambda</span> (guess)
      <span class="org-comment-delimiter">;; </span><span class="org-comment">This results in the application of f twice, unfortunately.</span>
      (&lt; (abs (- guess (f guess))) (epsilon)))
    f)
   guess))

(test 0.73909 (<span class="org-warning">fix</span>ed-point cos 1.0))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-47" class="outline-2">
<h2 id="sec-47"><span class="section-number-2">47</span> <span class="done DONE">DONE</span> 2.1</h2>
<div class="outline-text-2" id="text-47">
<div class="org-src-container">

<pre class="src src-scheme">(use (only sicp xor) test)

(<span class="org-keyword">define</span> (<span class="org-function-name">make-rat</span> n d)
  (<span class="org-keyword">let</span> ((g (gcd n d)))
    (<span class="org-keyword">let</span> ((n (/ n g))
          (d (/ d g)))
      (<span class="org-keyword">let</span> ((n (<span class="org-keyword">if</span> (xor (negative? n)
                        (negative? d))
                   (- (abs n))
                   (abs n)))
            (d (abs d)))
        (cons n d)))))

(test '(2 . 1) (make-rat 8 4))
(test '(2 . 1) (make-rat -8 -4))
(test '(-2 . 1) (make-rat 8 -4))
(test '(-2 . 1) (make-rat -8 4))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-48" class="outline-2">
<h2 id="sec-48"><span class="section-number-2">48</span> <span class="done DONE">DONE</span> 2.2</h2>
<div class="outline-text-2" id="text-48">
<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> <span class="org-function-name">make-segment</span> cons)
(<span class="org-keyword">define</span> <span class="org-function-name">start-segment</span> car)
(<span class="org-keyword">define</span> <span class="org-function-name">end-segment</span> cdr)

(<span class="org-keyword">define</span> <span class="org-function-name">make-point</span> cons)
(<span class="org-keyword">define</span> <span class="org-function-name">x-point</span> car)
(<span class="org-keyword">define</span> <span class="org-function-name">y-point</span> cdr)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(include <span class="org-string">"segment.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">midpoint-segment</span> segment)
  (<span class="org-keyword">let</span> ((start (start-segment segment))
        (end (end-segment segment)))
    (make-point (average (x-point start)
                         (x-point end))
                (average (y-point start)
                         (y-point end)))))

(test
 (make-point 1 1)
 (midpoint-segment (make-segment (make-point 0 0)
                                 (make-point 2 2))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-49" class="outline-2">
<h2 id="sec-49"><span class="section-number-2">49</span> <span class="done DONE">DONE</span> 2.3</h2>
<div class="outline-text-2" id="text-49">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(include <span class="org-string">"segment.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">length</span> p1 p2)
  (sqrt (+ (square (- (x-point p2)
                      (x-point p1)))
           (square (- (y-point p2)
                      (y-point p1))))))

(<span class="org-keyword">define</span> (<span class="org-function-name">make-segment-rect</span> s1 s2)
  (<span class="org-keyword">lambda</span> (message)
    (<span class="org-keyword">case</span> message
      ((length)
       (length (start-segment s1)
               (end-segment s1)))
      ((width)
       (length (start-segment s2)
               (end-segment s2))))))

(<span class="org-keyword">define</span> (<span class="org-function-name">make-point-rect</span> p1 p2 p3)
  (<span class="org-keyword">lambda</span> (message)
    (<span class="org-keyword">case</span> message
      ((length) (length p1 p2))
      ((width) (length p2 p3)))))

(<span class="org-keyword">define</span> (<span class="org-function-name">perimeter</span> rect)
  (* 2 (+ (rect 'length)
          (rect 'width))))

(<span class="org-keyword">define</span> (<span class="org-function-name">area</span> rect)
  (* (rect 'length) (rect 'width)))

(<span class="org-keyword">let</span> ((r1 (make-segment-rect (make-segment (make-point 0 0)
                                           (make-point 2 0))
                             (make-segment (make-point 0 0)
                                           (make-point 0 3))))
      (r2 (make-point-rect (make-point 2 0)
                           (make-point 0 0)
                           (make-point 0 3))))
  (test 10.0 (perimeter r1))
  (test (perimeter r1) (perimeter r2))
  (test 6.0 (area r1))
  (test (area r1) (area r2)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-50" class="outline-2">
<h2 id="sec-50"><span class="section-number-2">50</span> <span class="done DONE">DONE</span> 2.4</h2>
<div class="outline-text-2" id="text-50">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">cons</span> x y)
  (<span class="org-keyword">lambda</span> (m) (m x y)))

(<span class="org-keyword">define</span> (<span class="org-function-name">car</span> z)
  (z (<span class="org-keyword">lambda</span> (p q) p)))

(<span class="org-keyword">define</span> (<span class="org-function-name">cdr</span> z)
  (z (<span class="org-keyword">lambda</span> (p q) q)))

(<span class="org-keyword">let</span> ((pair (cons 1 2)))
  (test 1 (car pair))
  (test 2 (cdr pair)))
</pre>
</div>

<p>
Via the substitution model:
</p>

<div class="org-src-container">

<pre class="src src-scheme">(cdr pair)
(cdr (cons 1 2))
(cdr (<span class="org-keyword">lambda</span> (m) (m 1 2)))
((<span class="org-keyword">lambda</span> (m) (m 1 2))
 (<span class="org-keyword">lambda</span> (p q) q))
((<span class="org-keyword">lambda</span> (p q) q) 1 2)
2
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-51" class="outline-2">
<h2 id="sec-51"><span class="section-number-2">51</span> <span class="done DONE">DONE</span> 2.5</h2>
<div class="outline-text-2" id="text-51">
<p>
Is there a cleverer way to do this that’s not \(O(n)\) for accessing
<code>car</code> and <code>cdr</code>?
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">divides?</span> n d) (zero? (modulo n d)))

(<span class="org-keyword">define</span> (<span class="org-function-name">multiplicity</span> n d)
  (<span class="org-keyword">let</span> <span class="org-function-name">iter</span> ((n n)
             (m 0))
    (<span class="org-keyword">if</span> (divides? n d)
        (iter (/ n d) (+ m 1))
        m)))

<span class="org-comment-delimiter">;; </span><span class="org-comment">Strange things happen if we don't prefix these.</span>
(<span class="org-keyword">define</span> (<span class="org-function-name">n-cons</span> a b)
  (* (expt 2 a) (expt 3 b)))

(<span class="org-keyword">define</span> (<span class="org-function-name">n-car</span> n)
  (multiplicity n 2))

(<span class="org-keyword">define</span> (<span class="org-function-name">n-cdr</span> n)
  (multiplicity n 3))

(<span class="org-keyword">let</span> ((pair (n-cons 3 4)))
  (test 3 (n-car pair))
  (test 4 (n-cdr pair)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-52" class="outline-2">
<h2 id="sec-52"><span class="section-number-2">52</span> <span class="done DONE">DONE</span> 2.6</h2>
<div class="outline-text-2" id="text-52">
<p>
Addition relies on the property that \(f^{m + n}(x) = f^m(f^n(x))\).
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(<span class="org-keyword">define</span> <span class="org-function-name">zero</span> (<span class="org-keyword">lambda</span> (f) (<span class="org-keyword">lambda</span> (x) x)))

((zero identity) 0)

(<span class="org-keyword">define</span> (<span class="org-function-name">add-1</span> n)
  (<span class="org-keyword">lambda</span> (f) (<span class="org-keyword">lambda</span> (x) (f ((n f) x)))))

(<span class="org-keyword">define</span> <span class="org-function-name">one</span> (<span class="org-keyword">lambda</span> (f) (<span class="org-keyword">lambda</span> (x) (f x))))

(<span class="org-keyword">define</span> <span class="org-function-name">two</span> (<span class="org-keyword">lambda</span> (f) (<span class="org-keyword">lambda</span> (x) (f (f x)))))

(test
 ((one inc) 0)
 (((add-1 zero) inc) 0))

(test
 ((two inc) 0)
 (((add-1 (add-1 zero)) inc) 0))

(<span class="org-keyword">define</span> (<span class="org-function-name">add</span> m n)
  (<span class="org-keyword">lambda</span> (f) (<span class="org-keyword">lambda</span> (x) (f ((m (n f)) x)))))

(test 3 (((add one two) inc) 0))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-53" class="outline-2">
<h2 id="sec-53"><span class="section-number-2">53</span> <span class="done DONE">DONE</span> 2.7</h2>
<div class="outline-text-2" id="text-53">
<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">add-interval</span> x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))

(<span class="org-keyword">define</span> (<span class="org-function-name">mul-interval</span> x y)
  (<span class="org-keyword">let</span> ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))

(<span class="org-keyword">define</span> (<span class="org-function-name">div-interval</span> x y)
  (mul-interval
   x
   (make-interval (/ 1.0 (upper-bound y))
                  (/ 1.0 (lower-bound y)))))

(<span class="org-keyword">define</span> <span class="org-function-name">make-interval</span> cons)

(<span class="org-keyword">define</span> <span class="org-function-name">lower-bound</span> car)

(<span class="org-keyword">define</span> <span class="org-function-name">upper-bound</span> cdr)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(include <span class="org-string">"interval.scm"</span>)

(test '(3 . 3)
      (add-interval (make-interval 1 1)
                    (make-interval 2 2)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-54" class="outline-2">
<h2 id="sec-54"><span class="section-number-2">54</span> <span class="done DONE">DONE</span> 2.8</h2>
<div class="outline-text-2" id="text-54">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(include <span class="org-string">"interval.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">sub-interval</span> x y)
  (make-interval (- (lower-bound x) (lower-bound y))
                 (- (upper-bound x) (upper-bound y))))

(test '(1 . 1)
      (sub-interval (make-interval 2 2)
                    (make-interval 1 1)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-55" class="outline-2">
<h2 id="sec-55"><span class="section-number-2">55</span> <span class="done DONE">DONE</span> 2.9</h2>
<div class="outline-text-2" id="text-55">
<p>
With respect to addition:
</p>

\begin{align}
w(n_1) + w(n_2) &= w(n_1 + n_2) \\
\frac{u_1 - l_1}{2} + \frac{u_2 - l_2}{2} &= \frac{(u_1 + u_2) - (l_1 + l_2)}{2}
\end{align}

<p>
but, in general, with respect to multiplication:
</p>

\begin{align}
w(n_1)w(n_2) &\neq w(n_1n_2) \\
\frac{u_1 - l_1}{2}\cdot\frac{u_2 - l_2}{2} &\neq
\frac{\max_{u_1l_1, u_1l_2, u_2l_1, u_2l_2} - \min_{u_1l_1, u_1l_2, u_2l_1, u_2l_2}}{2}
\end{align}

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(include <span class="org-string">"interval.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">width</span> n)
  (/ (- (upper-bound n) (lower-bound n))
     2))

(<span class="org-keyword">let</span> ((n0 (make-interval 0 1))
      (n1 (make-interval 1 0)))
  (<span class="org-keyword">let</span> ((w0 (* (width n0)
               (width n1)))
        (w1 (width (mul-interval n0 n1))))
    (test-assert (not (= w0 w1)))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-56" class="outline-2">
<h2 id="sec-56"><span class="section-number-2">56</span> <span class="done DONE">DONE</span> 2.10</h2>
<div class="outline-text-2" id="text-56">
<p>
This doesn’t check the endpoints for division by zero but merely
checks the span.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(include <span class="org-string">"interval.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">div-interval</span> x y)
  (<span class="org-keyword">if</span> (xor (positive? (upper-bound y))
           (positive? (lower-bound y)))
      (error <span class="org-string">"It's not clear what it means to divide by an interval that spans zero."</span>)
      (mul-interval
       x
       (make-interval (/ 1.0 (upper-bound y))
                      (/ 1.0 (lower-bound y))))))

(test '(0.0 . 0.0)
      (div-interval (make-interval 0 0) (make-interval 1 1)))

(test-error (div-interval (make-interval 0 0)
                          (make-interval -1 1)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-57" class="outline-2">
<h2 id="sec-57"><span class="section-number-2">57</span> <span class="done DONE">DONE</span> 2.11</h2>
<div class="outline-text-2" id="text-57">
<p>
Let’s break it into nine cases according to which each interval is
either positive, negative or threshold-crossing.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(include <span class="org-string">"interval.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">positive-interval?</span> x)
  (<span class="org-keyword">and</span> (positive? (lower-bound x))
       (positive? (upper-bound x))))

(<span class="org-keyword">define</span> (<span class="org-function-name">negative-interval?</span> x)
  (<span class="org-keyword">and</span> (negative? (lower-bound x))
       (negative? (upper-bound x))))

(<span class="org-keyword">define</span> (<span class="org-function-name">mixed-interval?</span> x)
  (xor (positive? (lower-bound x))
       (positive? (upper-bound x))))

(<span class="org-keyword">define</span> (<span class="org-function-name">mul-interval-cases</span> x y)
  (<span class="org-keyword">let</span> ((x-negative? (negative-interval? x))
        (y-negative? (negative-interval? y))
        (x-positive? (positive-interval? x))
        (y-positive? (positive-interval? y))
        (x-mixed? (mixed-interval? x))
        (y-mixed? (mixed-interval? y))
        (x-lower (lower-bound x))
        (x-upper (upper-bound x))
        (y-lower (lower-bound y))
        (y-upper (upper-bound y)))
    (<span class="org-keyword">cond</span> ((<span class="org-keyword">and</span> x-negative? y-negative?)
           (make-interval (* x-upper y-upper)
                          (* x-lower y-lower)))
          ((<span class="org-keyword">and</span> x-negative? y-positive?)
           (make-interval (* x-lower y-upper)
                          (* x-upper y-lower)))
          ((<span class="org-keyword">and</span> x-negative? y-mixed?)
           (make-interval (* x-lower y-upper)
                          (* x-lower y-lower)))
          ((<span class="org-keyword">and</span> x-positive? y-negative?)
           (make-interval (* x-upper y-lower)
                          (* x-lower y-upper)))
          ((<span class="org-keyword">and</span> x-positive? y-positive?)
           (make-interval (* x-lower y-lower)
                          (* x-upper y-upper)))
          ((<span class="org-keyword">and</span> x-positive? y-mixed?)
           (make-interval (* x-upper y-lower)
                          (* x-upper y-upper)))
          ((<span class="org-keyword">and</span> x-mixed? y-negative?)
           (make-interval (* x-upper y-lower)
                          (* x-lower y-lower)))
          ((<span class="org-keyword">and</span> x-mixed? y-positive?)
           (make-interval (* x-lower y-upper)
                          (* x-upper y-upper)))
          ((<span class="org-keyword">and</span> x-mixed? y-mixed?)
           (make-interval (min (* x-lower y-upper)
                               (* x-upper y-lower))
                          (max (* x-upper y-upper)
                               (* x-lower y-lower)))))))

(<span class="org-keyword">let</span> ((negative (make-interval -5 -3))
      (mixed (make-interval -1 7))
      (positive (make-interval 11 13)))
  (test (mul-interval negative negative)
        (mul-interval-cases negative negative))
  (test (mul-interval negative positive)
        (mul-interval-cases negative positive))
  (test (mul-interval negative mixed)
        (mul-interval-cases negative mixed))
  (test (mul-interval positive negative)
        (mul-interval-cases positive negative))
  (test (mul-interval positive positive)
        (mul-interval-cases positive positive))
  (test (mul-interval positive mixed)
        (mul-interval-cases positive mixed))
  (test (mul-interval negative negative)
        (mul-interval-cases negative negative))
  (test (mul-interval mixed positive)
        (mul-interval-cases mixed positive))
  (test (mul-interval mixed mixed)
        (mul-interval-cases mixed mixed)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-58" class="outline-2">
<h2 id="sec-58"><span class="section-number-2">58</span> <span class="done DONE">DONE</span> 2.12</h2>
<div class="outline-text-2" id="text-58">
<div class="org-src-container">

<pre class="src src-scheme">(include <span class="org-string">"interval.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">make-center-width</span> c w)
  (make-interval (- c w) (+ c w)))

(<span class="org-keyword">define</span> (<span class="org-function-name">center</span> i)
  (/ (+ (lower-bound i) (upper-bound i)) 2))

(<span class="org-keyword">define</span> (<span class="org-function-name">width</span> i)
  (/ (- (upper-bound i) (lower-bound i)) 2))

(<span class="org-keyword">define</span> (<span class="org-function-name">make-center-percent</span> c p)
  (make-center-width c (* p c)))

(<span class="org-keyword">define</span> (<span class="org-function-name">percent</span> i)
  (/ (width i) (center i)))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(include <span class="org-string">"interval-percent.scm"</span>)

(<span class="org-keyword">let</span> ((i (make-center-percent 6.8 0.1)))
  (test 6.8 (center i))
  (test 0.68 (width i))
  (test 6.12 (lower-bound i))
  (test 7.48 (upper-bound i))
  (test 0.1 (percent i)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-59" class="outline-2">
<h2 id="sec-59"><span class="section-number-2">59</span> <span class="done DONE">DONE</span> 2.13</h2>
<div class="outline-text-2" id="text-59">
<p>
It’s possible to add the percentage tolerance to get an approximate
product-tolerance. Given that (where \(p\) is the percent; \(w\),
width; \(c\), center; \(u\), upper-bound; and \(l\), lower-bound):
</p>

\begin{align}
p(x) &= \frac{w(x)}{c(x)} \\
&= \frac{u - l}{u + l}
\end{align}

<p>
and that \(x_1x_2 = [l_1l_2, u_1u_2]\) for positive intervals, we
assert:
</p>

\begin{align}
p(x_1) + p(x_2) &\approx p(x_1x_2) \\
\frac{u_1 - l_1}{u_1 + l_1} + \frac{u_2 - l_2}{u_2 + l_2} &\approx
\frac{u_1u_2 - l_1l_2}{u_1u_2 + l_1l_2}
\end{align}

<p>
and for small percentage tolerances (i.e. where \(u_1\) is
sufficiently close to \(l_1\) and \(u_2\) is sufficiently close to
\(l_2\)):
</p>

\begin{align}
\frac{u - u}{u} &\approx \frac{u^2 - u^2}{2u^2} \\
0 &\approx 0
\end{align}

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(include <span class="org-string">"interval-percent.scm"</span>)

(<span class="org-keyword">let*</span> ((p 0.1)
       (i (make-center-percent 6.8 p)))
  (parameterize ((current-test-epsilon 0.01))
    (test (+ p p) (percent (mul-interval i i)))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-60" class="outline-2">
<h2 id="sec-60"><span class="section-number-2">60</span> <span class="done DONE">DONE</span> 2.14</h2>
<div class="outline-text-2" id="text-60">
<p>
The first formula for parallel resistors gives much looser bounds:
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(include <span class="org-string">"interval-percent.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">par1</span> r1 r2)
  (div-interval (mul-interval r1 r2)
                (add-interval r1 r2)))

(<span class="org-keyword">define</span> (<span class="org-function-name">par2</span> r1 r2)
  (<span class="org-keyword">let</span> ((one (make-interval 1 1)))
    (div-interval
     one (add-interval (div-interval one r1)
                       (div-interval one r2)))))

(<span class="org-keyword">let</span> ((r (make-center-percent 6.8 0.1)))
  (<span class="org-keyword">let</span> ((p1 (par1 r r))
        (p2 (par2 r r)))
    (test 3.5374 (center p1))
    (test 0.292233 (percent p1))
    (test 3.4 (center p2))
    (test 0.1 (percent p2))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-61" class="outline-2">
<h2 id="sec-61"><span class="section-number-2">61</span> <span class="done DONE">DONE</span> 2.15</h2>
<div class="outline-text-2" id="text-61">
<p>
Operations involving intervals reduce precision (i.e. increase error
bounds); Alyssa is therefore correct that <code>par2</code> is “better” in the
sense that it produces tighter bounds.
</p>
</div>
</div>
<div id="outline-container-sec-62" class="outline-2">
<h2 id="sec-62"><span class="section-number-2">62</span> <span class="done DONE">DONE</span> 2.16</h2>
<div class="outline-text-2" id="text-62">
<p>
As in <a href="#sec-61">problem 2.15</a>, operations involving intervals reduce precision;
equivalent algebraic expressions with nevertheless fewer operations
involving intervals might have better precision.
</p>

<p>
An interval-arithmetic package that reduces equations to their
simplest form before computing on intervals would not have this
shortcoming.
</p>
</div>

<div id="outline-container-sec-62-1" class="outline-3">
<h3 id="sec-62-1"><span class="section-number-3">62.1</span> <span class="todo TODO">TODO</span> Implement simplification</h3>
</div>
</div>
<div id="outline-container-sec-63" class="outline-2">
<h2 id="sec-63"><span class="section-number-2">63</span> <span class="done DONE">DONE</span> 2.17</h2>
<div class="outline-text-2" id="text-63">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">last-pair</span> list)
  (<span class="org-keyword">if</span> (null? (cdr list))
      list
      (last-pair (cdr list))))

(test '(34) (last-pair (list 23 72 149 34)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-64" class="outline-2">
<h2 id="sec-64"><span class="section-number-2">64</span> <span class="done DONE">DONE</span> 2.18</h2>
<div class="outline-text-2" id="text-64">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">reverse</span> list)
  (<span class="org-keyword">let</span> <span class="org-function-name">iter</span> ((reverse '())
             (list list))
    (<span class="org-keyword">if</span> (null? list)
        reverse
        (iter (cons (car list) reverse)
              (cdr list)))))

(test '(25 16 9 4 1)
      (reverse (list 1 4 9 16 25)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-65" class="outline-2">
<h2 id="sec-65"><span class="section-number-2">65</span> <span class="done DONE">DONE</span> 2.19</h2>
<div class="outline-text-2" id="text-65">
<p>
The order of <code>coin-values</code> shouldn’t affect <code>cc</code>, since it tries
every permutation.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> <span class="org-function-name">first-denomination</span> car)
(<span class="org-keyword">define</span> <span class="org-function-name">except-first-denomination</span> cdr)
(<span class="org-keyword">define</span> <span class="org-function-name">no-more?</span> null?)

(<span class="org-keyword">define</span> (<span class="org-function-name">cc</span> amount coin-values)
  (<span class="org-keyword">cond</span> ((= amount 0) 1)
        ((<span class="org-keyword">or</span> (&lt; amount 0) (no-more? coin-values)) 0)
        (<span class="org-keyword">else</span>
         (+ (cc amount
                (except-first-denomination
                 coin-values))
            (cc (- amount
                   (first-denomination
                    coin-values))
                coin-values)))))

(<span class="org-keyword">define</span> <span class="org-function-name">us-coins</span> (list 50 25 10 5 1))
(<span class="org-keyword">define</span> <span class="org-function-name">uk-coins</span> (list 100 50 20 10 5 2 1 0.5))

(test 292 (cc 100 us-coins))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-66" class="outline-2">
<h2 id="sec-66"><span class="section-number-2">66</span> <span class="done DONE">DONE</span> 2.20</h2>
<div class="outline-text-2" id="text-66">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">filter</span> predicate? list)
  (<span class="org-keyword">if</span> (null? list)
      '()
      (<span class="org-keyword">if</span> (predicate? (car list))
          (cons (car list) (filter predicate? (cdr list)))
          (filter predicate? (cdr list)))))

(<span class="org-keyword">define</span> (<span class="org-function-name">same-parity</span> . numbers)
  (<span class="org-keyword">if</span> (even? (car numbers))
      (filter even? numbers)
      (filter odd? numbers)))

<span class="org-comment-delimiter">;; </span><span class="org-comment">Non-branching alternative</span>
(<span class="org-keyword">define</span> (<span class="org-function-name">same-parity</span> a . rest)
  (cons a (filter (<span class="org-keyword">lambda</span> (n) (= (remainder a 2) (remainder n 2))) rest)))

(test '(1 3 5 7) (same-parity 1 2 3 4 5 6 7))
(test '(2 4 6) (same-parity 2 3 4 5 6 7))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-67" class="outline-2">
<h2 id="sec-67"><span class="section-number-2">67</span> <span class="done DONE">DONE</span> 2.21</h2>
<div class="outline-text-2" id="text-67">
<div class="org-src-container">

<pre class="src src-scheme">(use (only sicp nil square) test)

(<span class="org-keyword">define</span> (<span class="org-function-name">square-list</span> items)
  (<span class="org-keyword">if</span> (null? items)
      nil
      (cons (square (car items)) (square-list (cdr items)))))

(test '(1 4 9 16) (square-list (list 1 2 3 4)))

(<span class="org-keyword">define</span> (<span class="org-function-name">square-list</span> items)
  (<span class="org-keyword">map</span> square items))

(test '(1 4 9 16) (square-list (list 1 2 3 4)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-68" class="outline-2">
<h2 id="sec-68"><span class="section-number-2">68</span> <span class="done DONE">DONE</span> 2.22</h2>
<div class="outline-text-2" id="text-68">
<p>
The first solution reverses the answers since it conses the elements
to the front of the list in front-to-back order.
</p>

<p>
The second solution doesn’t work since it doesn’t produce the proper
sequence of nested conses to form a list.
</p>
</div>
</div>
<div id="outline-container-sec-69" class="outline-2">
<h2 id="sec-69"><span class="section-number-2">69</span> <span class="done DONE">DONE</span> 2.23</h2>
<div class="outline-text-2" id="text-69">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">for-each</span> f list)
  (unless (null? list)
    (<span class="org-keyword">begin</span>
      (f (car list))
      (<span class="org-keyword">for-each</span> f (cdr list)))))

(<span class="org-keyword">let</span> ((x '()))
  (<span class="org-keyword">for-each</span> (<span class="org-keyword">lambda</span> (i) (set! x (cons i x))) '(1 2 3))
  (test x '(3 2 1)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-70" class="outline-2">
<h2 id="sec-70"><span class="section-number-2">70</span> <span class="done DONE">DONE</span> 2.24</h2>
<div class="outline-text-2" id="text-70">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(test '(1 (2 (3 4))) (list 1 (list 2 (list 3 4))))
</pre>
</div>


<div class="figure">
<p><img src="./2.23-box-and-pointer.jpg" alt="2.23-box-and-pointer.jpg" />
</p>
<p><span class="figure-number">Figure 2:</span> Box-and-pointer diagram</p>
</div>


<div class="figure">
<p><img src="2.23-tree.png" alt="2.23-tree.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-sec-71" class="outline-2">
<h2 id="sec-71"><span class="section-number-2">71</span> <span class="done DONE">DONE</span> 2.25</h2>
<div class="outline-text-2" id="text-71">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(test 7 (car (cdaddr '(1 3 (5 7) 9))))
(test 7 (caar '((7))))
(test 7 (cadadr (cadadr (cadadr '(1 (2 (3 (4 (5 (6 7))))))))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-72" class="outline-2">
<h2 id="sec-72"><span class="section-number-2">72</span> <span class="done DONE">DONE</span> 2.26</h2>
<div class="outline-text-2" id="text-72">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> <span class="org-function-name">x</span> (list 1 2 3))
(<span class="org-keyword">define</span> <span class="org-function-name">y</span> (list 4 5 6))

(test '(1 2 3 4 5 6) (append x y))
(test '((1 2 3) 4 5 6) (cons x y))
(test '((1 2 3) (4 5 6)) (list x y))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-73" class="outline-2">
<h2 id="sec-73"><span class="section-number-2">73</span> <span class="done DONE">DONE</span> 2.27</h2>
<div class="outline-text-2" id="text-73">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">deep-reverse</span> list)
  (<span class="org-keyword">let</span> <span class="org-function-name">iter</span> ((list list)
             (reverse '()))
    (<span class="org-keyword">if</span> (null? list)
        reverse
        (<span class="org-keyword">let</span> ((first (car list)))
          (iter (cdr list)
                (cons (<span class="org-keyword">if</span> (pair? first)
                          (deep-reverse first)
                          first)
                      reverse))))))

<span class="org-comment-delimiter">;; </span><span class="org-comment">Or using higher-order functions.</span>
(<span class="org-keyword">define</span> (<span class="org-function-name">deep-reverse</span> list)
  (reverse (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (element)
                  (<span class="org-keyword">if</span> (pair? element)
                      (deep-reverse element)
                      element))
                list)))

(test '(((7 6 5) 4 3) (2 1))
      (deep-reverse '((1 2) (3 4 (5 6 7)))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-74" class="outline-2">
<h2 id="sec-74"><span class="section-number-2">74</span> <span class="done DONE">DONE</span> 2.28</h2>
<div class="outline-text-2" id="text-74">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">fringe</span> list)
  (<span class="org-keyword">let</span> <span class="org-function-name">iter</span> ((list list)
             (leaves '()))
    (<span class="org-keyword">if</span> (null? list)
        leaves
        (<span class="org-keyword">let</span> ((first (car list)))
          (iter (cdr list)
                (<span class="org-keyword">if</span> (pair? first)
                    (append (fringe first) leaves)
                    (cons first leaves)))))))

(<span class="org-keyword">define</span> <span class="org-function-name">x</span> '((1 2) (3 4)))
(test '(4 3 2 1) (fringe x))
(test '(4 3 2 1 4 3 2 1) (fringe (list x x)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-75" class="outline-2">
<h2 id="sec-75"><span class="section-number-2">75</span> <span class="done DONE">DONE</span> 2.29</h2>
<div class="outline-text-2" id="text-75">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">make-mobile</span> left right)
  (list left right))
(<span class="org-keyword">define</span> (<span class="org-function-name">make-branch</span> length structure)
  (list length structure))

(<span class="org-keyword">define</span> <span class="org-function-name">left-branch</span> car)
(<span class="org-keyword">define</span> <span class="org-function-name">right-branch</span> cadr)

(<span class="org-keyword">define</span> <span class="org-function-name">branch-length</span> car)
(<span class="org-keyword">define</span> <span class="org-function-name">branch-structure</span> cadr)

(<span class="org-keyword">define</span> (<span class="org-function-name">total-weight</span> mobile)
  (<span class="org-keyword">let</span> ((left-structure (branch-structure (left-branch mobile)))
        (right-structure (branch-structure (right-branch mobile))))
    (+ (<span class="org-keyword">if</span> (number? left-structure)
           left-structure
           (total-weight left-structure))
       (<span class="org-keyword">if</span> (number? right-structure)
           right-structure
           (total-weight right-structure)))))

(<span class="org-keyword">define</span> <span class="org-function-name">mobile</span>
  (make-mobile (make-branch
                2
                (make-mobile
                 (make-branch
                  2
                  (make-mobile
                   (make-branch 3 16)
                   (make-branch 2 20)))
                 (make-branch 4 20)))
               (make-branch 5 102.4)))

(<span class="org-keyword">define</span> (<span class="org-function-name">torque</span> branch)
  (<span class="org-keyword">let</span> ((structure (branch-structure branch)))
    (* (branch-length branch)
       (<span class="org-keyword">if</span> (number? structure)
           structure
           (+ (torque (left-branch structure))
              (torque (right-branch structure)))))))

(<span class="org-keyword">define</span> (<span class="org-function-name">balanced?</span> mobile)
  (= (torque (left-branch mobile))
     (torque (right-branch mobile))))

(test 158.4 (total-weight mobile))

(test-assert (balanced? mobile))
</pre>
</div>


<div class="figure">
<p><img src="./2.29-mobile.jpg" alt="2.29-mobile.jpg" />
</p>
<p><span class="figure-number">Figure 4:</span> Mobile</p>
</div>

<p>
In order to accomodate <code>cons</code> vs. <code>list</code>, we only need to modify the
accessors <code>right-branch</code>, <code>branch-structure</code> to use <code>cdr</code> instead of
<code>cadr</code>.
</p>
</div>
</div>
<div id="outline-container-sec-76" class="outline-2">
<h2 id="sec-76"><span class="section-number-2">76</span> <span class="done DONE">DONE</span> 2.30</h2>
<div class="outline-text-2" id="text-76">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(<span class="org-keyword">define</span> (<span class="org-function-name">square-tree-direct</span> tree)
  (<span class="org-keyword">cond</span> ((null? tree) nil)
        ((not (pair? tree)) (square tree))
        (<span class="org-keyword">else</span> (cons (square-tree-direct (car tree))
                    (square-tree-direct (cdr tree))))))

(<span class="org-keyword">define</span> (<span class="org-function-name">square-tree-map</span> tree)
  (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (sub-tree)
         (<span class="org-keyword">if</span> (pair? sub-tree)
             (square-tree-map sub-tree)
             (square sub-tree)))
       tree))

(<span class="org-keyword">define</span> <span class="org-function-name">tree</span> (list 1 (list 2 (list 3 4) 5) (list 6 7)))

(test '(1 (4 (9 16) 25) (36 49)) (square-tree-direct tree))
(test '(1 (4 (9 16) 25) (36 49)) (square-tree-map tree))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-77" class="outline-2">
<h2 id="sec-77"><span class="section-number-2">77</span> <span class="done DONE">DONE</span> 2.31</h2>
<div class="outline-text-2" id="text-77">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(<span class="org-keyword">define</span> (<span class="org-function-name">tree-map</span> f tree)
  (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (sub-tree)
         (<span class="org-keyword">if</span> (pair? sub-tree)
             (tree-map f sub-tree)
             (f sub-tree)))
       tree))

(<span class="org-keyword">define</span> (<span class="org-function-name">square-tree</span> tree) (tree-map square tree))

(<span class="org-keyword">define</span> <span class="org-function-name">tree</span> (list 1 (list 2 (list 3 4) 5) (list 6 7)))

(test '(1 (4 (9 16) 25) (36 49)) (square-tree tree))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-78" class="outline-2">
<h2 id="sec-78"><span class="section-number-2">78</span> <span class="done DONE">DONE</span> 2.32</h2>
<div class="outline-text-2" id="text-78">
<p>
It recursively descends to <code>(null? s)</code>, the base case, where it
seeds the unwinding with <code>(())</code>; and, as it unwinds the recursion,
it has already generated all subsets of the last \(n\) elements: all
that is required is to <code>cons</code> the \(n - 1^{st}\) element to all
subsets of the last \(n\) elements.
</p>

<p>
To see that this is the case, look at the zeroeth case, where it has
generated the empty set; look also at the first case, where it has
taken the <code>car</code> of <code>s</code>, e.g. <code>3</code>, and appended it to <code>()</code>, yielding
<code>(3)</code>.
</p>

<p>
The next step will <code>cons</code> <code>2</code> to <code>()</code> and <code>(3)</code>, append it to the
previously unwound subsets <code>(() (3))</code>, yielding <code>(() (3) (2) (2
  3))</code>.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(<span class="org-keyword">define</span> (<span class="org-function-name">subsets</span> s)
  (<span class="org-keyword">if</span> (null? s)
      (list nil)
      (<span class="org-keyword">let</span> ((rest (subsets (cdr s))))
        (append rest (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (subset) (cons (car s) subset)) rest)))))

(test '(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3)) (subsets '(1 2 3)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-79" class="outline-2">
<h2 id="sec-79"><span class="section-number-2">79</span> <span class="done DONE">DONE</span> 2.33</h2>
<div class="outline-text-2" id="text-79">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(<span class="org-keyword">define</span> (<span class="org-function-name">map</span> p sequence)
  (accumulate (<span class="org-keyword">lambda</span> (x y) (cons (p x) y)) nil sequence))

(<span class="org-keyword">define</span> <span class="org-function-name">list</span> '(1 2 3))

(test '(1 4 9) (<span class="org-keyword">map</span> square list))

(<span class="org-keyword">define</span> (<span class="org-function-name">append</span> seq1 seq2)
  (accumulate cons seq1 seq2))

(test '(1 2 3 1 2 3) (append list list))

(<span class="org-keyword">define</span> (<span class="org-function-name">length</span> sequence)
  (accumulate (<span class="org-keyword">lambda</span> (x y) (+ y 1)) 0 sequence))

(test 3 (length list))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-80" class="outline-2">
<h2 id="sec-80"><span class="section-number-2">80</span> <span class="done DONE">DONE</span> 2.34</h2>
<div class="outline-text-2" id="text-80">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(<span class="org-keyword">define</span> (<span class="org-function-name">horner-eval</span> x coefficient-sequence)
  (accumulate (<span class="org-keyword">lambda</span> (this-coeff higher-terms) (+ (* higher-terms x) this-coeff))
              0
              coefficient-sequence))

(test 79 (horner-eval 2 (list 1 3 0 5 0 1)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-81" class="outline-2">
<h2 id="sec-81"><span class="section-number-2">81</span> <span class="done DONE">DONE</span> 2.35</h2>
<div class="outline-text-2" id="text-81">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(<span class="org-keyword">define</span> (<span class="org-function-name">count-leaves</span> t)
  (accumulate + 0 (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (subtree)
                         (<span class="org-keyword">if</span> (pair? subtree)
                             (count-leaves subtree)
                             (<span class="org-keyword">if</span> (null? subtree) 0 1)))
                       t)))

(<span class="org-keyword">define</span> <span class="org-function-name">x</span> (cons (list 1 2 '()) (list 3 4)))

(test 4 (count-leaves x))
(test 8 (count-leaves (list x x)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-82" class="outline-2">
<h2 id="sec-82"><span class="section-number-2">82</span> <span class="done DONE">DONE</span> 2.36</h2>
<div class="outline-text-2" id="text-82">
<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">accumulate-n</span> op init seqs)
  (<span class="org-keyword">if</span> (null? (car seqs))
      nil
      (cons (accumulate op init (<span class="org-keyword">map</span> car seqs))
            (accumulate-n op init (<span class="org-keyword">map</span> cdr seqs)))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(include <span class="org-string">"accumulate-n.scm"</span>)

(<span class="org-keyword">define</span> <span class="org-function-name">s</span> '((1 2 3) (4 5 6) (7 8 9) (10 11 12)))

(test '(22 26 30) (accumulate-n + 0 s))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-83" class="outline-2">
<h2 id="sec-83"><span class="section-number-2">83</span> <span class="done DONE">DONE</span> 2.37</h2>
<div class="outline-text-2" id="text-83">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(include <span class="org-string">"accumulate-n.scm"</span>)

(<span class="org-keyword">define</span> <span class="org-function-name">m</span> '((1 -1 2) (0 -3 1)))

(<span class="org-keyword">define</span> <span class="org-function-name">v</span> '(2 1 0))

(<span class="org-keyword">define</span> (<span class="org-function-name">dot-product</span> v w)
  (accumulate + 0 (<span class="org-keyword">map</span> * v w)))

(<span class="org-keyword">define</span> (<span class="org-function-name">matrix-*-vector</span> m v)
  (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (w) (dot-product v w)) m))

(<span class="org-keyword">define</span> (<span class="org-function-name">transpose</span> mat)
  (accumulate-n cons '() mat))

(<span class="org-keyword">define</span> (<span class="org-function-name">matrix-*-matrix</span> m n)
  (<span class="org-keyword">let</span> ((cols (transpose n)))
    (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (w) (matrix-*-vector cols w)) m)))

(test '(1 -3) (matrix-*-vector m v))

(test '((1 0) (-1 -3) (2 1)) (transpose m))

(test '((6 5) (5 10)) (matrix-*-matrix m (transpose m)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-84" class="outline-2">
<h2 id="sec-84"><span class="section-number-2">84</span> <span class="done DONE">DONE</span> 2.38</h2>
<div class="outline-text-2" id="text-84">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp)

(<span class="org-keyword">define</span> <span class="org-function-name">fold-right</span> accumulate)

(<span class="org-keyword">define</span> (<span class="org-function-name">fold-left</span> op initial sequence)
  (<span class="org-keyword">define</span> (<span class="org-function-name">iter</span> result rest)
    (<span class="org-keyword">if</span> (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(include <span class="org-string">"fold.scm"</span>)

(test (/ 3 2) (fold-right / 1 (list 1 2 3)))
(test (/ 1 6) (fold-left / 1 (list 1 2 3)))
(test '(1 (2 (3 ()))) (fold-right list nil (list 1 2 3)))
(test '(((() 1) 2) 3) (fold-left list nil (list 1 2 3)))
</pre>
</div>

<p>
<code>op</code> needs to be commutative for <code>fold-right</code> and <code>fold-left</code> to
produce the same result.
</p>
</div>
</div>
<div id="outline-container-sec-85" class="outline-2">
<h2 id="sec-85"><span class="section-number-2">85</span> <span class="done DONE">DONE</span> 2.39</h2>
<div class="outline-text-2" id="text-85">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(include <span class="org-string">"fold.scm"</span>)

(<span class="org-keyword">define</span> <span class="org-function-name">l</span> '(1 2 3))

(<span class="org-keyword">define</span> (<span class="org-function-name">reverse</span> sequence)
  (fold-right (<span class="org-keyword">lambda</span> (x y) (append y (list x))) nil sequence))

(test '(3 2 1) (reverse l))

(<span class="org-keyword">define</span> (<span class="org-function-name">reverse</span> sequence)
  (fold-left (<span class="org-keyword">lambda</span> (x y) (cons y x)) nil sequence))

(test '(3 2 1) (reverse l))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-86" class="outline-2">
<h2 id="sec-86"><span class="section-number-2">86</span> <span class="done DONE">DONE</span> 2.40</h2>
<div class="outline-text-2" id="text-86">
<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">unique-pairs</span> n)
  (flatmap
   (<span class="org-keyword">lambda</span> (i)
     (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (j) (list i j))
          (enumerate-interval 1 (- i 1))))
   (enumerate-interval 1 n)))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp srfi-1 test)

(include <span class="org-string">"unique-pairs.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">prime-sum?</span> pair)
  (prime? (+ (car pair) (cadr pair))))

(<span class="org-keyword">define</span> (<span class="org-function-name">make-pair-sum</span> pair)
  (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))

(<span class="org-keyword">define</span> (<span class="org-function-name">prime-sum-pairs</span> n)
  (<span class="org-keyword">map</span> make-pair-sum (filter prime-sum? (unique-pairs n))))

(test '((2 1 3) (3 2 5) (4 1 5) (4 3 7) (5 2 7) (6 1 7) (6 5 11))
      (prime-sum-pairs 6))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-87" class="outline-2">
<h2 id="sec-87"><span class="section-number-2">87</span> <span class="done DONE">DONE</span> 2.41</h2>
<div class="outline-text-2" id="text-87">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp srfi-1 test)

(include <span class="org-string">"unique-pairs.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">unique-triples</span> n)
  (flatmap
   (<span class="org-keyword">lambda</span> (i)
     (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (j) (cons i j)) (unique-pairs (- i 1))))
   (enumerate-interval 1 n)))

(<span class="org-keyword">define</span> (<span class="org-function-name">sum-to?</span> s)
  (<span class="org-keyword">lambda</span> (triple)
    (= s (apply + triple))))

(<span class="org-keyword">define</span> (<span class="org-function-name">sum-to-triples</span> n s)
  (filter (sum-to? s) (unique-triples n)))

(test '((5 4 3) (6 4 2) (6 5 1)) (sum-to-triples 6 12))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-88" class="outline-2">
<h2 id="sec-88"><span class="section-number-2">88</span> <span class="done DONE">DONE</span> 2.42</h2>
<div class="outline-text-2" id="text-88">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp srfi-1 test)

(<span class="org-keyword">define</span> <span class="org-function-name">empty-board</span> '())

(<span class="org-keyword">define</span> (<span class="org-function-name">slope</span> x1 y1 x2 y2)
  (/ (- y2 y1) (- x2 x1)))

(<span class="org-keyword">define</span> (<span class="org-function-name">safe?</span> k positions)
  (<span class="org-keyword">let</span> ((kth-position (list-ref positions (- k 1))))
    (<span class="org-keyword">let</span> <span class="org-function-name">iter</span> ((positions positions)
               (i 1))
      (<span class="org-keyword">or</span> (null? positions)
          (<span class="org-keyword">if</span> (= i k)
              (iter (cdr positions) (+ i 1))
              (<span class="org-keyword">let*</span> ((ith-position (car positions))
                     (slope (slope i ith-position
                                   k kth-position)))
                (<span class="org-keyword">and</span> (not (<span class="org-keyword">or</span> (= slope 0)
                              (= (abs slope) 1)))
                     (iter (cdr positions) (+ i 1)))))))))

(<span class="org-keyword">define</span> (<span class="org-function-name">adjoin-position</span> new-row k rest-of-queens)
  (append (take rest-of-queens (- k 1))
          (list new-row)
          (drop rest-of-queens (- k 1))))

(<span class="org-keyword">define</span> (<span class="org-function-name">queens</span> board-size)
  (<span class="org-keyword">define</span> (<span class="org-function-name">queen-cols</span> k)
    (<span class="org-keyword">if</span> (= k 0)
        (list empty-board)
        (filter
         (<span class="org-keyword">lambda</span> (positions) (safe? k positions))
         (flatmap
          (<span class="org-keyword">lambda</span> (rest-of-queens)
            (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (new-row)
                   (adjoin-position new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))

(time (test 92 (length (queens 8))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-89" class="outline-2">
<h2 id="sec-89"><span class="section-number-2">89</span> <span class="done DONE">DONE</span> 2.43</h2>
<div class="outline-text-2" id="text-89">
<p>
The first implementation of queens prunes the tree based on <code>safe?</code>;
the second doesn’t. The second, therefore, evaluates all \(6 ^ 6 =
  46656\) possibilities; pruning on <code>safe?</code> should reduce all
subsequent moves by at least one possibility, meaning that the tree
is at worst \(6! = 720\) possibilities and that the non-pruning
version should run in more than \(64T\).
</p>

<p>
Scratch that:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="right">\(k\)</th>
<th scope="col" class="right">\(t\) (ms)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="right">8</td>
<td class="right">0.18</td>
</tr>

<tr>
<td class="right">9</td>
<td class="right">1.12</td>
</tr>

<tr>
<td class="right">10</td>
<td class="right">5.44</td>
</tr>

<tr>
<td class="right">11</td>
<td class="right">22.85</td>
</tr>
</tbody>
</table>

<p>
Appears to obey a power-law implying \(O(n^{15})\).
</p>
</div>
</div>
<div id="outline-container-sec-90" class="outline-2">
<h2 id="sec-90"><span class="section-number-2">90</span> <span class="done DONE">DONE</span> 2.44</h2>
<div class="outline-text-2" id="text-90">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp)

(<span class="org-keyword">define</span> (<span class="org-function-name">up-split</span> painter n)
  (<span class="org-keyword">if</span> (= n 0)
      painter
      (<span class="org-keyword">let</span> ((smaller (up-split painter (- n 1))))
        (below painter (beside smaller smaller)))))

(write-painter-to-png (up-split (image-&gt;painter <span class="org-string">"lena.png"</span>) 2) <span class="org-string">"2.44.png"</span>)
</pre>
</div>


<div class="figure">
<p><img src="./2.44.png" alt="2.44.png" />
</p>
<p><span class="figure-number">Figure 5:</span> <code>up-split</code></p>
</div>
</div>
</div>

<div id="outline-container-sec-91" class="outline-2">
<h2 id="sec-91"><span class="section-number-2">91</span> <span class="done DONE">DONE</span> 2.45</h2>
<div class="outline-text-2" id="text-91">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp)

(<span class="org-keyword">define</span> (<span class="org-function-name">split</span> first-preposition second-preposition)
  (<span class="org-keyword">lambda</span> (painter n)
    (<span class="org-keyword">if</span> (= n 0)
        painter
        (<span class="org-keyword">let</span> ((smaller ((split first-preposition second-preposition)
                        painter
                        (- n 1))))
          (first-preposition painter (second-preposition smaller smaller))))))

(<span class="org-keyword">define</span> <span class="org-function-name">right-split</span> (split beside below))
(<span class="org-keyword">define</span> <span class="org-function-name">up-split</span> (split below beside))

(write-painter-to-png (right-split (image-&gt;painter <span class="org-string">"lena.png"</span>) 4)
                      <span class="org-string">"2.45-right-split.png"</span>)
(write-painter-to-png (up-split (image-&gt;painter <span class="org-string">"lena.png"</span>) 4)
                      <span class="org-string">"2.45-up-split.png"</span>)
</pre>
</div>



<div class="figure">
<p><img src="./2.45-right-split.png" alt="2.45-right-split.png" />
</p>
<p><span class="figure-number">Figure 6:</span> <code>right-split</code></p>
</div>


<div class="figure">
<p><img src="./2.45-up-split.png" alt="2.45-up-split.png" />
</p>
<p><span class="figure-number">Figure 7:</span> <code>up-split</code></p>
</div>
</div>
</div>

<div id="outline-container-sec-92" class="outline-2">
<h2 id="sec-92"><span class="section-number-2">92</span> <span class="done DONE">DONE</span> 2.46</h2>
<div class="outline-text-2" id="text-92">
<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> <span class="org-function-name">make-vect</span> cons)
(<span class="org-keyword">define</span> <span class="org-function-name">xcor-vect</span> car)
(<span class="org-keyword">define</span> <span class="org-function-name">ycor-vect</span> cdr)

(<span class="org-keyword">define</span> (<span class="org-function-name">add-vect</span> v1 v2)
  (make-vect (+ (xcor-vect v1)
                (xcor-vect v2))
             (+ (ycor-vect v1)
                (ycor-vect v2))))

(<span class="org-keyword">define</span> (<span class="org-function-name">sub-vect</span> v1 v2)
  (add-vect v1 (make-vect (- (xcor-vect v2))
                          (- (ycor-vect v2)))))

(<span class="org-keyword">define</span> (<span class="org-function-name">scale-vect</span> s v1)
  (make-vect (* s (xcor-vect v1))
             (* s (ycor-vect v1))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use test)
(include <span class="org-string">"vect.scm"</span>)

(test (make-vect 4 7)
      (add-vect (make-vect 1 2) (make-vect 3 5)))

(test (make-vect -2 -3)
      (sub-vect (make-vect 1 2) (make-vect 3 5)))

(test (make-vect 6 15)
      (scale-vect 3 (make-vect 2 5)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-93" class="outline-2">
<h2 id="sec-93"><span class="section-number-2">93</span> <span class="done DONE">DONE</span> 2.47</h2>
<div class="outline-text-2" id="text-93">
<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">make-frame</span> origin edge1 edge2)
  (list origin edge1 edge2))

(<span class="org-keyword">define</span> <span class="org-function-name">origin-frame</span> car)
(<span class="org-keyword">define</span> <span class="org-function-name">edge1-frame</span> cadr)
(<span class="org-keyword">define</span> <span class="org-function-name">edge2-frame</span> caddr)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use test)
(include <span class="org-string">"frame.scm"</span>)

(<span class="org-keyword">let</span> ((frame (make-frame (make-vect 0 0)
                         (make-vect 1 1)
                         (make-vect 2 2))))
  (test (make-vect 0 0) (origin-frame frame))
  (test (make-vect 1 1) (edge1-frame frame))
  (test (make-vect 2 2) (edge2-frame frame)))

<span class="org-comment-delimiter">;; </span><span class="org-comment">The other representation.</span>
(<span class="org-keyword">define</span> (<span class="org-function-name">make-frame</span> origin edge1 edge2)
  (cons origin (cons edge1 edge2)))

(<span class="org-keyword">define</span> <span class="org-function-name">edge2-frame</span> cddr)

(<span class="org-keyword">let</span> ((frame (make-frame (make-vect 0 0)
                         (make-vect 1 1)
                         (make-vect 2 2))))
  (test (make-vect 0 0) (origin-frame frame))
  (test (make-vect 1 1) (edge1-frame frame))
  (test (make-vect 2 2) (edge2-frame frame)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-94" class="outline-2">
<h2 id="sec-94"><span class="section-number-2">94</span> <span class="done DONE">DONE</span> 2.48</h2>
<div class="outline-text-2" id="text-94">
<div class="org-src-container">

<pre class="src src-scheme"><span class="org-comment-delimiter">;; </span><span class="org-comment">We'll reuse make-segment from 2.2.</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-95" class="outline-2">
<h2 id="sec-95"><span class="section-number-2">95</span> <span class="done DONE">DONE</span> 2.49</h2>
<div class="outline-text-2" id="text-95">
<div class="org-src-container">

<pre class="src src-scheme">(include <span class="org-string">"segment.scm"</span>)
(include <span class="org-string">"vect.scm"</span>)

(<span class="org-keyword">define</span> <span class="org-function-name">outline</span>
  (list
   (make-segment (make-vect 0 0) (make-vect 0 1))
   (make-segment (make-vect 0 1) (make-vect 1 1))
   (make-segment (make-vect 1 1) (make-vect 1 0))
   (make-segment (make-vect 1 0) (make-vect 0 0))))

(<span class="org-keyword">define</span> <span class="org-function-name">x</span>
  (list
   (make-segment (make-vect 0 0) (make-vect 1 1))
   (make-segment (make-vect 0 1) (make-vect 1 0))))

(<span class="org-keyword">define</span> <span class="org-function-name">diamond</span>
  (list
   (make-segment (make-vect 0.5 0) (make-vect 1 0.5))
   (make-segment (make-vect 1 0.5) (make-vect 0.5 1))
   (make-segment (make-vect 0.5 1) (make-vect 0 0.5))
   (make-segment (make-vect 0 0.5) (make-vect 0.5 0))))

<span class="org-comment-delimiter">;; </span><span class="org-comment">Needs to be asymmetrical, so we can see rotations and flips.</span>
(<span class="org-keyword">define</span> <span class="org-function-name">wave</span>
  (list
   <span class="org-comment-delimiter">;; </span><span class="org-comment">Left leg</span>
   (make-segment (make-vect 0.3 1) (make-vect 0.4 0.6))
   (make-segment (make-vect 0.4 1) (make-vect 0.5 0.7))
   <span class="org-comment-delimiter">;; </span><span class="org-comment">Right leg</span>
   (make-segment (make-vect 0.6 1) (make-vect 0.5 0.7))
   (make-segment (make-vect 0.7 1) (make-vect 0.6 0.6))
   <span class="org-comment-delimiter">;; </span><span class="org-comment">Torso</span>
   (make-segment (make-vect 0.4 0.6) (make-vect 0.4 0.4))
   (make-segment (make-vect 0.6 0.6) (make-vect 0.6 0.4))
   <span class="org-comment-delimiter">;; </span><span class="org-comment">Left arm</span>
   (make-segment (make-vect 0.4 0.4) (make-vect 0.2 0.35))
   (make-segment (make-vect 0.2 0.35) (make-vect 0.2 0.25))
   (make-segment (make-vect 0.2 0.25) (make-vect 0.45 0.3))
   <span class="org-comment-delimiter">;; </span><span class="org-comment">Right arm</span>
   (make-segment (make-vect 0.6 0.4) (make-vect 0.8 0.45))
   (make-segment (make-vect 0.8 0.45) (make-vect 0.8 0.35))
   (make-segment (make-vect 0.8 0.35) (make-vect 0.55 0.3))
   <span class="org-comment-delimiter">;; </span><span class="org-comment">Neck</span>
   (make-segment (make-vect 0.45 0.3) (make-vect 0.45 0.25))
   (make-segment (make-vect 0.55 0.3) (make-vect 0.55 0.25))
   <span class="org-comment-delimiter">;; </span><span class="org-comment">Head</span>
   (make-segment (make-vect 0.45 0.25) (make-vect 0.425 0.25))
   (make-segment (make-vect 0.425 0.25) (make-vect 0.425 0.05))
   (make-segment (make-vect 0.425 0.05) (make-vect 0.575 0.05))
   (make-segment (make-vect 0.575 0.05) (make-vect 0.575 0.25))
   (make-segment (make-vect 0.575 0.25) (make-vect 0.55 0.25))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp)
(include <span class="org-string">"painters.scm"</span>)

(write-painter-to-svg (segments-&gt;painter outline) <span class="org-string">"2.49-outline.svg"</span>)
(write-painter-to-svg (segments-&gt;painter x) <span class="org-string">"2.49-x.svg"</span>)
(write-painter-to-svg (segments-&gt;painter diamond) <span class="org-string">"2.49-diamond.svg"</span>)
(write-painter-to-svg (segments-&gt;painter wave) <span class="org-string">"2.49-wave.svg"</span>)
</pre>
</div>


<div class="figure">
<p><img src="./2.49-diamond.svg" alt="2.49-diamond.svg" />
</p>
<p><span class="figure-number">Figure 8:</span> Diamond</p>
</div>


<div class="figure">
<p><img src="./2.49-outline.svg" alt="2.49-outline.svg" />
</p>
<p><span class="figure-number">Figure 9:</span> Outline</p>
</div>


<div class="figure">
<p><img src="./2.49-x.svg" alt="2.49-x.svg" />
</p>
<p><span class="figure-number">Figure 10:</span> X</p>
</div>


<div class="figure">
<p><img src="./2.49-wave.svg" alt="2.49-wave.svg" />
</p>
<p><span class="figure-number">Figure 11:</span> Wave</p>
</div>
</div>
</div>
<div id="outline-container-sec-96" class="outline-2">
<h2 id="sec-96"><span class="section-number-2">96</span> <span class="done DONE">DONE</span> 2.50</h2>
<div class="outline-text-2" id="text-96">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp)

(<span class="org-keyword">define</span> (<span class="org-function-name">flip-horiz</span> painter)
  (transform-painter painter
                     (make-vect 1 0)
                     (make-vect 0 0)
                     (make-vect 1 1)))

(<span class="org-keyword">define</span> <span class="org-function-name">rotate180</span> (compose rotate90 rotate90))
(<span class="org-keyword">define</span> <span class="org-function-name">rotate270</span> (compose rotate180 rotate90))

(write-painter-to-png (flip-horiz (image-&gt;painter <span class="org-string">"lena.png"</span>)) <span class="org-string">"2.50-horiz.png"</span>)
(write-painter-to-png (rotate180 (image-&gt;painter <span class="org-string">"lena.png"</span>)) <span class="org-string">"2.50-rotate180.png"</span>)
(write-painter-to-png (rotate270 (image-&gt;painter <span class="org-string">"lena.png"</span>)) <span class="org-string">"2.50-rotate270.png"</span>)
</pre>
</div>


<div class="figure">
<p><img src="./2.50-horiz.png" alt="2.50-horiz.png" />
</p>
<p><span class="figure-number">Figure 12:</span> Flipped horizontally</p>
</div>


<div class="figure">
<p><img src="./2.50-rotate180.png" alt="2.50-rotate180.png" />
</p>
<p><span class="figure-number">Figure 13:</span> Rotated 180°</p>
</div>


<div class="figure">
<p><img src="./2.50-rotate270.png" alt="2.50-rotate270.png" />
</p>
<p><span class="figure-number">Figure 14:</span> Rotated 270°</p>
</div>
</div>
</div>
<div id="outline-container-sec-97" class="outline-2">
<h2 id="sec-97"><span class="section-number-2">97</span> <span class="done DONE">DONE</span> 2.51</h2>
<div class="outline-text-2" id="text-97">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp)

(<span class="org-keyword">define</span> (<span class="org-function-name">below</span> painter1 painter2)
  (<span class="org-keyword">let</span> ((split-point (make-vect 1 0.5)))
    (<span class="org-keyword">let</span> ((paint-top
           (transform-painter
            painter2
            (make-vect 0 0)
            (make-vect 1 0)
            (make-vect 0 0.5)))
          (paint-bottom
           (transform-painter
            painter1
            (make-vect 0 0.5)
            split-point
            (make-vect 0 1)
            )))
      (<span class="org-keyword">lambda</span> (frame)
        (paint-top frame)
        (paint-bottom frame)))))

(<span class="org-keyword">let</span> ((lena (image-&gt;painter <span class="org-string">"lena.png"</span>)))
  (write-painter-to-png (below lena lena) <span class="org-string">"2.51-below-direct.png"</span>))

(<span class="org-keyword">define</span> (<span class="org-function-name">below</span> painter1 painter2)
  (rotate90 (beside (rotate270 painter1) (rotate270 painter2))))

(<span class="org-keyword">let</span> ((lena (image-&gt;painter <span class="org-string">"lena.png"</span>)))
  (write-painter-to-png (below lena lena) <span class="org-string">"2.51-below-indirect.png"</span>))
</pre>
</div>


<div class="figure">
<p><img src="./2.51-below-direct.png" alt="2.51-below-direct.png" />
</p>
<p><span class="figure-number">Figure 15:</span> <code>below</code> written directly</p>
</div>


<div class="figure">
<p><img src="./2.51-below-indirect.png" alt="2.51-below-indirect.png" />
</p>
<p><span class="figure-number">Figure 16:</span> <code>below</code> written indirectly (i.e. in terms of rotations)</p>
</div>
</div>
</div>
<div id="outline-container-sec-98" class="outline-2">
<h2 id="sec-98"><span class="section-number-2">98</span> <span class="done DONE">DONE</span> 2.52</h2>
<div class="outline-text-2" id="text-98">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp)
(include <span class="org-string">"painters.scm"</span>)

(<span class="org-keyword">define</span> <span class="org-function-name">wave-with-smile</span>
  (append wave
          (list (make-segment (make-vect 0.48 0.2) (make-vect 0.52 0.2))
                (make-segment (make-vect 0.45 0.13) (make-vect 0.47 0.13))
                (make-segment (make-vect 0.53 0.13) (make-vect 0.55 0.13)))))

(write-painter-to-svg (segments-&gt;painter wave-with-smile) <span class="org-string">"2.52-smile.svg"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">corner-split</span> painter n)
  (<span class="org-keyword">if</span> (= n 0)
      painter
      (<span class="org-keyword">let</span> ((up (up-split painter (- n 1)))
            (right (right-split painter (- n 1))))
        (<span class="org-keyword">let</span> ((top-left up)
              (bottom-right right)
              (corner (corner-split painter (- n 1))))
          (beside (below painter top-left)
                  (below bottom-right corner))))))

(write-painter-to-png (corner-split (image-&gt;painter <span class="org-string">"lena.png"</span>) 5)
                     <span class="org-string">"2.52-corner-split.png"</span>)

(write-painter-to-png (square-limit (flip-horiz (image-&gt;painter <span class="org-string">"lena.png"</span>)) 5)
                     <span class="org-string">"2.52-square-limit.png"</span>)
</pre>
</div>


<div class="figure">
<p><img src="./2.52-smile.svg" alt="2.52-smile.svg" />
</p>
<p><span class="figure-number">Figure 17:</span> Add a smile</p>
</div>


<div class="figure">
<p><img src="./2.52-corner-split.png" alt="2.52-corner-split.png" />
</p>
<p><span class="figure-number">Figure 18:</span> Corner split with only one top and one right</p>
</div>


<div class="figure">
<p><img src="./2.52-square-limit.png" alt="2.52-square-limit.png" />
</p>
<p><span class="figure-number">Figure 19:</span> Square limit with flipped wave</p>
</div>
</div>
</div>
<div id="outline-container-sec-99" class="outline-2">
<h2 id="sec-99"><span class="section-number-2">99</span> <span class="done DONE">DONE</span> 2.53</h2>
<div class="outline-text-2" id="text-99">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(test '(a b c) (list 'a 'b 'c))
(test '((george)) (list (list 'george)))
(test '((y1 y2)) (cdr '((x1 x2) (y1 y2))))
(test '(y1 y2) (cadr '((x1 x2) (y1 y2))))
(test #f (pair? (car '(a short list))))
(test #f (memq 'red '((red shoes) (blue shoes))))
(test '(red shoes blue shoes) (memq 'red '(red shoes blue shoes)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-100" class="outline-2">
<h2 id="sec-100"><span class="section-number-2">100</span> <span class="done DONE">DONE</span> 2.54</h2>
<div class="outline-text-2" id="text-100">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">equal?</span> l1 l2)
  (<span class="org-keyword">cond</span> ((<span class="org-keyword">and</span> (symbol? l1) (symbol? l2))
         (eq? l1 l2))
        ((<span class="org-keyword">and</span> (number? l1) (number? l2))
         (= l1 l2))
        ((<span class="org-keyword">and</span> (pair? l1) (pair? l2))
         (<span class="org-keyword">and</span> (equal? (car l1) (car l2))
              (equal? (cdr l1) (cdr l2))))))

(test-assert (equal? '(this is a list) '(this is a list)))
(test-assert (not (equal? '(this is a list) '(this (is a) list))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-101" class="outline-2">
<h2 id="sec-101"><span class="section-number-2">101</span> <span class="done DONE">DONE</span> 2.55</h2>
<div class="outline-text-2" id="text-101">
<p>
<code>’’abracadabra</code> evaluates to <code>(quote (quote abracadabra))</code>; the
<code>car</code> of which evaluates to <code>quote</code>.
</p>
</div>
</div>
<div id="outline-container-sec-102" class="outline-2">
<h2 id="sec-102"><span class="section-number-2">102</span> <span class="done DONE">DONE</span> 2.56</h2>
<div class="outline-text-2" id="text-102">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(<span class="org-keyword">define</span> (<span class="org-function-name">make-diff</span> a1 a2)
  (<span class="org-keyword">cond</span> ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((<span class="org-keyword">and</span> (number? a1) (number? a2))
         (- a1 a2))
        (<span class="org-keyword">else</span> (list '- a1 a2))))

(<span class="org-keyword">define</span> (<span class="org-function-name">deriv</span> exp var)
  (<span class="org-keyword">cond</span> ((number? exp) 0)
        ((variable? exp) (<span class="org-keyword">if</span> (same-variable? exp var) 1 0))
        ((sum? exp) (make-sum (deriv (addend exp) var)
                              (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product (multiplier exp)
                        (deriv (multiplicand exp) var))
          (make-product (deriv (multiplier exp) var)
                        (multiplicand exp))))
        ((exponentiation? exp)
         (<span class="org-keyword">let</span> ((base (base exp))
               (exponent (exponent exp)))
           (make-product exponent
                         (make-product
                          (make-exponentiation base (make-diff exponent 1))
                          (deriv base var)))))
        (<span class="org-keyword">else</span>
         (error <span class="org-string">"Unknown expression type: DERIV"</span> exp))))

(<span class="org-keyword">define</span> (<span class="org-function-name">exponentiation?</span> x) (<span class="org-keyword">and</span> (pair? x) (eq? (car x) '**)))

(<span class="org-keyword">define</span> <span class="org-function-name">base</span> cadr)

(<span class="org-keyword">define</span> <span class="org-function-name">exponent</span> caddr)

(<span class="org-keyword">define</span> (<span class="org-function-name">make-exponentiation</span> b e)
  (<span class="org-keyword">cond</span> ((=number? e 0) 1)
        ((=number? e 1) b)
        ((<span class="org-keyword">and</span> (number? b) (number? e))
         (expt b e))
        (<span class="org-keyword">else</span> (list '** b e))))

(test '(* y (** x (- y 1))) (deriv '(** x y) 'x))
(test '(* 2 x) (deriv '(** x 2) 'x))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-103" class="outline-2">
<h2 id="sec-103"><span class="section-number-2">103</span> <span class="done DONE">DONE</span> 2.57</h2>
<div class="outline-text-2" id="text-103">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(<span class="org-keyword">define</span> (<span class="org-function-name">augend</span> x)
  (<span class="org-keyword">let</span> ((augenda (cddr x)))
    (<span class="org-keyword">if</span> (null? (cdr augenda))
        (car augenda)
        (cons '+ augenda))))

(<span class="org-keyword">define</span> (<span class="org-function-name">multiplicand</span> x)
  (<span class="org-keyword">let</span> ((multiplicanda (cddr x)))
    (<span class="org-keyword">if</span> (null? (cdr multiplicanda))
        (car multiplicanda)
        (cons '* multiplicanda))))

(test '(+ (* x y) (* y (+ x 3))) (deriv '(* x y (+ x 3)) 'x))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-104" class="outline-2">
<h2 id="sec-104"><span class="section-number-2">104</span> <span class="done DONE">DONE</span> 2.58</h2>
<div class="outline-text-2" id="text-104">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(<span class="org-keyword">define</span> <span class="org-function-name">addend</span> car)
(<span class="org-keyword">define</span> <span class="org-function-name">augend</span> caddr)
(<span class="org-keyword">define</span> (<span class="org-function-name">sum?</span> x) (<span class="org-keyword">and</span> (pair? x) (eq? (cadr x) '+)))

(<span class="org-keyword">define</span> <span class="org-function-name">multiplier</span> car)
(<span class="org-keyword">define</span> <span class="org-function-name">multiplicand</span> caddr)
(<span class="org-keyword">define</span> (<span class="org-function-name">product?</span> x) (<span class="org-keyword">and</span> (pair? x) (eq? (cadr x) '*)))

(test 4 (deriv '(x + (3 * (x + (y + 2)))) 'x))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp srfi-1 test)

(<span class="org-keyword">define</span> (<span class="org-function-name">list-or-symbol</span> x)
  (<span class="org-keyword">if</span> (<span class="org-keyword">and</span> (pair? x) (null? (cdr x)))
      (car x)
      x))

(<span class="org-keyword">define</span> (<span class="org-function-name">addend</span> x)
  (list-or-symbol (take-while (<span class="org-keyword">lambda</span> (x) (not (eq? x '+))) x)))

(<span class="org-keyword">define</span> (<span class="org-function-name">augend</span> x)
  (list-or-symbol (cdr (drop-while (<span class="org-keyword">lambda</span> (x) (not (eq? x '+))) x))))

(<span class="org-keyword">define</span> (<span class="org-function-name">sum?</span> x) (<span class="org-keyword">and</span> (pair? x) (<span class="org-keyword">and</span> (memq '+ x) #t)))

(<span class="org-keyword">define</span> <span class="org-function-name">multiplier</span> car)

(<span class="org-keyword">define</span> (<span class="org-function-name">multiplicand</span> x)
  (list-or-symbol (cddr x)))

(<span class="org-keyword">define</span> (<span class="org-function-name">product?</span> x) (<span class="org-keyword">and</span> (pair? x) (eq? (cadr x) '*)))

(test 4 (deriv '(x + 3 * (x + y + 2)) 'x))

(test 5 (deriv '(x * 3 + x * 2 + y * 3) 'x))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-105" class="outline-2">
<h2 id="sec-105"><span class="section-number-2">105</span> <span class="done DONE">DONE</span> 2.59</h2>
<div class="outline-text-2" id="text-105">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(<span class="org-keyword">define</span> (<span class="org-function-name">union-set</span> set1 set2)
  (<span class="org-keyword">if</span> (null? set1)
      set2
      (<span class="org-keyword">if</span> (element-of-set? (car set1) set2)
          (union-set (cdr set1) set2)
          (union-set (cdr set1) (cons (car set1) set2)))))

(<span class="org-keyword">let</span> ((set1 '(1 2 3))
      (set2 '(3 4 5)))
  (test '(2 1 3 4 5) (union-set set1 set2)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-106" class="outline-2">
<h2 id="sec-106"><span class="section-number-2">106</span> <span class="done DONE">DONE</span> 2.60</h2>
<div class="outline-text-2" id="text-106">
<p>
<code>element-of-set?</code> is still \(\Theta(n)\), <code>adjoin-set</code> went from
\(\Theta(n)\) to \(\Theta(1)\), <code>union-set</code> is went from \(\Theta(n^2)\)
to \(\Theta(n)\) (the complexity of <code>append</code>) and <code>intersection-set</code>
is still \(\Theta(n^2)\); where \(n\) in the repeated case is some
constant factor larger than \(n\) in the unique case.
</p>

<p>
It might be useful where you need cheap writes.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(<span class="org-keyword">define</span> <span class="org-function-name">set</span> '(2 3 2 1 3 2 2))

(test-assert (element-of-set? 1 set))

(<span class="org-keyword">define</span> <span class="org-function-name">adjoin-set</span> cons)

(test '(4 2 3 2 1 3 2 2)
      (adjoin-set 4 set))

(<span class="org-keyword">define</span> <span class="org-function-name">union-set</span> append)

(test '(2 3 2 1 3 2 2 2 3 2 1 3 2 2)
      (union-set set set))

(test '(3 2 2) (intersection-set '(3 2 2) set))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-107" class="outline-2">
<h2 id="sec-107"><span class="section-number-2">107</span> <span class="done DONE">DONE</span> 2.61</h2>
<div class="outline-text-2" id="text-107">
<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">element-of-set?</span> x set)
  (<span class="org-keyword">cond</span> ((null? set) #f)
        ((= x (car set)) #t)
        ((&lt; x (car set)) #f)
        (<span class="org-keyword">else</span> (element-of-set? x (cdr set)))))

(<span class="org-keyword">define</span> (<span class="org-function-name">intersection-set</span> set1 set2)
  (<span class="org-keyword">if</span> (<span class="org-keyword">or</span> (null? set1) (null? set2))
      '()
      (<span class="org-keyword">let</span> ((x1 (car set1)) (x2 (car set2)))
        (<span class="org-keyword">cond</span> ((= x1 x2)
               (cons x1 (intersection-set (cdr set1) (cdr set2))))
              ((&lt; x1 x2)
               (intersection-set (cdr set1) set2))
              ((&lt; x2 x1)
               (intersection-set set1 (cdr set2)))))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)
(include <span class="org-string">"ordered-sets.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">adjoin-set</span> x set)
  (<span class="org-keyword">if</span> (null? set)
      (list x)
      (<span class="org-keyword">let</span> ((first (car set)))
        (<span class="org-keyword">if</span> (&lt; first x)
            (cons first (adjoin-set x (cdr set)))
            (cons x set)))))

(<span class="org-keyword">define</span> <span class="org-function-name">set</span> '(1 3 6 10))

(test '(1 3 5 6 10) (adjoin-set 5 '(1 3 6 10)))
(test '(5) (adjoin-set 5 '()))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-108" class="outline-2">
<h2 id="sec-108"><span class="section-number-2">108</span> <span class="done DONE">DONE</span> 2.62</h2>
<div class="outline-text-2" id="text-108">
<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">union-set</span> set1 set2)
  (<span class="org-keyword">cond</span> ((null? set1) set2)
        ((null? set2) set1)
        (<span class="org-keyword">else</span>
         (<span class="org-keyword">let</span> ((x1 (car set1)) (x2 (car set2)))
           (<span class="org-keyword">cond</span> ((= x1 x2)
                  (cons x1 (union-set (cdr set1) (cdr set2))))
                 ((&lt; x1 x2)
                  (cons x1 (union-set (cdr set1) set2)))
                 (<span class="org-keyword">else</span>
                  (cons x2 (union-set set1 (cdr set2)))))))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(include <span class="org-string">"union-set.scm"</span>)

(<span class="org-keyword">define</span> <span class="org-function-name">set1</span> '(1 3 6 10))

(<span class="org-keyword">define</span> <span class="org-function-name">set2</span> '(0 2 3 7 12))

(test '(0 1 2 3 6 7 10 12) (union-set set1 set2))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-109" class="outline-2">
<h2 id="sec-109"><span class="section-number-2">109</span> <span class="done DONE">DONE</span> 2.63</h2>
<div class="outline-text-2" id="text-109">
<p>
The two procedures should return the same result for every tree,
since they’re both doing a topological sort over the entries.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">entry</span> tree) (car tree))
(<span class="org-keyword">define</span> (<span class="org-function-name">left-branch</span> tree) (cadr tree))
(<span class="org-keyword">define</span> (<span class="org-function-name">right-branch</span> tree) (caddr tree))
(<span class="org-keyword">define</span> (<span class="org-function-name">make-tree</span> entry left right)
  (list entry left right))

(<span class="org-keyword">define</span> (<span class="org-function-name">element-of-set?</span> x set)
  (<span class="org-keyword">cond</span> ((null? set) #f)
        ((= x (entry set)) #t)
        ((&lt; x (entry set))
         (element-of-set? x (left-branch set)))
        ((&gt; x (entry set))
         (element-of-set? x (right-branch set)))))

(<span class="org-keyword">define</span> (<span class="org-function-name">adjoin-set</span> x set)
  (<span class="org-keyword">cond</span> ((null? set) (make-tree x '() '()))
        ((= x (entry set)) set)
        ((&lt; x (entry set))
         (make-tree (entry set)
                    (adjoin-set x (left-branch set))
                    (right-branch set)))
        ((&gt; x (entry set))
         (make-tree (entry set) (left-branch set)
                    (adjoin-set x (right-branch set))))))

(<span class="org-keyword">define</span> (<span class="org-function-name">tree-&gt;list-1</span> tree)
  (<span class="org-keyword">if</span> (null? tree)
      '()
      (append (tree-&gt;list-1 (left-branch tree))
              (cons (entry tree)
                    (tree-&gt;list-1
                     (right-branch tree))))))

(<span class="org-keyword">define</span> (<span class="org-function-name">tree-&gt;list-2</span> tree)
  (<span class="org-keyword">define</span> (<span class="org-function-name">copy-to-list</span> tree result-list)
    (<span class="org-keyword">if</span> (null? tree)
        result-list
        (copy-to-list (left-branch tree)
                      (cons (entry tree)
                            (copy-to-list
                             (right-branch tree)
                             result-list)))))
  (copy-to-list tree '()))

(<span class="org-keyword">define</span> (<span class="org-function-name">list-&gt;tree</span> elements)
  (car (partial-tree elements (length elements))))

(<span class="org-keyword">define</span> (<span class="org-function-name">partial-tree</span> elts n)
  (<span class="org-keyword">if</span> (= n 0)
      (cons '() elts)
      (<span class="org-keyword">let</span> ((left-size (quotient (- n 1) 2)))
        (<span class="org-keyword">let</span> ((left-result
               (partial-tree elts left-size)))
          (<span class="org-keyword">let</span> ((left-tree (car left-result))
                (non-left-elts (cdr left-result))
                (right-size (- n (+ left-size 1))))
            (<span class="org-keyword">let</span> ((this-entry (car non-left-elts))
                  (right-result
                   (partial-tree
                    (cdr non-left-elts)
                    right-size)))
              (<span class="org-keyword">let</span> ((right-tree (car right-result))
                    (remaining-elts
                     (cdr right-result)))
                (cons (make-tree this-entry
                                 left-tree
                                 right-tree)
                      remaining-elts))))))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)
(include <span class="org-string">"tree-sets.scm"</span>)

(<span class="org-keyword">define</span> <span class="org-function-name">tree-1</span>
  '(7 (3 (1 () ()) (5 () ())) (9 () (11 () ()))))
(<span class="org-keyword">define</span> <span class="org-function-name">tree-2</span>
  '(3 (1 () ()) (7 (5 () ()) (9 () (11 () ())))))
(<span class="org-keyword">define</span> <span class="org-function-name">tree-3</span>
  '(5 (3 (1 () ()) ()) (9 (7 () ()) (11 () ()))))

(test-assert (equal? (tree-&gt;list-1 tree-1)
                     (tree-&gt;list-2 tree-1)))

(test-assert (equal? (tree-&gt;list-1 tree-2)
                     (tree-&gt;list-2 tree-2)))

(test-assert (equal? (tree-&gt;list-1 tree-3)
                     (tree-&gt;list-2 tree-3)))
</pre>
</div>

<p>
<code>tree-&gt;list-1</code> has an additional <code>append</code> at every level of the
tree, whereas <code>tree-&gt;list-2</code> gets away with <code>cons</code> only;
<code>tree-&gt;list-2</code> should grow more slowly, therefore, since <code>append</code> is
a \(\Theta(n)\) operation and <code>cons</code> is \(\Theta(1)\).
</p>
</div>
</div>
<div id="outline-container-sec-110" class="outline-2">
<h2 id="sec-110"><span class="section-number-2">110</span> <span class="done DONE">DONE</span> 2.64</h2>
<div class="outline-text-2" id="text-110">
<div class="org-src-container">

<pre class="src src-scheme">(use test)
(include <span class="org-string">"tree-sets.scm"</span>)

(test '(5 (1 () (3 () ())) (9 (7 () ()) (11 () ())))
      (list-&gt;tree '(1 3 5 7 9 11)))
</pre>
</div>

<p>
In the \(n = 0\) case, we’re at a leaf; return an empty list,
signifying no children.
</p>

<p>
Otherwise, the size of the left-tree (\(leftsize\)) will be half of
the list minus the middle element, which will act as the root;
create the left-tree from the first \(leftsize\) elements. The size of
the right-tree (\(rightsize\)) is the left-over elements minus the
root (i.e. the first non-left entry); create the right-tree from the
last \(rightsize\) elements
</p>

<p>
It recursively partitions the tree into a pivot (the
\(\frac{n}{2}^{nd}\) element or so-called “entry”), the left elements
less than the pivot (belonging to the left subtree) and the right
elements greater than the pivot (belonging to the right subtree); it
works from the left side of the list and the bottom of the tree,
composing leaves and smaller subtrees into larger ones and
eventually consuming the entire list.
</p>

<p>
The order of growth is \(\Theta(n)\), since the list is already
sorted; \(\Theta(n log(n))\) if this were not the case.
</p>
</div>
<div id="outline-container-sec-110-1" class="outline-3">
<h3 id="sec-110-1"><span class="section-number-3">110.1</span> <span class="todo TODO">TODO</span> Some sort of power-law with nodes vs. invocations of partial-tree.</h3>
</div>
</div>
<div id="outline-container-sec-111" class="outline-2">
<h2 id="sec-111"><span class="section-number-2">111</span> <span class="done DONE">DONE</span> 2.65</h2>
<div class="outline-text-2" id="text-111">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(include <span class="org-string">"ordered-sets.scm"</span>)
(include <span class="org-string">"union-set.scm"</span>)
(include <span class="org-string">"tree-sets.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">tree-union-set</span> tree1 tree2)
  (list-&gt;tree (union-set (tree-&gt;list-2 tree1)
                         (tree-&gt;list-2 tree2))))

(<span class="org-keyword">define</span> (<span class="org-function-name">tree-intersection-set</span> tree1 tree2)
  (list-&gt;tree (intersection-set (tree-&gt;list-2 tree1)
                                (tree-&gt;list-2 tree2))))

(<span class="org-keyword">define</span> <span class="org-function-name">tree1</span> (list-&gt;tree '(1 3 6 10)))

(<span class="org-keyword">define</span> <span class="org-function-name">tree2</span> (list-&gt;tree '(0 2 3 7 12)))

(test '(0 1 2 3 6 7 10 12)
      (tree-&gt;list-2 (tree-union-set tree1 tree2)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-112" class="outline-2">
<h2 id="sec-112"><span class="section-number-2">112</span> <span class="done DONE">DONE</span> 2.66</h2>
<div class="outline-text-2" id="text-112">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)
(include <span class="org-string">"tree-sets.scm"</span>)

(<span class="org-keyword">define</span> <span class="org-function-name">tree</span> (list-&gt;tree '(1 3 6 10)))

(<span class="org-keyword">define</span> (<span class="org-function-name">lookup</span> key tree)
  (<span class="org-keyword">if</span> (null? tree)
      #f
      (<span class="org-keyword">let</span> ((entry (entry tree)))
        (<span class="org-keyword">cond</span> ((= key entry) #t)
              ((&lt; key entry) (lookup key (left-branch tree)))
              (<span class="org-keyword">else</span> (lookup key (right-branch tree)))))))

(test-assert (not (lookup 2 tree)))
(test-assert (lookup 1 tree))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-113" class="outline-2">
<h2 id="sec-113"><span class="section-number-2">113</span> <span class="done DONE">DONE</span> 2.67</h2>
<div class="outline-text-2" id="text-113">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(<span class="org-keyword">define</span> <span class="org-function-name">sample-tree</span>
  (make-code-tree (make-leaf 'A 4)
                  (make-code-tree
                   (make-leaf 'B 2)
                   (make-code-tree
                    (make-leaf 'D 1)
                    (make-leaf 'C 1)))))

(<span class="org-keyword">define</span> <span class="org-function-name">sample-message</span> '(0 1 1 0 0 1 0 1 0 1 1 1 0))

(test '(A D A B B C A) (decode sample-message sample-tree))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-114" class="outline-2">
<h2 id="sec-114"><span class="section-number-2">114</span> <span class="done DONE">DONE</span> 2.68</h2>
<div class="outline-text-2" id="text-114">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp srfi-1 test)

(<span class="org-keyword">define</span> (<span class="org-function-name">encode-symbol</span> symbol tree)
  (<span class="org-keyword">if</span> (leaf? tree)
      '()
      (<span class="org-keyword">cond</span> ((memq symbol (symbols (left-branch tree)))
             (cons 0 (encode-symbol symbol (left-branch tree))))
            ((memq symbol (symbols (right-branch tree)))
             (cons 1 (encode-symbol symbol (right-branch tree))))
            (<span class="org-keyword">else</span> (error <span class="org-string">"Symbol not in tree -- ENCODE-SYMBOL"</span> symbol)))))

(<span class="org-keyword">define</span> <span class="org-function-name">sample-tree</span>
  (make-code-tree (make-leaf 'A 4)
                  (make-code-tree
                   (make-leaf 'B 2)
                   (make-code-tree
                    (make-leaf 'D 1)
                    (make-leaf 'C 1)))))

(test '(0 1 1 0 0 1 0 1 0 1 1 1 0)
      (encode '(A D A B B C A) sample-tree))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-115" class="outline-2">
<h2 id="sec-115"><span class="section-number-2">115</span> <span class="done DONE">DONE</span> 2.69</h2>
<div class="outline-text-2" id="text-115">
<p>
Interesting to note that the message from 2.67 is decoded slightly
differently.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp traversal)

(<span class="org-keyword">define</span> (<span class="org-function-name">adjoin-leaf-set</span> tree leaf-set)
  (<span class="org-keyword">if</span> (null? leaf-set)
      (list tree)
      (<span class="org-keyword">let</span> ((leaf (car leaf-set)))
        (<span class="org-keyword">if</span> (&gt; (weight tree) (weight leaf))
            (cons leaf (adjoin-tree tree (cdr leaf-set)))
            (cons tree leaf-set)))))

(<span class="org-keyword">define</span> (<span class="org-function-name">successive-merge</span> leaf-set)
  (<span class="org-keyword">if</span> (= 1 (length leaf-set))
      <span class="org-comment-delimiter">;; </span><span class="org-comment">What if it's a single leaf?</span>
      (<span class="org-keyword">if</span> (leaf? leaf-set)
          leaf-set
          (car leaf-set))
      (successive-merge (adjoin-leaf-set (make-code-tree (cadr leaf-set)
                                                         (car leaf-set))
                                         (cddr leaf-set)))))

(<span class="org-keyword">define</span> (<span class="org-function-name">generate-huffman-tree</span> pairs)
  (successive-merge (make-leaf-set pairs)))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(include <span class="org-string">"huffman.scm"</span>)

(<span class="org-keyword">define</span> <span class="org-function-name">sample-message</span> '(0 1 1 0 0 1 0 1 0 1 1 1 0))

(test
 '(A C A B B D A)
 (decode sample-message
         (generate-huffman-tree '((A 4) (B 2) (C 1) (D 1)))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-116" class="outline-2">
<h2 id="sec-116"><span class="section-number-2">116</span> <span class="done DONE">DONE</span> 2.70</h2>
<div class="outline-text-2" id="text-116">
<p>
84 bits are required for the encoding; if we had used a fixed-length
encoding, \(36\ \text{symbols} \times \log_28\
  \frac{\text{bits}}{\text{symbol}} = 108\ \text{bits}\) would have
been required.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(include <span class="org-string">"huffman.scm"</span>)

(test
 '(1 1 1 1 1 1 1 1 1 0 1 1 0 0 1 1 1
     0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1
     1 1 0 1 1 0 0 1 1 1 0 0 0 0 0 0
     0 0 0 1 1 0 1 0 1 0 1 0 1 0 1 0
     1 0 1 0 1 0 1 0 1 0 1 1 1 0 1 1
     0 1 1)
 (encode
 '(get a job
       sha na na na na na na na na
       get a job
       sha na na na na na na na na
       wah yip yip yip yip yip yip yip yip yip
       sha boom)
 (generate-huffman-tree '((wah 1)
                          (boom 1)
                          (a 2)
                          (get 2)
                          (job 2)
                          (sha 3)
                          (na 16)
                          (yip 9)))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-117" class="outline-2">
<h2 id="sec-117"><span class="section-number-2">117</span> <span class="done DONE">DONE</span> 2.71</h2>
<div class="outline-text-2" id="text-117">
<p>
Here is the tree for \(n = 5\):
</p>


<div class="figure">
<p><img src="2.71.png" alt="2.71.png" />
</p>
</div>

<p>
In general, 1 bit is required to encode the most frequent symbol;
\(n - 1\) bits, the least frequent.
</p>
</div>
</div>
<div id="outline-container-sec-118" class="outline-2">
<h2 id="sec-118"><span class="section-number-2">118</span> <span class="done DONE">DONE</span> 2.72</h2>
<div class="outline-text-2" id="text-118">
<p>
Assuming a linear <code>memq</code>, <code>encode-symbol</code> takes, in the special case
where the relative frequencies of symbols are \(1, 2, \dots,
  2^{n-1}\), \(O(n)\) for the most frequent symbol and \(O(n^2)\) for the
least frequent.
</p>

<p>
For pathological (nearly linear) trees, the order of growth is
\(O(n^2)\); for balanced trees, \(O(n \log n)\).
</p>

<p>
Using a constant-time lookup for symbol membership instead of
<code>memq</code>, the order of growth would be \(O(n)\) and \((\log n)\).
</p>
</div>
</div>
<div id="outline-container-sec-119" class="outline-2">
<h2 id="sec-119"><span class="section-number-2">119</span> <span class="done DONE">DONE</span> 2.73</h2>
<div class="outline-text-2" id="text-119">
<p>
<code>number?</code> and <code>variable?</code> can’t be assimilated because they operate
on primitive (i.e. non-type-tagged objects); on the other hand,
<code>type-tag</code> and <code>contents</code> could be generalized to support them.
</p>

<p>
In order to accomodate a reversal of the indexing for procedures,
we’d have to reverse the corresponding <code>put</code> statements during
installation.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp srfi-69 test)

(<span class="org-keyword">define</span> (<span class="org-function-name">deriv</span> exp var)
  (<span class="org-keyword">cond</span> ((number? exp) 0)
        ((variable? exp) (<span class="org-keyword">if</span> (same-variable? exp var) 1 0))
        (<span class="org-keyword">else</span> ((get 'deriv (operator exp))
               (operands exp) var))))

(<span class="org-keyword">define</span> (<span class="org-function-name">operator</span> exp) (car exp))

(<span class="org-keyword">define</span> (<span class="org-function-name">operands</span> exp) (cdr exp))

(<span class="org-keyword">define</span> <span class="org-function-name">dispatch-table</span> (make-parameter (make-hash-table)))

(<span class="org-keyword">define</span> (<span class="org-function-name">put</span> op type proc)
  (hash-table-set! (dispatch-table) (cons op type) proc))

(<span class="org-keyword">define</span> (<span class="org-function-name">get</span> op type)
  (hash-table-ref/default (dispatch-table) (cons op type) #f))

(<span class="org-keyword">define</span> (<span class="org-function-name">install-sum-and-product-package</span>)
  (<span class="org-keyword">define</span> <span class="org-function-name">addend</span> car)
  (<span class="org-keyword">define</span> <span class="org-function-name">augend</span> cadr)

  (<span class="org-keyword">define</span> (<span class="org-function-name">deriv-sum</span> exp var)
    (make-sum (deriv (addend exp) var)
              (deriv (augend exp) var)))

  (<span class="org-keyword">define</span> <span class="org-function-name">multiplicand</span> car)
  (<span class="org-keyword">define</span> <span class="org-function-name">multiplier</span> cadr)

  (<span class="org-keyword">define</span> (<span class="org-function-name">deriv-product</span> exp var)
    (make-sum
     (make-product (multiplier exp)
                   (deriv (multiplicand exp) var))
     (make-product (deriv (multiplier exp) var)
                   (multiplicand exp))))

  (put 'deriv '+ deriv-sum)
  (put 'deriv '* deriv-product)
  'done)

(install-sum-and-product-package)

(test 'y (deriv '(* x y) 'x))
(test 1 (deriv '(+ x y) 'x))

(<span class="org-keyword">define</span> (<span class="org-function-name">install-exponent-package</span>)
  (<span class="org-keyword">define</span> <span class="org-function-name">base</span> car)
  (<span class="org-keyword">define</span> <span class="org-function-name">exponent</span> cadr)

  (<span class="org-keyword">define</span> (<span class="org-function-name">make-exponentiation</span> b e)
    (<span class="org-keyword">cond</span> ((=number? e 0) 1)
          ((=number? e 1) b)
          ((<span class="org-keyword">and</span> (number? b) (number? e))
           (expt b e))
          (<span class="org-keyword">else</span> (list '** b e))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">make-diff</span> a1 a2)
    (<span class="org-keyword">cond</span> ((=number? a1 0) a2)
          ((=number? a2 0) a1)
          ((<span class="org-keyword">and</span> (number? a1) (number? a2))
           (- a1 a2))
          (<span class="org-keyword">else</span> (list '- a1 a2))))

  (<span class="org-keyword">define</span> (<span class="org-function-name">deriv-exponent</span> exp var)
    (<span class="org-keyword">let</span> ((base (base exp))
          (exponent (exponent exp)))
      (make-product exponent
                    (make-product
                     (make-exponentiation base (make-diff exponent 1))
                     (deriv base var)))))

  (put 'deriv '** deriv-exponent)
  'done)

(install-exponent-package)

(test '(* y (** x (- y 1))) (deriv '(** x y) 'x))
(test '(* 2 x) (deriv '(** x 2) 'x))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-120" class="outline-2">
<h2 id="sec-120"><span class="section-number-2">120</span> <span class="done DONE">DONE</span> 2.74</h2>
<div class="outline-text-2" id="text-120">
<p>
Some sort of type information supplied as e.g. a file-extension or
header should be provided to describe the file being read; this type
is passed to functions for reading and parsing records so that
<code>get-record</code> can be generically defined. (See, for instance,
<a href="./division-a-1.data">./division-a-1.data</a> and <a href="./division-b-1.data">./division-b-1.data</a>.)
</p>

<p>
The record itself should have a tag so that <code>get-salary</code> can be
generically defined.
</p>

<p>
When Insatiable takes over a new company, record- and field-parsers
corresponding to their file-format will have to be installed in the
dispatch table.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use alist-lib debug extras medea sicp srfi-61 test)

(<span class="org-keyword">define</span> (<span class="org-function-name">install-division-a-package</span>)
  (<span class="org-keyword">define</span> <span class="org-function-name">get-person</span> (cut alist-ref &lt;&gt; 'person))
  (<span class="org-keyword">define</span> <span class="org-function-name">get-salary</span> (cut alist-ref &lt;&gt; 'salary))
  (<span class="org-keyword">define</span> (<span class="org-function-name">read-record</span> file)
    (attach-tag 'division-a-record (read file)))
  (put 'get-person '(division-a-record) get-person)
  (put 'get-salary '(division-a-record) get-salary)
  (put 'read-record '(division-a-file) read-record)
  (put 'eof? '(division-a-record) eof-object?)
  (put 'close '(division-a-file) close-input-port))

(<span class="org-keyword">define</span> (<span class="org-function-name">install-division-b-package</span>)
  (<span class="org-keyword">define</span> (<span class="org-function-name">get-person</span> record)
    (string-&gt;symbol (alist-ref record 'name)))
  (<span class="org-keyword">define</span> <span class="org-function-name">get-salary</span> (cute alist-ref &lt;&gt; 'income))
  (<span class="org-keyword">define</span> (<span class="org-function-name">read-record</span> file)
    (attach-tag 'division-b-record
                (<span class="org-keyword">let</span> ((object (read-line file)))
                  (<span class="org-keyword">if</span> (eof-object? object)
                      object
                      (read-json object)))))
  (put 'get-person '(division-b-record) get-person)
  (put 'get-salary '(division-b-record) get-salary)
  (put 'read-record '(division-b-file) read-record)
  (put 'eof? '(division-b-record) eof-object?)
  (put 'close '(division-b-file) close-input-port))

(<span class="org-keyword">define</span> (<span class="org-function-name">file-tag</span> file)
  (string-&gt;symbol (read-line file)))

(<span class="org-keyword">define</span> (<span class="org-function-name">make-file</span> file)
  (<span class="org-keyword">let</span> ((file (open-input-file file)))
    (attach-tag (file-tag file) file)))

(<span class="org-keyword">define</span> (<span class="org-function-name">read-record</span> file)
  (apply-generic 'read-record file))

(<span class="org-keyword">define</span> (<span class="org-function-name">get-person</span> record)
  (apply-generic 'get-person record))

(<span class="org-keyword">define</span> (<span class="org-function-name">eof?</span> record)
  (apply-generic 'eof? record))

(<span class="org-keyword">define</span> (<span class="org-function-name">close</span> file)
  (apply-generic 'close file))

(<span class="org-keyword">define</span> (<span class="org-function-name">get-record</span> person file)
  (dynamic-wind
      void
      (<span class="org-keyword">lambda</span> () (<span class="org-keyword">let</span> <span class="org-function-name">iter</span> ((record (read-record file)))
              (<span class="org-keyword">if</span> (eof? record)
                  #f
                  (<span class="org-keyword">if</span> (eq? person (get-person record))
                      record
                      (iter (read-record file))))))
      (<span class="org-keyword">lambda</span> () (close file))))

(<span class="org-keyword">define</span> (<span class="org-function-name">make-person</span> name)
  (attach-tag 'person name))

(<span class="org-keyword">define</span> (<span class="org-function-name">get-salary</span> record)
  (apply-generic 'get-salary record))

(<span class="org-keyword">define</span> (<span class="org-function-name">get-salary</span> record)
  (apply-generic 'get-salary record))

(<span class="org-keyword">define</span> (<span class="org-function-name">find-employee-record</span> person files)
  (append-map (<span class="org-keyword">lambda</span> (file)
                (<span class="org-keyword">let</span> ((record (get-record person (make-file file))))
                  (<span class="org-keyword">if</span> record
                      (list record)
                      '())))
              files))

(install-division-a-package)
(install-division-b-package)

(<span class="org-keyword">let</span> ((jake (get-record 'jake (make-file <span class="org-string">"division-a-1.data"</span>)))
      (mary (get-record 'mary (make-file <span class="org-string">"division-b-1.data"</span>))))
  (test <span class="org-string">"(get-record 'jake (make-file \"division-a-1.data\"))"</span>
        jake
        '(division-a-record (person . jake) (salary . 110000)))
  (test <span class="org-string">"(get-record 'mary (make-file \"division-b-1.data\"))"</span>
        mary
        '(division-b-record (name . <span class="org-string">"mary"</span>) (income . 110000)))
  (test 110000 (get-salary jake))
  (test 110000 (get-salary mary)))

(test '((division-b-record (name . <span class="org-string">"barbara"</span>) (income . 60000)))
      (find-employee-record 'barbara '(<span class="org-string">"division-b-1.data"</span>
                                       <span class="org-string">"division-b-2.data"</span>)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-121" class="outline-2">
<h2 id="sec-121"><span class="section-number-2">121</span> <span class="done DONE">DONE</span> 2.75</h2>
<div class="outline-text-2" id="text-121">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">make-from-mag-ang</span> r a)
  (<span class="org-keyword">lambda</span> (op)
    (<span class="org-keyword">cond</span> ((eq? op 'real-part) (* r (cos a)))
          ((eq? op 'imag-part) (* r (sin a)))
          ((eq? op 'magnitude) r)
          ((eq? op 'angle) a)
          (<span class="org-keyword">else</span> (error <span class="org-string">"Unknown op: MAKE-FROM-MAG-ANG"</span> op)))))

(<span class="org-keyword">let</span> ((magnitude (sqrt 2))
      (angle (atan 1)))
  (<span class="org-keyword">let</span> ((number (make-from-mag-ang magnitude angle)))
    (test 1.0 (number 'real-part))
    (test 1.0 (number 'imag-part))
    (test magnitude (number 'magnitude))
    (test angle (number 'angle))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-122" class="outline-2">
<h2 id="sec-122"><span class="section-number-2">122</span> <span class="done DONE">DONE</span> 2.76</h2>
<div class="outline-text-2" id="text-122">
<p>
Explicit dispatch isn’t appropriate for large systems in which
either new types or new operations must be added, since explicit
dispatch doesn’t exhibit additivity: the generic dispatch procedure
must be modified every time there is a new type or operation.
</p>

<p>
If new types are often added (and one doesn’t mind having a sparse
operation-and-type table), message passing is superior: adding a
type is merely the addition of a column; and if new procedures are
often added, data-directed is superior: adding an operation is
merely the addition of a row.
</p>
</div>
</div>
<div id="outline-container-sec-123" class="outline-2">
<h2 id="sec-123"><span class="section-number-2">123</span> <span class="done DONE">DONE</span> 2.77</h2>
<div class="outline-text-2" id="text-123">
<p>
<code>Apply-generic</code> is invoked twice.
</p>

<p>
First, the top-level procedure <code>magnitude</code> is applied to <code>z</code> which,
after substitution, looks like:
</p>

<div class="org-src-container">

<pre class="src src-scheme">(magnitude (complex rectangular 3 4))
</pre>
</div>

<p>
which in turn calls <code>apply-generic</code>:
</p>

<div class="org-src-container">

<pre class="src src-scheme">(apply-generic 'magnitude (complex rectangular 3 4))
</pre>
</div>

<p>
<code>Apply-generic</code> applies <code>magnitude</code> from the complex package with
the contents of <code>z</code>, stripping off the <code>complex</code> tag; <code>magnitude</code>
from the complex package defers, however, to top-level <code>magnitude</code>:
</p>

<div class="org-src-container">

<pre class="src src-scheme">(magnitude (rectangular 3 4))
</pre>
</div>

<p>
which invokes <code>apply-generic</code> a second time:
</p>

<div class="org-src-container">

<pre class="src src-scheme">(apply-generic 'magnitude (rectangular 3 4))
</pre>
</div>

<p>
<code>Apply-generic</code> then applies <code>magnitude</code> from the rectangular
package:
</p>

<div class="org-src-container">

<pre class="src src-scheme">(sqrt (+ (square (real-part (rectangular 3 4))
                 (imag-part (rectangular 3 4)))))
</pre>
</div>

<p>
which becomes:
</p>

<div class="org-src-container">

<pre class="src src-scheme">(sqrt (+ (square 3) (square 4)))
</pre>
</div>

<p>
and finally:
</p>

<div class="org-src-container">

<pre class="src src-scheme">5.0
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(<span class="org-keyword">define</span> (<span class="org-function-name">install-complex-selectors-package</span>)
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)
  'done)

(install-scheme-number-package)
(install-rational-package)
(install-complex-package)
(install-complex-selectors-package)

(<span class="org-keyword">let</span> ((z (make-complex-from-mag-ang 3 4)))
  (test 3 (magnitude z)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-124" class="outline-2">
<h2 id="sec-124"><span class="section-number-2">124</span> <span class="done DONE">DONE</span> 2.78</h2>
<div class="outline-text-2" id="text-124">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp)

(<span class="org-keyword">define</span> (<span class="org-function-name">attach-tag</span> type-tag contents)
  (<span class="org-keyword">if</span> (eq? type-tag 'scheme-number)
      contents
      (cons type-tag contents)))

(<span class="org-keyword">define</span> (<span class="org-function-name">type-tag</span> datum)
  (<span class="org-keyword">cond</span> ((number? datum) 'scheme-number)
        ((pair? datum) (car datum))
        (<span class="org-keyword">else</span> (error <span class="org-string">"Bad tagged datum: TYPE-TAG"</span> datum))))

(<span class="org-keyword">define</span> (<span class="org-function-name">contents</span> datum)
  (<span class="org-keyword">cond</span> ((number? datum) datum)
        ((pair? datum) (cdr datum))
        (<span class="org-keyword">else</span> (error <span class="org-string">"Bad tagged datum: CONTENTS"</span> datum))))

(<span class="org-keyword">let</span> ((n (make-scheme-number 1)))
  (test 1 n)
  (test 2 (add n n)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-125" class="outline-2">
<h2 id="sec-125"><span class="section-number-2">125</span> <span class="done DONE">DONE</span> 2.79</h2>
<div class="outline-text-2" id="text-125">
<p>
This took a little more code than I would have liked; opted for an
orthogonal package that tests equality across all permutations of
scheme-number, rational, complex.
</p>

<p>
This is not an additive strategy: the equality package has to be
modified every time we add a type; the alternative of embedding the
equality procedures in the scheme-number, rational, complex packages
would have violated module-boundaries.
</p>

<p>
It also involves writing ad-hoc promotion and demotion procedures up
and down the number ladder.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp)

(<span class="org-keyword">define</span> (<span class="org-function-name">scheme-number-&gt;rational</span> scheme-number)
  (<span class="org-keyword">let</span> ((number (contents scheme-number)))
    (make-rational (numerator number)
                   (denominator number))))

(<span class="org-keyword">define</span> (<span class="org-function-name">rational-&gt;complex</span> rational)
  (make-complex-from-real-imag
   (/ (numer rational) (denom rational))
   0))

(<span class="org-keyword">define</span> (<span class="org-function-name">tag-scheme-number</span> scheme-number)
  (attach-tag 'scheme-number scheme-number))

(<span class="org-keyword">define</span> (<span class="org-function-name">tag-rational</span> rational)
  (attach-tag 'rational rational))

(<span class="org-keyword">define</span> (<span class="org-function-name">tag-complex</span> complex)
  (attach-tag 'complex complex))

<span class="org-comment-delimiter">;; </span><span class="org-comment">Let's modify the rational package so that it exports numer and</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">denom.</span>
(<span class="org-keyword">define</span> (<span class="org-function-name">install-rational-package</span>)
  <span class="org-comment-delimiter">;; </span><span class="org-comment">internal procedures</span>
  (<span class="org-keyword">define</span> (<span class="org-function-name">numer</span> x) (car x))
  (<span class="org-keyword">define</span> (<span class="org-function-name">denom</span> x) (cdr x))
  (<span class="org-keyword">define</span> (<span class="org-function-name">make-rat</span> n d)
    (<span class="org-keyword">let</span> ((g (gcd n d)))
      (cons (/ n g) (/ d g))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">add-rat</span> x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">sub-rat</span> x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">mul-rat</span> x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">div-rat</span> x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))
  <span class="org-comment-delimiter">;; </span><span class="org-comment">interface to rest of the system</span>
  (<span class="org-keyword">define</span> <span class="org-function-name">tag</span> tag-rational)
  (put 'add '(rational rational)
       (<span class="org-keyword">lambda</span> (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (<span class="org-keyword">lambda</span> (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (<span class="org-keyword">lambda</span> (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (<span class="org-keyword">lambda</span> (x y) (tag (div-rat x y))))
  (put 'make 'rational
       (<span class="org-keyword">lambda</span> (n d) (tag (make-rat n d))))
  (put 'numer '(rational) numer)
  (put 'denom '(rational) denom)
  'done)

(<span class="org-keyword">define</span> (<span class="org-function-name">numer</span> rational)
  (apply-generic 'numer rational))

(<span class="org-keyword">define</span> (<span class="org-function-name">denom</span> rational)
  (apply-generic 'denom rational))

(<span class="org-keyword">define</span> (<span class="org-function-name">scheme-number-rational-equ?</span> scheme-number rational)
  (<span class="org-keyword">let</span> ((scheme-number-rational (scheme-number-&gt;rational scheme-number)))
    (<span class="org-keyword">and</span> (= (numer scheme-number-rational) (numer rational))
         (= (denom scheme-number-rational) (denom rational)))))

(<span class="org-keyword">define</span> (<span class="org-function-name">rational-complex-equ?</span> rational complex)
  (<span class="org-keyword">let</span> ((rational-complex (rational-&gt;complex rational)))
    (<span class="org-keyword">and</span> (= (magnitude rational-complex) (magnitude complex))
         (= (angle rational-complex) (angle complex)))))

(<span class="org-keyword">define</span> (<span class="org-function-name">install-equality-package</span>)
  (install-scheme-number-package)
  (install-rational-package)
  (install-complex-package)
  (put 'equ? '(scheme-number scheme-number)
       (<span class="org-keyword">lambda</span> (x y) (= x y)))
  (put 'equ? '(scheme-number rational)
       (<span class="org-keyword">lambda</span> (x y)
         (<span class="org-keyword">let</span> ((scheme-number (tag-scheme-number x))
               (rational (tag-rational y)))
           (scheme-number-rational-equ? scheme-number rational))))
  (put 'equ? '(scheme-number complex)
       (<span class="org-keyword">lambda</span> (x y)
         (<span class="org-keyword">let</span> ((scheme-number (tag-scheme-number x))
               (complex (tag-complex y)))
           (rational-complex-equ?
            (scheme-number-&gt;rational scheme-number)
            complex))))

  (put 'equ? '(rational scheme-number)
       (<span class="org-keyword">lambda</span> (x y)
         (<span class="org-keyword">let</span> ((rational (tag-rational x))
               (scheme-number (tag-rational y)))
           (scheme-number-rational-equ? scheme-number rational))))
  (put 'equ? '(rational rational)
       (<span class="org-keyword">lambda</span> (x y)
         (<span class="org-keyword">let</span> ((rational-x (tag-rational x))
               (rational-y (tag-rational y)))
           (<span class="org-keyword">and</span> (= (numer rational-x)
                   (numer rational-y))
                (= (denom rational-x)
                   (denom rational-y))))))
  (put 'equ? '(rational complex)
       (<span class="org-keyword">lambda</span> (x y)
         (<span class="org-keyword">let</span> ((rational (attach-tag 'rational x))
               (complex (attach-tag 'complex y)))
           (rational-complex-equ? rational complex))))

  (put 'equ? '(complex scheme-number)
       (<span class="org-keyword">lambda</span> (x y)
         (<span class="org-keyword">let</span> ((complex (tag-complex x))
               (scheme-number (tag-complex y)))
           (rational-complex-equ?
            (scheme-number-&gt;rational scheme-number)
            complex))))
  (put 'equ? '(complex rational)
       (<span class="org-keyword">lambda</span> (x y)
         (<span class="org-keyword">let</span> ((complex (tag-complex x))
               (rational (tag-rational y)))
           (rational-complex-equ? rational complex))))
  (put 'equ? '(complex complex)
       (<span class="org-keyword">lambda</span> (x y)
         (<span class="org-keyword">let</span> ((complex-x (tag-complex x))
               (complex-y (tag-complex y)))
           (<span class="org-keyword">and</span> (= (magnitude complex-x)
                   (magnitude complex-y))
                (= (angle complex-y)
                   (angle complex-y)))))))

(<span class="org-keyword">define</span> (<span class="org-function-name">equ?</span> x y)
  (apply-generic 'equ? x y))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(include <span class="org-string">"number-equality.scm"</span>)

(install-equality-package)

(<span class="org-keyword">let</span> ((scheme-number (make-scheme-number 0.5))
      (rational (make-rational 2 4))
      (complex (make-complex-from-real-imag 0.5 0)))
  (test-assert (equ? scheme-number scheme-number))
  (test-assert (equ? scheme-number rational))
  (test-assert (equ? scheme-number complex))

  (test-assert (equ? rational scheme-number))
  (test-assert (equ? rational rational))
  (test-assert (equ? rational complex))

  (test-assert (equ? complex scheme-number))
  (test-assert (equ? complex rational))
  (test-assert (equ? complex complex)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-126" class="outline-2">
<h2 id="sec-126"><span class="section-number-2">126</span> <span class="done DONE">DONE</span> 2.80</h2>
<div class="outline-text-2" id="text-126">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(include <span class="org-string">"number-equality.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">install-zero-package</span>)
  (install-equality-package)
  (<span class="org-keyword">define</span> <span class="org-function-name">zero</span> (make-scheme-number 0))
  (put '=zero? '(scheme-number)
       (<span class="org-keyword">lambda</span> (x)
         (equ? (tag-scheme-number x) zero)))
  (put '=zero? '(rational)
       (<span class="org-keyword">lambda</span> (x)
         (equ? (tag-rational x) zero)))
  (put '=zero? '(complex)
       (<span class="org-keyword">lambda</span> (x)
         (equ? (tag-complex x) zero))))

(<span class="org-keyword">define</span> (<span class="org-function-name">=zero?</span> x)
  (apply-generic '=zero? x))

(install-zero-package)

(<span class="org-keyword">let</span> ((scheme-number (make-scheme-number 0))
      (rational (make-rational 0 1))
      (complex (make-complex-from-real-imag 0 0)))
  (test-assert (=zero? scheme-number))
  (test-assert (=zero? rational))
  (test-assert (=zero? complex)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-127" class="outline-2">
<h2 id="sec-127"><span class="section-number-2">127</span> <span class="done DONE">DONE</span> 2.81</h2>
<div class="outline-text-2" id="text-127">
<p>
With a <code>complex-&gt;complex</code> coercion in place, there will be an
infinite loop as it repeatedly coerces complex to itself and retries
the generic operation.
</p>

<p>
<code>apply-generic</code> works correctly as is, even if self-coercion wastes
some time.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use debug sicp srfi-69 test)

(install-scheme-number-package)
(install-rational-package)
(install-complex-package)

(<span class="org-keyword">define</span> <span class="org-function-name">coercion-table</span> (make-parameter (make-hash-table)))

(<span class="org-keyword">define</span> (<span class="org-function-name">put-coercion</span> op type proc)
  (hash-table-set! (coercion-table) (cons op type) proc))

(<span class="org-keyword">define</span> (<span class="org-function-name">get-coercion</span> op type)
  (hash-table-ref/default (coercion-table) (cons op type) #f))

(<span class="org-keyword">define</span> (<span class="org-function-name">apply-generic</span> op . args)
  (<span class="org-keyword">let</span> ((type-tags (<span class="org-keyword">map</span> type-tag args)))
    (<span class="org-keyword">let</span> ((proc (get op type-tags)))
      (<span class="org-keyword">if</span> proc
          (apply proc (<span class="org-keyword">map</span> contents args))
          (<span class="org-keyword">if</span> (= (length args) 2)
              (<span class="org-keyword">let</span> ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                <span class="org-comment-delimiter">;; </span><span class="org-comment">Don't bother coercing to self.</span>
                (<span class="org-keyword">if</span> (eq? type1 type2)
                    (error <span class="org-string">"No method for these types"</span>
                           (list op type-tags))
                    (<span class="org-keyword">let</span> ((t1-&gt;t2 (get-coercion type1 type2))
                          (t2-&gt;t1 (get-coercion type2 type1)))
                      (<span class="org-keyword">cond</span> (t1-&gt;t2
                             (apply-generic op (t1-&gt;t2 a1) a2))
                            (t2-&gt;t1
                             (apply-generic op a1 (t2-&gt;t1 a2)))
                            (<span class="org-keyword">else</span> (error <span class="org-string">"No method for these types"</span>
                                         (list op type-tags)))))))
              (error <span class="org-string">"No method for these types"</span>
                     (list op type-tags)))))))

(<span class="org-keyword">define</span> (<span class="org-function-name">scheme-number-&gt;complex</span> n)
  (make-complex-from-real-imag (contents n) 0))

(put-coercion 'scheme-number
              'complex
              scheme-number-&gt;complex)

(<span class="org-keyword">define</span> (<span class="org-function-name">scheme-number-&gt;scheme-number</span> n) n)

(<span class="org-keyword">define</span> (<span class="org-function-name">complex-&gt;complex</span> z) z)

(put-coercion 'scheme-number
              'scheme-number
              scheme-number-&gt;scheme-number)

(put-coercion 'complex
              'complex
              complex-&gt;complex)

(<span class="org-keyword">define</span> (<span class="org-function-name">exp</span> x y)
  (apply-generic 'exp x y))

(put 'exp '(scheme-number scheme-number)
     (<span class="org-keyword">lambda</span> (x y)
       (attach-tag 'scheme-number (expt x y))))

(<span class="org-keyword">let</span> ((complex (make-complex-from-real-imag 2 0))
      (scheme-number (make-scheme-number 2)))
  (test '(scheme-number . 4) (exp scheme-number scheme-number))
  (test-error (exp complex complex))
  (test-error (exp scheme-number complex)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-128" class="outline-2">
<h2 id="sec-128"><span class="section-number-2">128</span> <span class="done DONE">DONE</span> 2.82</h2>
<div class="outline-text-2" id="text-128">
<p>
If we had a vector arithmetic package, for instance, and wanted to
scale a vector by a scheme-number (but had only defined scale for
rationals and vectors); this generalized coercion would not work.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use debug sicp srfi-69 test)

(install-scheme-number-package)
(install-rational-package)
(install-complex-package)

(<span class="org-keyword">define</span> <span class="org-function-name">coercion-table</span> (make-parameter (make-hash-table)))

(<span class="org-keyword">define</span> (<span class="org-function-name">put-coercion</span> op type proc)
  (hash-table-set! (coercion-table) (cons op type) proc))

(<span class="org-keyword">define</span> (<span class="org-function-name">get-coercion</span> op type)
  (hash-table-ref/default (coercion-table) (cons op type) #f))

(<span class="org-keyword">define</span> (<span class="org-function-name">apply-generic</span> op . args)
  (<span class="org-keyword">let</span> ((type-tags (<span class="org-keyword">map</span> type-tag args)))
    (<span class="org-keyword">let</span> ((proc (get op type-tags)))
      (<span class="org-keyword">if</span> proc
          (apply proc (<span class="org-keyword">map</span> contents args))
          (<span class="org-keyword">let</span> <span class="org-function-name">iter</span> ((candidate-types type-tags))
            (<span class="org-keyword">if</span> (null? candidate-types)
                (error <span class="org-string">"No method for these types"</span>
                       (list op type-tags))
                (<span class="org-keyword">let*</span> ((candidate-type (car candidate-types))
                       (coercions (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (type)
                                         <span class="org-comment-delimiter">;; </span><span class="org-comment">Need to distinguish</span>
                                         <span class="org-comment-delimiter">;; </span><span class="org-comment">between no coercion and</span>
                                         <span class="org-comment-delimiter">;; </span><span class="org-comment">self-coercion.</span>
                                         (<span class="org-keyword">if</span> (eq? type candidate-type)
                                             identity
                                             (get-coercion type candidate-type)))
                                       type-tags)))
                  <span class="org-comment-delimiter">;; </span><span class="org-comment">We should have a coercion for every type,</span>
                  <span class="org-comment-delimiter">;; </span><span class="org-comment">excluding self-coercions.</span>
                  (<span class="org-keyword">if</span> (<span class="org-keyword">and</span> (every identity coercions)
                           (pair? (delete identity coercions)))
                      (<span class="org-keyword">let</span> ((args (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (coercion arg) (coercion arg))
                                       coercions args)))
                        (apply apply-generic (cons op args)))
                      (iter (cdr candidate-types))))))))))

(<span class="org-keyword">define</span> (<span class="org-function-name">scheme-number-&gt;complex</span> n)
  (make-complex-from-real-imag (contents n) 0))

(put-coercion 'scheme-number
              'complex
              scheme-number-&gt;complex)

(<span class="org-keyword">define</span> (<span class="org-function-name">exp</span> x y)
  (apply-generic 'exp x y))

(put 'exp '(scheme-number scheme-number)
     (<span class="org-keyword">lambda</span> (x y)
       (attach-tag 'scheme-number (expt x y))))

(<span class="org-keyword">let</span> ((complex (make-complex-from-real-imag 2 0))
      (scheme-number (make-scheme-number 2)))
  (test '(complex rectangular 4 . 0) (add scheme-number complex))
  (test-error (exp scheme-number complex)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-129" class="outline-2">
<h2 id="sec-129"><span class="section-number-2">129</span> <span class="done DONE">DONE</span> 2.83</h2>
<div class="outline-text-2" id="text-129">
<div class="org-src-container">

<pre class="src src-scheme"><span class="org-comment-delimiter">;;; </span><span class="org-comment">Packages</span>

(<span class="org-keyword">define</span> (<span class="org-function-name">install-scheme-number-conversion-package</span>)
  (<span class="org-keyword">define</span> (<span class="org-function-name">-&gt;rational</span> number)
    (make-rational (numerator number)
                   (denominator number)))
  (<span class="org-keyword">define</span> (<span class="org-function-name">-&gt;complex</span> number)
    (make-complex-from-real-imag number 0))
  (put '-&gt;rational '(scheme-number) -&gt;rational)
  (put '-&gt;complex '(scheme-number) -&gt;complex))

(<span class="org-keyword">define</span> (<span class="org-function-name">install-rational-conversion-package</span>)
  (<span class="org-keyword">define</span> <span class="org-function-name">numer</span> car)
  (<span class="org-keyword">define</span> <span class="org-function-name">denom</span> cdr)
  (<span class="org-keyword">define</span> (<span class="org-function-name">-&gt;real</span> rational)
    (make-real (/ (numer rational)
                  (denom rational))))
  (put 'raise '(rational) -&gt;real))

(<span class="org-keyword">define</span> (<span class="org-function-name">install-complex-conversion-package</span>)
  (put 'raise '(complex) (constantly #f)))

(<span class="org-keyword">define</span> (<span class="org-function-name">install-integer-package</span>)
  (<span class="org-keyword">define</span> (<span class="org-function-name">tag</span> object)
    (attach-tag 'integer object))
  (<span class="org-keyword">define</span> (<span class="org-function-name">make</span> value)
    (tag (make-scheme-number value)))
  (put 'raise '(integer) -&gt;rational)
  (put 'make 'integer make))

(<span class="org-keyword">define</span> (<span class="org-function-name">install-real-package</span>)
  (<span class="org-keyword">define</span> (<span class="org-function-name">tag</span> object)
    (attach-tag 'real object))
  (<span class="org-keyword">define</span> (<span class="org-function-name">make</span> value)
    (tag (make-scheme-number value)))
  (put 'raise '(real) -&gt;complex)
  (put 'make 'real make))

<span class="org-comment-delimiter">;;; </span><span class="org-comment">Constructors</span>

(<span class="org-keyword">define</span> (<span class="org-function-name">make-integer</span> i)
  ((get 'make 'integer) i))

(<span class="org-keyword">define</span> (<span class="org-function-name">make-real</span> x)
  ((get 'make 'real) x))

<span class="org-comment-delimiter">;;; </span><span class="org-comment">Converters</span>

(<span class="org-keyword">define</span> (<span class="org-function-name">-&gt;rational</span> number)
  (apply-generic '-&gt;rational number))

(<span class="org-keyword">define</span> (<span class="org-function-name">-&gt;complex</span> number)
  (apply-generic '-&gt;complex number))

<span class="org-comment-delimiter">;;; </span><span class="org-comment">Generic raise</span>

(<span class="org-keyword">define</span> (<span class="org-function-name">raise</span> number)
  (apply-generic 'raise number))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use data-structures sicp test)

(include <span class="org-string">"raise.scm"</span>)

(install-scheme-number-package)
(install-scheme-number-conversion-package)
(install-rational-package)
(install-rational-conversion-package)
(install-complex-package)
(install-complex-conversion-package)

(install-integer-package)
(install-real-package)

(<span class="org-keyword">let</span> ((integer (make-integer 1))
      (rational (make-rational 1 1))
      (real (make-real 1))
      (complex (make-complex-from-real-imag 1 0)))
  <span class="org-comment-delimiter">;; </span><span class="org-comment">These tests rely on the fact that we're dealing with lists as a</span>
  <span class="org-comment-delimiter">;; </span><span class="org-comment">convential interface.</span>
  (test rational (raise integer))
  (test real (raise rational))
  (test complex (raise real))
  (test-assert (not (raise complex))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-130" class="outline-2">
<h2 id="sec-130"><span class="section-number-2">130</span> <span class="done DONE">DONE</span> 2.84</h2>
<div class="outline-text-2" id="text-130">
<p>
For simplicity, we’re only handling the monadic and dyadic case; we
should really abstract this to n-ary.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> <span class="org-function-name">supertype-table</span> (make-parameter (make-hash-table)))

(<span class="org-keyword">define</span> (<span class="org-function-name">put-supertype</span> subtype supertype)
  (hash-table-set! (supertype-table) subtype supertype))

(<span class="org-keyword">define</span> (<span class="org-function-name">get-supertype</span> subtype)
  (hash-table-ref/default (supertype-table) subtype #f))

(put-supertype 'integer 'rational)
(put-supertype 'rational 'real)
(put-supertype 'real 'complex)

(<span class="org-keyword">define</span> (<span class="org-function-name">supertype?</span> subtype type)
  (<span class="org-keyword">let</span> <span class="org-function-name">iter</span> ((supertype (get-supertype subtype)))
    (<span class="org-keyword">and</span> supertype
         (<span class="org-keyword">or</span> (eq? supertype type)
             (iter (get-supertype supertype))))))

(<span class="org-keyword">define</span> (<span class="org-function-name">raise-until-equitable</span> arg type)
  (<span class="org-keyword">if</span> (eq? (type-tag arg) type)
      arg
      (raise-until-equitable (raise arg) type)))

(<span class="org-keyword">define</span> (<span class="org-function-name">apply-generic</span> op . args)
  (<span class="org-keyword">let</span> ((type-tags (<span class="org-keyword">map</span> type-tag args)))
    (<span class="org-keyword">let</span> ((proc (get op type-tags)))
      (<span class="org-keyword">if</span> proc
          (apply proc (<span class="org-keyword">map</span> contents args))
          (<span class="org-keyword">cond</span> ((= (length args) 1)
                 (<span class="org-keyword">let</span> ((superarg (raise (car args))))
                   (<span class="org-keyword">if</span> superarg
                       (apply-generic op superarg)
                       (error <span class="org-string">"No method for these types"</span>
                              (list op type-tags)))))
                ((= (length args) 2)
                 (<span class="org-keyword">let</span> ((type1 (car type-tags))
                       (type2 (cadr type-tags))
                       (a1 (car args))
                       (a2 (cadr args)))
                   (<span class="org-keyword">cond</span> ((supertype? type1 type2)
                          (apply-generic op
                                         (raise-until-equitable a1 type2)
                                         a2))
                         ((supertype? type2 type1)
                          (apply-generic op a1 (raise-until-equitable a2
                                                                      type1)))
                         (<span class="org-keyword">else</span> (error <span class="org-string">"No method for these types"</span>
                                      (list op type-tags))))))
                (<span class="org-keyword">else</span> (error <span class="org-string">"No method for these types"</span> (list op type-tags))))))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use data-structures sicp srfi-69 test)

(include <span class="org-string">"raise.scm"</span>)
(include <span class="org-string">"apply-generic-raise.scm"</span>)

(install-scheme-number-package)
(install-scheme-number-conversion-package)
(install-rational-package)
(install-rational-conversion-package)
(install-complex-package)
(install-complex-conversion-package)

(install-integer-package)
(install-real-package)

(<span class="org-keyword">let</span> ((rational (make-rational 1 1))
      (complex (make-complex-from-real-imag 1 0)))
  (test '(complex rectangular 2 . 0) (add rational complex))
  (test 0 (imag-part rational)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-131" class="outline-2">
<h2 id="sec-131"><span class="section-number-2">131</span> <span class="done DONE">DONE</span> 2.85</h2>
<div class="outline-text-2" id="text-131">
<p>
We were able to simplify results from apply-generic, but had to
configure a switch to disable dropping on raise.
</p>

<p>
We might have detected that the operation was raise in
<code>apply-generic</code>, but that doesn’t seem additive; let’s add a <code>drop?</code>
parameter.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use data-structures debug sicp test)

(include <span class="org-string">"raise.scm"</span>)
(include <span class="org-string">"apply-generic-raise.scm"</span>)

<span class="org-comment-delimiter">;;; </span><span class="org-comment">Packages</span>

(<span class="org-keyword">define</span> (<span class="org-function-name">install-scheme-number-projection-package</span>)
  (<span class="org-keyword">define</span> (<span class="org-function-name">-&gt;rational</span> number)
    (make-rational (numerator number)
                   (denominator number)))
  (<span class="org-keyword">define</span> (<span class="org-function-name">equ?</span> x y) (= x y))
  (put '-&gt;rational '(real) -&gt;rational)
  (put 'equ? '(scheme-number scheme-number) equ?))

(<span class="org-keyword">define</span> (<span class="org-function-name">install-rational-projection-package</span>)
  (<span class="org-keyword">define</span> <span class="org-function-name">numer</span> car)
  (<span class="org-keyword">define</span> <span class="org-function-name">denom</span> cdr)
  (<span class="org-keyword">define</span> (<span class="org-function-name">-&gt;integer</span> rational)
    (make-integer (/ (numer rational)
                     (denom rational))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">equ?</span> n1 n2)
    (<span class="org-keyword">and</span> (= (numer n1) (numer n2))
         (= (denom n1) (denom n2))))
  (put 'project '(rational) -&gt;integer)
  (put 'equ? '(rational rational) equ?))

(<span class="org-keyword">define</span> (<span class="org-function-name">install-complex-projection-package</span>)
  (<span class="org-keyword">define</span> (<span class="org-function-name">-&gt;real</span> complex)
    (make-real (real-part complex)))
  <span class="org-comment-delimiter">;; </span><span class="org-comment">Not precise because of errors in conversion?</span>
  (<span class="org-keyword">define</span> (<span class="org-function-name">equ?</span> c1 c2)
    (<span class="org-keyword">and</span> (= (real-part c1) (real-part c2))
         (= (imag-part c1) (imag-part c2))))
  (put 'project '(complex) -&gt;real)
  (put 'equ? '(complex complex) equ?))

(<span class="org-keyword">define</span> (<span class="org-function-name">install-integer-projection-package</span>)
  (put 'project '(integer) (constantly #f))
  (put 'equ? '(integer integer) equ?))

(<span class="org-keyword">define</span> (<span class="org-function-name">install-real-projection-package</span>)
  (put 'project '(real) -&gt;rational)
  (put 'equ? '(real real) equ?))

<span class="org-comment-delimiter">;;; </span><span class="org-comment">Generic project, equ?; drop</span>

(<span class="org-keyword">define</span> (<span class="org-function-name">project</span> number)
  (apply-generic 'project number))

(<span class="org-keyword">define</span> (<span class="org-function-name">equ?</span> n1 n2)
  (apply-generic 'equ? n1 n2))

(<span class="org-keyword">define</span> (<span class="org-function-name">drop</span> number)
  (handle-exceptions exn
    number
    (<span class="org-keyword">let</span> ((projection (project number)))
      (<span class="org-keyword">if</span> projection
          (<span class="org-keyword">let</span> ((promotion (raise projection)))
            (<span class="org-keyword">if</span> (<span class="org-keyword">and</span> promotion (equ? promotion number))
                (drop projection)
                number))
          number))))

(install-scheme-number-package)
(install-scheme-number-conversion-package)
(install-scheme-number-projection-package)
(install-rational-package)
(install-rational-conversion-package)
(install-rational-projection-package)
(install-complex-package)
(install-complex-conversion-package)
(install-complex-projection-package)

(install-integer-package)
(install-integer-projection-package)
(install-real-package)
(install-real-projection-package)

(<span class="org-keyword">let</span> ((integer (make-integer 1))
      (rational (make-rational 1 1))
      (real (make-real 1))
      (complex (make-complex-from-real-imag 1 0))
      (irreducible-complex (make-complex-from-real-imag 1 2)))
  <span class="org-comment-delimiter">;; </span><span class="org-comment">These tests rely on the fact that we're dealing with lists as a</span>
  <span class="org-comment-delimiter">;; </span><span class="org-comment">convential interface.</span>
  (test-assert (not (project integer)))
  (test integer (project rational))
  (test rational (project real))
  (test real (project complex))
  (test integer (drop complex))
  (test irreducible-complex (drop irreducible-complex)))

<span class="org-comment-delimiter">;;; </span><span class="org-comment">Simplifying apply-generic</span>

(<span class="org-keyword">define</span> (<span class="org-function-name">generic-number?</span> number)
  (<span class="org-keyword">and</span> (pair? number)
       (eq? (type-tag number) 'complex)))

(<span class="org-keyword">define</span> <span class="org-function-name">drop?</span> (make-parameter #t))

(<span class="org-keyword">define</span> (<span class="org-function-name">apply-generic</span> op . args)
  (<span class="org-keyword">let</span> ((type-tags (<span class="org-keyword">map</span> type-tag args)))
    (<span class="org-keyword">let</span> ((proc (get op type-tags)))
      (<span class="org-keyword">if</span> proc
          (<span class="org-keyword">let</span> ((result (apply proc (<span class="org-keyword">map</span> contents args))))
            (<span class="org-keyword">if</span> (drop?) (drop result) result))
          (<span class="org-keyword">cond</span> ((= (length args) 1)
                 (<span class="org-keyword">let</span> ((superarg (raise (car args))))
                   (<span class="org-keyword">if</span> superarg
                       (apply-generic op superarg)
                       (error <span class="org-string">"No method for these types"</span>
                              (list op type-tags)))))
                ((= (length args) 2)
                 (<span class="org-keyword">let</span> ((type1 (car type-tags))
                       (type2 (cadr type-tags))
                       (a1 (car args))
                       (a2 (cadr args)))
                   (<span class="org-keyword">cond</span> ((supertype? type1 type2)
                          (apply-generic op
                                         (raise-until-equitable a1 type2)
                                         a2))
                         ((supertype? type2 type1)
                          (apply-generic op a1 (raise-until-equitable a2
                                                                      type1)))
                         (<span class="org-keyword">else</span> (error <span class="org-string">"No method for these types"</span>
                                      (list op type-tags))))))
                (<span class="org-keyword">else</span> (error <span class="org-string">"No method for these types"</span> (list op type-tags))))))))

<span class="org-comment-delimiter">;;; </span><span class="org-comment">Don't drop on raise: it defeats the purpose of raising.</span>
(<span class="org-keyword">define</span> (<span class="org-function-name">raise</span> number)
  (parameterize ((drop? #f))
    (apply-generic 'raise number)))

(<span class="org-keyword">let</span> ((integer (make-integer 2))
      (complex (make-complex-from-real-imag 1 0)))
  (test integer (add complex complex)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-132" class="outline-2">
<h2 id="sec-132"><span class="section-number-2">132</span> <span class="done DONE">DONE</span> 2.86</h2>
<div class="outline-text-2" id="text-132">
<p>
For every primitive operation in the imaginary package, we have to
replace them with generic ones (including not only <code>cos</code> and <code>sin</code>,
but also <code>sqrt</code>, <code>square</code>, <code>atan</code>, <code>*</code>, <code>+</code>).
</p>

<p>
We could have done this more intelligently using e.g. coercion; we
could have also endeavored to preserve types (i.e. instead of
returning scheme-numbers from trigonometric and other functions,
return e.g. rationals).
</p>

<p>
We could have also installed the trigonometric and other functions
in the e.g. rational-package itself, instead of creating
function-specific packages.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(<span class="org-keyword">define</span> (<span class="org-function-name">install-rectangular-package</span>)
  <span class="org-comment-delimiter">;; </span><span class="org-comment">internal procedures</span>
  (<span class="org-keyword">define</span> (<span class="org-function-name">real-part</span> z) (car z))
  (<span class="org-keyword">define</span> (<span class="org-function-name">imag-part</span> z) (cdr z))
  (<span class="org-keyword">define</span> (<span class="org-function-name">make-from-real-imag</span> x y) (cons x y))
  (<span class="org-keyword">define</span> (<span class="org-function-name">magnitude</span> z)
    (square-root (add (square (real-part z))
                      (square (imag-part z)))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">angle</span> z)
    (arctan (imag-part z) (real-part z)))
  (<span class="org-keyword">define</span> (<span class="org-function-name">make-from-mag-ang</span> r a)
    (cons (* r (cos a)) (* r (sin a))))
  <span class="org-comment-delimiter">;; </span><span class="org-comment">interface to the rest of the system</span>
  (<span class="org-keyword">define</span> (<span class="org-function-name">tag</span> x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular
       (<span class="org-keyword">lambda</span> (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular
       (<span class="org-keyword">lambda</span> (r a) (tag (make-from-mag-ang r a))))
  'done)

(<span class="org-keyword">define</span> (<span class="org-function-name">install-polar-package</span>)
  <span class="org-comment-delimiter">;; </span><span class="org-comment">internal procedures</span>
  (<span class="org-keyword">define</span> (<span class="org-function-name">magnitude</span> z) (car z))
  (<span class="org-keyword">define</span> (<span class="org-function-name">angle</span> z) (cdr z))
  (<span class="org-keyword">define</span> (<span class="org-function-name">make-from-mag-ang</span> r a) (cons r a))
  (<span class="org-keyword">define</span> (<span class="org-function-name">real-part</span> z) (mul (magnitude z) (cosine (angle z))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">imag-part</span> z) (mul (magnitude z) (sine (angle z))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">make-from-real-imag</span> x y)
    (cons (square-root (add (square x) (square y)))
          (atan y x)))
  <span class="org-comment-delimiter">;; </span><span class="org-comment">interface to the rest of the system</span>
  (<span class="org-keyword">define</span> (<span class="org-function-name">tag</span> x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (<span class="org-keyword">lambda</span> (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar
       (<span class="org-keyword">lambda</span> (r a) (tag (make-from-mag-ang r a))))
  'done)

(<span class="org-keyword">define</span> (<span class="org-function-name">install-complex-package</span>)
  (install-polar-package)
  (install-rectangular-package)
  <span class="org-comment-delimiter">;; </span><span class="org-comment">imported procedures from rectangular and polar packages</span>
  (<span class="org-keyword">define</span> (<span class="org-function-name">make-from-real-imag</span> x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (<span class="org-keyword">define</span> (<span class="org-function-name">make-from-mag-ang</span> r a)
    ((get 'make-from-mag-ang 'polar) r a))
  <span class="org-comment-delimiter">;; </span><span class="org-comment">internal procedures</span>
  (<span class="org-keyword">define</span> (<span class="org-function-name">add-complex</span> z1 z2)
    (make-from-real-imag (add (real-part z1) (real-part z2))
                         (add (imag-part z1) (imag-part z2))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">sub-complex</span> z1 z2)
    (make-from-real-imag (sub (real-part z1) (real-part z2))
                         (sub (imag-part z1) (imag-part z2))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">mul-complex</span> z1 z2)
    (make-from-mag-ang (mul (magnitude z1) (magnitude z2))
                       (add (angle z1) (angle z2))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">div-complex</span> z1 z2)
    (make-from-mag-ang (div (magnitude z1) (magnitude z2))
                       (sub (angle z1) (angle z2))))
  <span class="org-comment-delimiter">;; </span><span class="org-comment">interface to rest of the system</span>
  (<span class="org-keyword">define</span> (<span class="org-function-name">tag</span> z) (attach-tag 'complex z))
  (put 'add '(complex complex)
       (<span class="org-keyword">lambda</span> (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (<span class="org-keyword">lambda</span> (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (<span class="org-keyword">lambda</span> (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (<span class="org-keyword">lambda</span> (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (<span class="org-keyword">lambda</span> (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (<span class="org-keyword">lambda</span> (r a) (tag (make-from-mag-ang r a))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)
  'done)

<span class="org-comment-delimiter">;;; </span><span class="org-comment">Should have done this using coercion; also, should have tried to</span>
<span class="org-comment-delimiter">;;; </span><span class="org-comment">preserve types?</span>
(<span class="org-keyword">define</span> (<span class="org-function-name">install-trigonometric-etc-package</span>)
  (<span class="org-keyword">define</span> (<span class="org-function-name">tag-scheme-number</span> object)
    (attach-tag 'scheme-number object))
  (put 'arctan '(scheme-number)
       (<span class="org-keyword">lambda</span> (n) (tag-scheme-number (atan n))))
  (put 'arctan '(rational)
       (<span class="org-keyword">lambda</span> (n) (tag-scheme-number (atan (/ (numer n) (denom n))))))
  (put 'sine '(scheme-number)
       (<span class="org-keyword">lambda</span> (n) (tag-scheme-number (sin n))))
  (put 'sine '(rational)
       (<span class="org-keyword">lambda</span> (n) (tag-scheme-number (sin (/ (numer n) (denom n))))))
  (put 'cosine '(scheme-number)
       (<span class="org-keyword">lambda</span> (n) (tag-scheme-number (cos n))))
  (put 'cosine '(rational)
       (<span class="org-keyword">lambda</span> (n) (tag-scheme-number (cos (/ (numer n) (denom n))))))
  (put 'square '(scheme-number)
       (<span class="org-keyword">lambda</span> (n) (tag-scheme-number (* n n))))
  (put 'square '(rational)
       (<span class="org-keyword">lambda</span> (n) (<span class="org-keyword">let</span> ((n (/ (numer n) (denom n))))
                (tag-scheme-number (* n n)))))
  (put 'square-root '(scheme-number)
       (<span class="org-keyword">lambda</span> (n) (tag-scheme-number (sqrt n))))
  (put 'square-root '(rational)
       (<span class="org-keyword">lambda</span> (n) (tag-scheme-number
               (sqrt (/ (numer n) (denom n)))))))

(<span class="org-keyword">define</span> (<span class="org-function-name">arctan</span> x) (apply-generic 'arctan x))
(<span class="org-keyword">define</span> (<span class="org-function-name">cosine</span> x) (apply-generic 'cosine x))
(<span class="org-keyword">define</span> (<span class="org-function-name">sine</span> x) (apply-generic 'sine x))
(<span class="org-keyword">define</span> (<span class="org-function-name">square</span> x) (apply-generic 'square x))
(<span class="org-keyword">define</span> (<span class="org-function-name">square-root</span> x) (apply-generic 'square-root x))

(install-scheme-number-package)
(install-rational-package)
(install-complex-package)
(install-trigonometric-etc-package)

(<span class="org-keyword">let*</span> ((rational (make-rational 1 2))
       (complex (make-complex-from-real-imag rational rational)))
  (test '(complex rectangular (rational 1 . 1) rational 1 . 1)
        (add complex complex)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-133" class="outline-2">
<h2 id="sec-133"><span class="section-number-2">133</span> <span class="done DONE">DONE</span> 2.87</h2>
<div class="outline-text-2" id="text-133">
<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">attach-tag</span> type-tag contents)
  (<span class="org-keyword">if</span> (eq? type-tag 'scheme-number)
      contents
      (cons type-tag contents)))

(<span class="org-keyword">define</span> (<span class="org-function-name">type-tag</span> datum)
  (<span class="org-keyword">cond</span> ((number? datum) 'scheme-number)
        ((pair? datum) (car datum))
        (<span class="org-keyword">else</span> (error <span class="org-string">"Bad tagged datum: TYPE-TAG"</span> datum))))

(<span class="org-keyword">define</span> (<span class="org-function-name">contents</span> datum)
  (<span class="org-keyword">cond</span> ((number? datum) datum)
        ((pair? datum) (cdr datum))
        (<span class="org-keyword">else</span> (error <span class="org-string">"Bad tagged datum: CONTENTS"</span> datum))))

(<span class="org-keyword">define</span> (<span class="org-function-name">install-zero-package</span>)
  (put '=zero? '(scheme-number) (<span class="org-keyword">lambda</span> (n) (= 0 n)))
  (put '=zero? '(rational) (<span class="org-keyword">lambda</span> (n) (= 0 (numer n))))
  (put '=zero? '(complex) (<span class="org-keyword">lambda</span> (n) (<span class="org-keyword">and</span> (= (imag-part n) 0)
                                      (= (real-part n) 0)))))

(<span class="org-keyword">define</span> (<span class="org-function-name">=zero?</span> n) (apply-generic '=zero? n))

(<span class="org-keyword">define</span> (<span class="org-function-name">install-polynomial-package</span>)
  <span class="org-comment-delimiter">;; </span><span class="org-comment">internal procedures</span>
  <span class="org-comment-delimiter">;; </span><span class="org-comment">representation of poly</span>
  (<span class="org-keyword">define</span> (<span class="org-function-name">make-poly</span> variable term-list) (cons variable term-list))
  (<span class="org-keyword">define</span> (<span class="org-function-name">variable</span> p) (car p))
  (<span class="org-keyword">define</span> (<span class="org-function-name">term-list</span> p) (cdr p))
  (<span class="org-keyword">define</span> <span class="org-function-name">variable?</span> symbol?)

  (<span class="org-keyword">define</span> (<span class="org-function-name">same-variable?</span> v1 v2)
    (<span class="org-keyword">and</span> (variable? v1) (variable? v2) (eq? v1 v2)))
  (<span class="org-keyword">define</span> (<span class="org-function-name">adjoin-term</span> term term-list)
    (<span class="org-keyword">if</span> (=zero? (coeff term))
        term-list
        (cons term term-list)))
  (<span class="org-keyword">define</span> (<span class="org-function-name">the-empty-termlist</span>) '())
  (<span class="org-keyword">define</span> (<span class="org-function-name">first-term</span> term-list) (car term-list))
  (<span class="org-keyword">define</span> (<span class="org-function-name">rest-terms</span> term-list) (cdr term-list))
  (<span class="org-keyword">define</span> (<span class="org-function-name">empty-termlist?</span> term-list) (null? term-list))
  (<span class="org-keyword">define</span> (<span class="org-function-name">make-term</span> order coeff) (list order coeff))
  (<span class="org-keyword">define</span> (<span class="org-function-name">order</span> term) (car term))
  (<span class="org-keyword">define</span> (<span class="org-function-name">coeff</span> term) (cadr term))

  (<span class="org-keyword">define</span> (<span class="org-function-name">add-poly</span> p1 p2)
    (<span class="org-keyword">if</span> (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (add-terms (term-list p1) (term-list p2)))
        (error <span class="org-string">"Polys not in same var: ADD-POLY"</span> (list p1 p2))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">add-terms</span> L1 L2)
    (<span class="org-keyword">cond</span> ((empty-termlist? L1) L2)
          ((empty-termlist? L2) L1)
          (<span class="org-keyword">else</span>
           (<span class="org-keyword">let</span> ((t1 (first-term L1))
                 (t2 (first-term L2)))
             (<span class="org-keyword">cond</span> ((&gt; (order t1) (order t2))
                    (adjoin-term
                     t1 (add-terms (rest-terms L1) L2)))
                   ((&lt; (order t1) (order t2))
                    (adjoin-term
                     t2 (add-terms L1 (rest-terms L2))))
                   (<span class="org-keyword">else</span>
                    (adjoin-term
                     (make-term (order t1)
                                (add (coeff t1) (coeff t2)))
                     (add-terms (rest-terms L1)
                                (rest-terms L2)))))))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">mul-poly</span> p1 p2)
    (<span class="org-keyword">if</span> (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (mul-terms (term-list p1) (term-list p2)))
        (error <span class="org-string">"Polys not in same var: MUL-POLY"</span> (list p1 p2))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">mul-terms</span> L1 L2)
    (<span class="org-keyword">if</span> (empty-termlist? L1)
        (the-empty-termlist)
        (add-terms (mul-term-by-all-terms (first-term L1) L2)
                   (mul-terms (rest-terms L1) L2))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">mul-term-by-all-terms</span> t1 L)
    (<span class="org-keyword">if</span> (empty-termlist? L)
        (the-empty-termlist)
        (<span class="org-keyword">let</span> ((t2 (first-term L)))
          (adjoin-term
           (make-term (+ (order t1) (order t2))
                      (mul (coeff t1) (coeff t2)))
           (mul-term-by-all-terms t1 (rest-terms L))))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">poly-=zero?</span> p)
    (<span class="org-keyword">let</span> ((term-list (term-list p)))
      (<span class="org-keyword">or</span> (empty-termlist? term-list)
          (every =zero? (<span class="org-keyword">map</span> coeff term-list)))))
  <span class="org-comment-delimiter">;; </span><span class="org-comment">interface to rest of the system</span>
  (<span class="org-keyword">define</span> (<span class="org-function-name">tag</span> p) (attach-tag 'polynomial p))
  (put 'add '(polynomial polynomial)
       (<span class="org-keyword">lambda</span> (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial)
       (<span class="org-keyword">lambda</span> (p1 p2) (tag (mul-poly p1 p2))))
  (put 'make 'polynomial
       (<span class="org-keyword">lambda</span> (var terms) (tag (make-poly var terms))))
  (put '=zero? '(polynomial) poly-=zero?)
  'done)

(<span class="org-keyword">define</span> (<span class="org-function-name">make-polynomial</span> var terms)
  ((get 'make 'polynomial) var terms))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(include <span class="org-string">"polynomial.scm"</span>)

(install-scheme-number-package)
(install-rational-package)
(install-complex-package)
(install-polynomial-package)
(install-zero-package)

(<span class="org-keyword">let*</span> ((p1 (make-polynomial 'x '((2 1))))
       (p2 (make-polynomial 'x `((2 ,p1)))))
  (test '(polynomial x (2 (polynomial x (2 2))))
        (add p2 p2)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-134" class="outline-2">
<h2 id="sec-134"><span class="section-number-2">134</span> <span class="done DONE">DONE</span> 2.88</h2>
<div class="outline-text-2" id="text-134">
<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">install-negation-package</span>)
  (put 'negate '(scheme-number)
       (<span class="org-keyword">lambda</span> (n) (make-scheme-number (- n))))
  (put 'negate '(rational)
       (<span class="org-keyword">lambda</span> (r) (make-rational (- (numer r))
                             (denom r))))
  (put 'negate '(complex)
       (<span class="org-keyword">lambda</span> (z) (make-complex-from-real-imag
               (- (real-part z))
               (- (imag-part z)))))

  (<span class="org-keyword">define</span> (<span class="org-function-name">variable</span> p) (car p))
  (<span class="org-keyword">define</span> (<span class="org-function-name">term-list</span> p) (cdr p))
  (<span class="org-keyword">define</span> (<span class="org-function-name">make-term</span> order coeff) (list order coeff))
  (<span class="org-keyword">define</span> (<span class="org-function-name">term-list</span> p) (cdr p))
  (<span class="org-keyword">define</span> (<span class="org-function-name">order</span> term) (car term))
  (<span class="org-keyword">define</span> (<span class="org-function-name">coeff</span> term) (cadr term))
  (put 'negate '(polynomial)
       (<span class="org-keyword">lambda</span> (p) (make-polynomial (variable p)
                               (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (term)
                                      (make-term (order term)
                                                 (negate (coeff term))))
                                    (term-list p))))))

(<span class="org-keyword">define</span> (<span class="org-function-name">negate</span> n) (apply-generic 'negate n))

(<span class="org-keyword">define</span> (<span class="org-function-name">install-polynomial-sub-package</span>)
  (<span class="org-keyword">define</span> (<span class="org-function-name">sub-poly</span> p1 p2)
    (add (attach-tag 'polynomial p1)
         (negate (attach-tag 'polynomial p2))))
  (put 'sub '(polynomial polynomial) sub-poly))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(include <span class="org-string">"polynomial.scm"</span>)
(include <span class="org-string">"polynomial-sub.scm"</span>)

(install-scheme-number-package)
(install-rational-package)
(install-complex-package)
(install-polynomial-package)
(install-negation-package)
(install-polynomial-sub-package)

(<span class="org-keyword">let*</span> ((p1 (make-polynomial 'x '((2 1))))
       (p2 (make-polynomial 'x `((2 ,p1)))))
  (test '(polynomial x)
        (sub p2 p2)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-135" class="outline-2">
<h2 id="sec-135"><span class="section-number-2">135</span> <span class="done DONE">DONE</span> 2.89</h2>
<div class="outline-text-2" id="text-135">
<p>
It is sufficient to modify <code>first-term</code> and <code>adjoin-term</code> to
implement the dense representation.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(include <span class="org-string">"polynomial.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">install-polynomial-package</span>)
  <span class="org-comment-delimiter">;; </span><span class="org-comment">Modified these accessors for the dense representation.</span>
  (<span class="org-keyword">define</span> (<span class="org-function-name">first-term</span> term-list)
    (make-term (- (length term-list) 1)
               (car term-list)))

  (<span class="org-keyword">define</span> (<span class="org-function-name">adjoin-term</span> term term-list)
    (<span class="org-keyword">if</span> (= (length term-list) (order term))
        (cons (coeff term) term-list)
        (adjoin-term term (cons 0 term-list))))

  <span class="org-comment-delimiter">;; </span><span class="org-comment">The rest is the same.</span>
  (<span class="org-keyword">define</span> (<span class="org-function-name">make-poly</span> variable term-list)
    (cons variable term-list))
  (<span class="org-keyword">define</span> (<span class="org-function-name">variable</span> p) (car p))
  (<span class="org-keyword">define</span> (<span class="org-function-name">term-list</span> p) (cdr p))
  (<span class="org-keyword">define</span> <span class="org-function-name">variable?</span> symbol?)

  (<span class="org-keyword">define</span> (<span class="org-function-name">same-variable?</span> v1 v2)
    (<span class="org-keyword">and</span> (variable? v1) (variable? v2) (eq? v1 v2)))
  (<span class="org-keyword">define</span> (<span class="org-function-name">the-empty-termlist</span>) '())
  (<span class="org-keyword">define</span> (<span class="org-function-name">rest-terms</span> term-list) (cdr term-list))
  (<span class="org-keyword">define</span> (<span class="org-function-name">empty-termlist?</span> term-list) (null? term-list))
  (<span class="org-keyword">define</span> (<span class="org-function-name">make-term</span> order coeff) (list order coeff))
  (<span class="org-keyword">define</span> (<span class="org-function-name">order</span> term) (car term))
  (<span class="org-keyword">define</span> (<span class="org-function-name">coeff</span> term) (cadr term))

  (<span class="org-keyword">define</span> (<span class="org-function-name">add-poly</span> p1 p2)
    (<span class="org-keyword">if</span> (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (add-terms (term-list p1) (term-list p2)))
        (error <span class="org-string">"Polys not in same var: ADD-POLY"</span> (list p1 p2))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">add-terms</span> L1 L2)
    (<span class="org-keyword">cond</span> ((empty-termlist? L1) L2)
          ((empty-termlist? L2) L1)
          (<span class="org-keyword">else</span>
           (<span class="org-keyword">let</span> ((t1 (first-term L1))
                 (t2 (first-term L2)))
             (<span class="org-keyword">cond</span> ((&gt; (order t1) (order t2))
                    (adjoin-term
                     t1 (add-terms (rest-terms L1) L2)))
                   ((&lt; (order t1) (order t2))
                    (adjoin-term
                     t2 (add-terms L1 (rest-terms L2))))
                   (<span class="org-keyword">else</span>
                    (adjoin-term
                     (make-term (order t1)
                                (add (coeff t1) (coeff t2)))
                     (add-terms (rest-terms L1)
                                (rest-terms L2)))))))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">mul-poly</span> p1 p2)
    (<span class="org-keyword">if</span> (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (mul-terms (term-list p1) (term-list p2)))
        (error <span class="org-string">"Polys not in same var: MUL-POLY"</span> (list p1 p2))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">mul-terms</span> L1 L2)
    (<span class="org-keyword">if</span> (empty-termlist? L1)
        (the-empty-termlist)
        (add-terms (mul-term-by-all-terms (first-term L1) L2)
                   (mul-terms (rest-terms L1) L2))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">mul-term-by-all-terms</span> t1 L)
    (<span class="org-keyword">if</span> (empty-termlist? L)
        (the-empty-termlist)
        (<span class="org-keyword">let</span> ((t2 (first-term L)))
          (adjoin-term
           (make-term (+ (order t1) (order t2))
                      (mul (coeff t1) (coeff t2)))
           (mul-term-by-all-terms t1 (rest-terms L))))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">poly-=zero?</span> p)
    (<span class="org-keyword">let</span> ((term-list (term-list p)))
      (<span class="org-keyword">or</span> (empty-termlist? term-list)
          (every =zero? (<span class="org-keyword">map</span> coeff term-list)))))
  <span class="org-comment-delimiter">;; </span><span class="org-comment">interface to rest of the system</span>
  (<span class="org-keyword">define</span> (<span class="org-function-name">tag</span> p) (attach-tag 'polynomial p))
  (put 'add '(polynomial polynomial)
       (<span class="org-keyword">lambda</span> (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial)
       (<span class="org-keyword">lambda</span> (p1 p2) (tag (mul-poly p1 p2))))
  (put 'make 'polynomial
       (<span class="org-keyword">lambda</span> (var terms) (tag (make-poly var terms))))
  (put '=zero? '(polynomial) poly-=zero?)
  'done)

(install-scheme-number-package)
(install-rational-package)
(install-complex-package)
(install-polynomial-package)

(<span class="org-keyword">let*</span> ((p1 (make-polynomial 'x '(1 0 0)))
       (p2 (make-polynomial 'x `(,p1 0 0))))
  (test '(polynomial x (polynomial x 2 0 0) 0 0)
         (add p2 p2)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-136" class="outline-2">
<h2 id="sec-136"><span class="section-number-2">136</span> <span class="done DONE">DONE</span> 2.90</h2>
<div class="outline-text-2" id="text-136">
<p>
Unlike complex numbers, we don’t have two types of polynomials:
sparse and dense; instead, we have one type of polynomial (namely
polynomial) and two types of term lists, sparse and dense, such that
a polynomial looks like: <code>(polynomial x sparse (2 2))</code>.
</p>

<p>
It’s also useful to have a <code>term</code> type for generic operations
involving coefficients, etc.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(include <span class="org-string">"polynomial.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">install-term-package</span>)
  (<span class="org-keyword">define</span> (<span class="org-function-name">tag</span> object) (attach-tag 'term object))
  (<span class="org-keyword">define</span> (<span class="org-function-name">make</span> order coeff) (list order coeff))
  (<span class="org-keyword">define</span> <span class="org-function-name">order</span> car)
  (<span class="org-keyword">define</span> <span class="org-function-name">coeff</span> cadr)
  (put 'make-term 'term (<span class="org-keyword">lambda</span> (order coeff)
                          (tag (list order coeff))))
  (put 'order '(term) order)
  (put 'coeff '(term) coeff))

(<span class="org-keyword">define</span> (<span class="org-function-name">make-term</span> order coeff)
  ((get 'make-term 'term) order coeff))

(<span class="org-keyword">define</span> (<span class="org-function-name">order</span> term)
  (apply-generic 'order term))

(<span class="org-keyword">define</span> (<span class="org-function-name">coeff</span> term)
  (apply-generic 'coeff term))

(<span class="org-keyword">define</span> (<span class="org-function-name">install-sparse-term-package</span>)
  (<span class="org-keyword">define</span> (<span class="org-function-name">tag</span> object) (attach-tag 'sparse object))
  (<span class="org-keyword">define</span> (<span class="org-function-name">first-term</span> term-list) (apply make-term (car term-list)))
  (<span class="org-keyword">define</span> (<span class="org-function-name">adjoin-term</span> term term-list)
    (<span class="org-keyword">let</span> ((term (apply make-term term)))
      (<span class="org-keyword">if</span> (=zero? (coeff term))
          (tag term-list)
          (tag (cons (contents term) term-list)))))
  (put 'make-terms 'sparse
       (<span class="org-keyword">lambda</span> (terms)
         (attach-tag 'sparse terms)))
  (put 'first-term '(sparse) first-term)
  (put 'adjoin-term '(term sparse) adjoin-term)
  (put 'empty-termlist? '(sparse) null?)
  (put 'rest-terms '(sparse) (compose tag cdr)))

(<span class="org-keyword">define</span> (<span class="org-function-name">install-dense-term-package</span>)
  (<span class="org-keyword">define</span> (<span class="org-function-name">tag</span> object) (attach-tag 'dense object))
  (<span class="org-keyword">define</span> (<span class="org-function-name">first-term</span> term-list)
    (make-term (- (length term-list) 1)
               (car term-list)))
  (<span class="org-keyword">define</span> (<span class="org-function-name">adjoin-term</span> term term-list)
    (<span class="org-keyword">let</span> ((term (apply make-term term)))
      (<span class="org-keyword">if</span> (= (length term-list) (order term))
          (tag (cons (coeff term) term-list))
          (adjoin-term (contents term)
                       (cons 0 term-list)))))
  (put 'make-terms 'dense
       (<span class="org-keyword">lambda</span> (terms) (tag terms)))
  (put 'first-term '(dense) first-term)
  (put 'adjoin-term '(term dense) adjoin-term)
  (put 'empty-termlist? '(dense) null?)
  (put 'rest-terms '(dense) (compose tag cdr)))

(<span class="org-keyword">define</span> (<span class="org-function-name">first-term</span> term-list)
  (apply-generic 'first-term term-list))

(<span class="org-keyword">define</span> (<span class="org-function-name">adjoin-term</span> term term-list)
  (apply-generic 'adjoin-term term term-list))

(<span class="org-keyword">define</span> (<span class="org-function-name">empty-termlist?</span> terms)
  (apply-generic 'empty-termlist? terms))

(<span class="org-keyword">define</span> (<span class="org-function-name">rest-terms</span> terms)
  (apply-generic 'rest-terms terms))

(<span class="org-keyword">define</span> (<span class="org-function-name">make-sparse-terms</span> terms)
  ((get 'make-terms 'sparse) terms))

(<span class="org-keyword">define</span> (<span class="org-function-name">make-dense-terms</span> terms)
  ((get 'make-terms 'dense) terms))

(<span class="org-keyword">define</span> (<span class="org-function-name">install-polynomial-package</span>)
  <span class="org-comment-delimiter">;; </span><span class="org-comment">internal procedures</span>
  <span class="org-comment-delimiter">;; </span><span class="org-comment">representation of poly</span>
  (<span class="org-keyword">define</span> (<span class="org-function-name">make-poly</span> variable term-list)
    (cons variable term-list))
  (<span class="org-keyword">define</span> (<span class="org-function-name">variable</span> p) (car p))
  (<span class="org-keyword">define</span> (<span class="org-function-name">term-list</span> p) (cdr p))
  (<span class="org-keyword">define</span> <span class="org-function-name">variable?</span> symbol?)

  (<span class="org-keyword">define</span> (<span class="org-function-name">same-variable?</span> v1 v2)
    (<span class="org-keyword">and</span> (variable? v1) (variable? v2) (eq? v1 v2)))
  (<span class="org-keyword">define</span> (<span class="org-function-name">the-empty-termlist</span>) '())

  (<span class="org-keyword">define</span> (<span class="org-function-name">add-poly</span> p1 p2)
    (<span class="org-keyword">if</span> (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (add-terms (term-list p1) (term-list p2)))
        (error <span class="org-string">"Polys not in same var: ADD-POLY"</span> (list p1 p2))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">add-terms</span> L1 L2)
    (<span class="org-keyword">cond</span> ((empty-termlist? L1) L2)
          ((empty-termlist? L2) L1)
          (<span class="org-keyword">else</span>
           (<span class="org-keyword">let</span> ((t1 (first-term L1))
                 (t2 (first-term L2)))
             (<span class="org-keyword">cond</span> ((&gt; (order t1) (order t2))
                    (adjoin-term
                     t1 (add-terms (rest-terms L1) L2)))
                   ((&lt; (order t1) (order t2))
                    (adjoin-term
                     t2 (add-terms L1 (rest-terms L2))))
                   (<span class="org-keyword">else</span>
                    (adjoin-term
                     (make-term (order t1)
                                (add (coeff t1) (coeff t2)))
                     (add-terms (rest-terms L1)
                                (rest-terms L2)))))))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">mul-poly</span> p1 p2)
    (<span class="org-keyword">if</span> (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (mul-terms (term-list p1) (term-list p2)))
        (error <span class="org-string">"Polys not in same var: MUL-POLY"</span> (list p1 p2))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">mul-terms</span> L1 L2)
    (<span class="org-keyword">if</span> (empty-termlist? L1)
        (the-empty-termlist)
        (add-terms (mul-term-by-all-terms (first-term L1) L2)
                   (mul-terms (rest-terms L1) L2))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">mul-term-by-all-terms</span> t1 L)
    (<span class="org-keyword">if</span> (empty-termlist? L)
        (the-empty-termlist)
        (<span class="org-keyword">let</span> ((t2 (first-term L)))
          (adjoin-term
           (make-term (+ (order t1) (order t2))
                      (mul (coeff t1) (coeff t2)))
           (mul-term-by-all-terms t1 (rest-terms L))))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">poly-=zero?</span> p)
    (<span class="org-keyword">let</span> ((term-list (term-list p)))
      (<span class="org-keyword">or</span> (empty-termlist? term-list)
          (every =zero? (<span class="org-keyword">map</span> coeff term-list)))))
  <span class="org-comment-delimiter">;; </span><span class="org-comment">interface to rest of the system</span>
  (<span class="org-keyword">define</span> (<span class="org-function-name">tag</span> p) (attach-tag 'polynomial p))
  (put 'add '(polynomial polynomial)
       (<span class="org-keyword">lambda</span> (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial)
       (<span class="org-keyword">lambda</span> (p1 p2) (tag (mul-poly p1 p2))))
  (put 'make 'polynomial
       (<span class="org-keyword">lambda</span> (var terms) (tag (make-poly var terms))))
  (put '=zero? '(polynomial) poly-=zero?)
  'done)

(<span class="org-keyword">define</span> (<span class="org-function-name">make-sparse-polynomial</span> var terms)
  ((get 'make 'polynomial) var (make-sparse-terms terms)))

(<span class="org-keyword">define</span> (<span class="org-function-name">make-dense-polynomial</span> var terms)
  ((get 'make 'polynomial) var (make-dense-terms terms)))

(<span class="org-keyword">define</span> (<span class="org-function-name">=zero?</span> n) (apply-generic '=zero? n))

(install-zero-package)
(install-scheme-number-package)
(install-rational-package)
(install-complex-package)
(install-term-package)
(install-sparse-term-package)
(install-dense-term-package)
(install-polynomial-package)

(<span class="org-keyword">let*</span> ((p1 (make-sparse-polynomial 'x '((2 1))))
       (p2 (make-dense-polynomial 'x `(,p1 0 0))))
  (test '(polynomial x dense (polynomial x sparse (2 2)) 0 0)
        (add p2 p2)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-137" class="outline-2">
<h2 id="sec-137"><span class="section-number-2">137</span> <span class="done DONE">DONE</span> 2.91</h2>
<div class="outline-text-2" id="text-137">
<p>
In order to pull this off, we had to employ generic <code>=zero?</code> and
<code>sub</code>; because we were working outside of the original polynomial
package, there was a little awkwardness in terms of reexporting
polynomials for generic operations.
</p>

<p>
(We have a separate case for zero-polynomials which Robert didn’t
need; why is that?)
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">install-polynomial-div-package</span>)
  <span class="org-comment-delimiter">;; </span><span class="org-comment">Copied, unfortunately, from the polynomial package</span>
  (<span class="org-keyword">define</span> (<span class="org-function-name">make-poly</span> variable term-list) (cons variable term-list))
  (<span class="org-keyword">define</span> (<span class="org-function-name">variable</span> p) (car p))
  (<span class="org-keyword">define</span> (<span class="org-function-name">term-list</span> p) (cdr p))
  (<span class="org-keyword">define</span> <span class="org-function-name">variable?</span> symbol?)

  (<span class="org-keyword">define</span> (<span class="org-function-name">same-variable?</span> v1 v2)
    (<span class="org-keyword">and</span> (variable? v1) (variable? v2) (eq? v1 v2)))
  (<span class="org-keyword">define</span> (<span class="org-function-name">adjoin-term</span> term term-list)
    (<span class="org-keyword">if</span> (=zero? (coeff term))
        term-list
        (cons term term-list)))
  (<span class="org-keyword">define</span> (<span class="org-function-name">the-empty-termlist</span>) '())
  (<span class="org-keyword">define</span> (<span class="org-function-name">first-term</span> term-list) (car term-list))
  (<span class="org-keyword">define</span> (<span class="org-function-name">rest-terms</span> term-list) (cdr term-list))
  (<span class="org-keyword">define</span> (<span class="org-function-name">empty-termlist?</span> term-list) (null? term-list))
  (<span class="org-keyword">define</span> (<span class="org-function-name">make-term</span> order coeff) (list order coeff))
  (<span class="org-keyword">define</span> (<span class="org-function-name">order</span> term) (car term))
  (<span class="org-keyword">define</span> (<span class="org-function-name">coeff</span> term) (cadr term))
  (<span class="org-keyword">define</span> (<span class="org-function-name">tag</span> p) (attach-tag 'polynomial p))

  <span class="org-comment-delimiter">;; </span><span class="org-comment">Division starts here.</span>
  (<span class="org-keyword">define</span> (<span class="org-function-name">div-poly</span> p1 p2)
    (<span class="org-keyword">if</span> (same-variable? (variable p1) (variable p2))
        (<span class="org-keyword">let</span> ((variable (variable p1)))
          (<span class="org-keyword">let</span> ((result (div-terms variable
                                   (term-list p1)
                                   (term-list p2))))
            (list (make-polynomial variable (car result))
                  (make-polynomial variable (cadr result)))))
        (error <span class="org-string">"Polys not in same var: DIV-POLY"</span> (list p1 p2))))

  (<span class="org-keyword">define</span> (<span class="org-function-name">div-terms</span> variable L1 L2)
    (<span class="org-keyword">cond</span> ((every =zero? (<span class="org-keyword">map</span> coeff L1))
           (list (list (make-term 0 0)) (list (make-term 0 0))))
          ((empty-termlist? L1)
           (list (the-empty-termlist) (the-empty-termlist)))
          (<span class="org-keyword">else</span>
           (<span class="org-keyword">let</span> ((t1 (first-term L1))
                 (t2 (first-term L2)))
             (<span class="org-keyword">if</span> (&gt; (order t2) (order t1))
                 (list (the-empty-termlist) L1)
                 (<span class="org-keyword">let</span> ((new-c (div (coeff t1) (coeff t2)))
                       (new-o (- (order t1) (order t2))))
                   (<span class="org-keyword">let</span> ((new-term (make-term new-o new-c)))
                     (<span class="org-keyword">let</span> ((result (make-polynomial variable (list new-term)))
                           (dividend (make-polynomial variable L1))
                           (divisor (make-polynomial variable L2)))
                       (<span class="org-keyword">let</span> ((rest-of-result
                              (div-terms variable
                                         (term-list
                                          (contents
                                           (sub dividend (mul result divisor))))
                                         L2)))
                         (list (adjoin-term new-term (car rest-of-result))
                               (cadr rest-of-result)))))))))))

  (put 'div '(polynomial polynomial) div-poly))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(include <span class="org-string">"polynomial.scm"</span>)
(include <span class="org-string">"polynomial-sub.scm"</span>)
(include <span class="org-string">"polynomial-div.scm"</span>)

(install-scheme-number-package)
(install-rational-package)
(install-complex-package)
(install-negation-package)
(install-polynomial-package)
(install-polynomial-sub-package)
(install-polynomial-div-package)
(install-zero-package)

(<span class="org-keyword">let</span> ((p1 (make-polynomial 'x '((5 1) (0 -1))))
      (p2 (make-polynomial 'x '((2 1) (0 -1)))))
  (test '((polynomial x (3 1) (1 1)) (polynomial x (1 1) (0 -1)))
        (div p1 p2)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-138" class="outline-2">
<h2 id="sec-138"><span class="section-number-2">138</span> <span class="todo TODO">TODO</span> 2.92</h2>
<div class="outline-text-2" id="text-138">
<p>
How would this work: order the primary variable first, followed by
secondary, tertiary, etc.?
</p>
</div>
</div>
<div id="outline-container-sec-139" class="outline-2">
<h2 id="sec-139"><span class="section-number-2">139</span> <span class="done DONE">DONE</span> 2.93</h2>
<div class="outline-text-2" id="text-139">
<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">install-rational-package</span>)
  <span class="org-comment-delimiter">;; </span><span class="org-comment">internal procedures</span>
  (<span class="org-keyword">define</span> (<span class="org-function-name">numer</span> x) (car x))
  (<span class="org-keyword">define</span> (<span class="org-function-name">denom</span> x) (cdr x))
  (<span class="org-keyword">define</span> (<span class="org-function-name">make-rat</span> n d)
    (cons n d))
  (<span class="org-keyword">define</span> (<span class="org-function-name">add-rat</span> x y)
    (make-rat (add (mul (numer x) (denom y))
                   (mul (numer y) (denom x)))
              (mul (denom x) (denom y))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">sub-rat</span> x y)
    (make-rat (sub (mul (numer x) (denom y))
                   (mul (numer y) (denom x)))
              (mul (denom x) (denom y))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">mul-rat</span> x y)
    (make-rat (mul (numer x) (numer y))
              (mul (denom x) (denom y))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">div-rat</span> x y)
    (make-rat (mul (numer x) (denom y))
              (mul (denom x) (numer y))))
  <span class="org-comment-delimiter">;; </span><span class="org-comment">interface to rest of the system</span>
  (<span class="org-keyword">define</span> (<span class="org-function-name">tag</span> x) (attach-tag 'rational x))
  (put 'add '(rational rational)
       (<span class="org-keyword">lambda</span> (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (<span class="org-keyword">lambda</span> (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (<span class="org-keyword">lambda</span> (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (<span class="org-keyword">lambda</span> (x y) (tag (div-rat x y))))
  (put 'make 'rational
       (<span class="org-keyword">lambda</span> (n d) (tag (make-rat n d))))
  (put 'numer '(rational) numer)
  (put 'denom '(rational) denom)
  'done)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use debug sicp test)

(include <span class="org-string">"polynomial.scm"</span>)
(include <span class="org-string">"polynomial-sub.scm"</span>)
(include <span class="org-string">"polynomial-div.scm"</span>)
(include <span class="org-string">"rational-generic.scm"</span>)

(install-scheme-number-package)
(install-rational-package)
(install-complex-package)
(install-negation-package)
(install-polynomial-package)
(install-polynomial-sub-package)
(install-polynomial-div-package)
(install-zero-package)

(<span class="org-keyword">let</span> ((p1 (make-polynomial 'x '((2 1) (0 1))))
      (p2 (make-polynomial 'x '((3 1) (0 1)))))
  (<span class="org-keyword">let</span> ((rf (make-rational p2 p1)))
    (test '(rational (polynomial x (5 2) (3 2) (2 2) (0 2))
                     polynomial x (4 1) (2 2) (0 1))
          (add rf rf))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-140" class="outline-2">
<h2 id="sec-140"><span class="section-number-2">140</span> <span class="done DONE">DONE</span> 2.94</h2>
<div class="outline-text-2" id="text-140">
<p>
According to <a href="http://po.st/UPdANw">WolframAlpha</a>, though, the result is not \(-x^2 + x\) but
\(x^2 - x\); which, I take it, is because they prefer <a href="http://en.wikipedia.org/wiki/Monic_polynomial">monic form</a>.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">install-greatest-common-divisor-package</span>)
  <span class="org-comment-delimiter">;; </span><span class="org-comment">Copied, unfortunately, from the polynomial package</span>
  (<span class="org-keyword">define</span> (<span class="org-function-name">make-poly</span> variable term-list) (cons variable term-list))
  (<span class="org-keyword">define</span> (<span class="org-function-name">variable</span> p) (car p))
  (<span class="org-keyword">define</span> (<span class="org-function-name">term-list</span> p) (cdr p))
  (<span class="org-keyword">define</span> <span class="org-function-name">variable?</span> symbol?)

  (<span class="org-keyword">define</span> (<span class="org-function-name">same-variable?</span> v1 v2)
    (<span class="org-keyword">and</span> (variable? v1) (variable? v2) (eq? v1 v2)))
  (<span class="org-keyword">define</span> (<span class="org-function-name">adjoin-term</span> term term-list)
    (<span class="org-keyword">if</span> (=zero? (coeff term))
        term-list
        (cons term term-list)))
  (<span class="org-keyword">define</span> (<span class="org-function-name">the-empty-termlist</span>) '())
  (<span class="org-keyword">define</span> (<span class="org-function-name">first-term</span> term-list) (car term-list))
  (<span class="org-keyword">define</span> (<span class="org-function-name">rest-terms</span> term-list) (cdr term-list))
  (<span class="org-keyword">define</span> (<span class="org-function-name">empty-termlist?</span> term-list) (null? term-list))
  (<span class="org-keyword">define</span> (<span class="org-function-name">make-term</span> order coeff) (list order coeff))
  (<span class="org-keyword">define</span> (<span class="org-function-name">order</span> term) (car term))
  (<span class="org-keyword">define</span> (<span class="org-function-name">coeff</span> term) (cadr term))
  (<span class="org-keyword">define</span> (<span class="org-function-name">tag</span> p) (attach-tag 'polynomial p))

  (<span class="org-keyword">define</span> (<span class="org-function-name">remainder-terms</span> variable L1 L2)
    (<span class="org-keyword">let</span> ((result (div (make-polynomial variable L1)
                       (make-polynomial variable L2))))
      (term-list (contents (cadr result)))))

  (<span class="org-keyword">define</span> (<span class="org-function-name">gcd-terms</span> variable L1 L2)
    (<span class="org-keyword">if</span> (<span class="org-keyword">or</span> (empty-termlist? L2)
            (=zero? (make-polynomial variable L2)))
        L1
        (gcd-terms variable L2 (remainder-terms variable L1 L2))))

  (<span class="org-keyword">define</span> (<span class="org-function-name">gcd-poly</span> p1 p2)
    (<span class="org-keyword">if</span> (same-variable? (variable p1) (variable p2))
        (<span class="org-keyword">let</span> ((variable (variable p1)))
          (make-polynomial variable (gcd-terms variable
                                               (term-list p1)
                                               (term-list p2))))
        (error <span class="org-string">"Polys not in same var: GCD-POLY"</span>)))

  (<span class="org-keyword">define</span> (<span class="org-function-name">gcd</span> a b)
    (<span class="org-keyword">if</span> (= b 0)
        a
        (gcd b (remainder a b))))

  (<span class="org-keyword">define</span> (<span class="org-function-name">gcd-scheme-number</span> a b)
    (attach-tag 'scheme-number
                (gcd a b)))

  (put 'greatest-common-divisor
       '(polynomial polynomial)
       gcd-poly)

  (put 'greatest-common-divisor
       '(scheme-number scheme-number)
       gcd-scheme-number))

(<span class="org-keyword">define</span> (<span class="org-function-name">greatest-common-divisor</span> n1 n2)
  (apply-generic 'greatest-common-divisor n1 n2))

(<span class="org-keyword">define</span> (<span class="org-function-name">install-rational-simplifying-make-package</span>)
  (<span class="org-keyword">define</span> (<span class="org-function-name">make-rat</span> n d)
    (<span class="org-keyword">let</span> ((g (greatest-common-divisor n d)))
      (cons (div n g) (div d g))))
  (put 'make 'rational
       (<span class="org-keyword">lambda</span> (n d)
         (attach-tag 'rational (make-rat n d)))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(include <span class="org-string">"polynomial.scm"</span>)
(include <span class="org-string">"polynomial-sub.scm"</span>)
(include <span class="org-string">"polynomial-div.scm"</span>)
(include <span class="org-string">"rational-generic.scm"</span>)
(include <span class="org-string">"greatest-common-divisor.scm"</span>)

(install-scheme-number-package)
(install-rational-package)
(install-rational-simplifying-make-package)
(install-complex-package)
(install-negation-package)
(install-polynomial-package)
(install-polynomial-sub-package)
(install-polynomial-div-package)
(install-zero-package)
(install-greatest-common-divisor-package)

(<span class="org-keyword">let</span> ((p1 (make-polynomial 'x '((4 1) (3 -1) (2 -2) (1 2))))
      (p2 (make-polynomial 'x '((3 1) (1 -1)))))
  (test '(polynomial x (2 -1) (1 1))
        (greatest-common-divisor p1 p2)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-141" class="outline-2">
<h2 id="sec-141"><span class="section-number-2">141</span> <span class="done DONE">DONE</span> 2.95</h2>
<div class="outline-text-2" id="text-141">
<div class="org-src-container">

<pre class="src src-scheme">(use debug sicp test)

(include <span class="org-string">"polynomial.scm"</span>)
(include <span class="org-string">"polynomial-sub.scm"</span>)
(include <span class="org-string">"polynomial-div.scm"</span>)
(include <span class="org-string">"rational-generic.scm"</span>)
(include <span class="org-string">"greatest-common-divisor.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">install-greatest-common-divisor-package</span>)
  <span class="org-comment-delimiter">;; </span><span class="org-comment">Copied, unfortunately, from the polynomial package</span>
  (<span class="org-keyword">define</span> (<span class="org-function-name">make-poly</span> variable term-list) (cons variable term-list))
  (<span class="org-keyword">define</span> (<span class="org-function-name">variable</span> p) (car p))
  (<span class="org-keyword">define</span> (<span class="org-function-name">term-list</span> p) (cdr p))
  (<span class="org-keyword">define</span> <span class="org-function-name">variable?</span> symbol?)

  (<span class="org-keyword">define</span> (<span class="org-function-name">same-variable?</span> v1 v2)
    (<span class="org-keyword">and</span> (variable? v1) (variable? v2) (eq? v1 v2)))
  (<span class="org-keyword">define</span> (<span class="org-function-name">adjoin-term</span> term term-list)
    (<span class="org-keyword">if</span> (=zero? (coeff term))
        term-list
        (cons term term-list)))
  (<span class="org-keyword">define</span> (<span class="org-function-name">the-empty-termlist</span>) '())
  (<span class="org-keyword">define</span> (<span class="org-function-name">first-term</span> term-list) (car term-list))
  (<span class="org-keyword">define</span> (<span class="org-function-name">rest-terms</span> term-list) (cdr term-list))
  (<span class="org-keyword">define</span> (<span class="org-function-name">empty-termlist?</span> term-list) (null? term-list))
  (<span class="org-keyword">define</span> (<span class="org-function-name">make-term</span> order coeff) (list order coeff))
  (<span class="org-keyword">define</span> (<span class="org-function-name">order</span> term) (car term))
  (<span class="org-keyword">define</span> (<span class="org-function-name">coeff</span> term) (cadr term))
  (<span class="org-keyword">define</span> (<span class="org-function-name">tag</span> p) (attach-tag 'polynomial p))

  (<span class="org-keyword">define</span> (<span class="org-function-name">remainder-terms</span> variable L1 L2)
    (<span class="org-keyword">let</span> ((result (div (make-polynomial variable L1)
                       (make-polynomial variable L2))))
      (term-list (contents (cadr result)))))

  (trace remainder-terms)

  (<span class="org-keyword">define</span> (<span class="org-function-name">gcd-terms</span> variable L1 L2)
    (<span class="org-keyword">if</span> (<span class="org-keyword">or</span> (empty-termlist? L2)
            (=zero? (make-polynomial variable L2)))
        L1
        (gcd-terms variable L2 (remainder-terms variable L1 L2))))

  (trace gcd-terms)

  (<span class="org-keyword">define</span> (<span class="org-function-name">gcd-poly</span> p1 p2)
    (<span class="org-keyword">if</span> (same-variable? (variable p1) (variable p2))
        (<span class="org-keyword">let</span> ((variable (variable p1)))
          (make-polynomial variable (gcd-terms variable
                                               (term-list p1)
                                               (term-list p2))))
        (error <span class="org-string">"Polys not in same var: GCD-POLY"</span>)))

  (<span class="org-keyword">define</span> (<span class="org-function-name">gcd</span> a b)
    (<span class="org-keyword">if</span> (= b 0)
        a
        (gcd b (remainder a b))))

  (<span class="org-keyword">define</span> (<span class="org-function-name">gcd-scheme-number</span> a b)
    (attach-tag 'scheme-number
                (gcd a b)))

  (put 'greatest-common-divisor
       '(polynomial polynomial)
       gcd-poly)

  (put 'greatest-common-divisor
       '(scheme-number scheme-number)
       gcd-scheme-number))

(install-scheme-number-package)
(install-rational-package)
(install-rational-simplifying-make-package)
(install-complex-package)
(install-negation-package)
(install-polynomial-package)
(install-polynomial-sub-package)
(install-polynomial-div-package)
(install-zero-package)
(install-greatest-common-divisor-package)

(<span class="org-keyword">let</span> ((p1 (make-polynomial 'x '((2 1) (1 -2) (0 1))))
      (p2 (make-polynomial 'x '((2 11) (0 7))))
      (p3 (make-polynomial 'x '((1 13) (0 5)))))
  (<span class="org-keyword">let</span> ((q1 (mul p1 p2))
        (q2 (mul p1 p3)))
    (test-assert (not (equal? p1 (greatest-common-divisor q1 q2))))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-142" class="outline-2">
<h2 id="sec-142"><span class="section-number-2">142</span> <span class="done DONE">DONE</span> 2.96</h2>
<div class="outline-text-2" id="text-142">
<p>
We ended up defining an ad-hoc <code>mul</code> between scheme-numbers and
polynomials (though this should have been taken care of by
coercion); and it turns out that <code>greatest-common-divisor</code> is
pathological for the zero-case (otherwise, we could have used zero
as an identity when folding over GCD).
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp srfi-1 test)

(include <span class="org-string">"polynomial.scm"</span>)
(include <span class="org-string">"polynomial-sub.scm"</span>)
(include <span class="org-string">"polynomial-div.scm"</span>)
(include <span class="org-string">"rational-generic.scm"</span>)
(include <span class="org-string">"greatest-common-divisor.scm"</span>)

(<span class="org-keyword">define</span> <span class="org-function-name">remove-common-factors?</span> (make-parameter #f))

(<span class="org-keyword">define</span> (<span class="org-function-name">install-greatest-common-divisor-package</span>)
  <span class="org-comment-delimiter">;; </span><span class="org-comment">Copied, unfortunately, from the polynomial package</span>
  (<span class="org-keyword">define</span> (<span class="org-function-name">make-poly</span> variable term-list) (cons variable term-list))
  (<span class="org-keyword">define</span> (<span class="org-function-name">variable</span> p) (car p))
  (<span class="org-keyword">define</span> (<span class="org-function-name">term-list</span> p) (cdr p))
  (<span class="org-keyword">define</span> <span class="org-function-name">variable?</span> symbol?)

  (<span class="org-keyword">define</span> (<span class="org-function-name">same-variable?</span> v1 v2)
    (<span class="org-keyword">and</span> (variable? v1) (variable? v2) (eq? v1 v2)))
  (<span class="org-keyword">define</span> (<span class="org-function-name">adjoin-term</span> term term-list)
    (<span class="org-keyword">if</span> (=zero? (coeff term))
        term-list
        (cons term term-list)))
  (<span class="org-keyword">define</span> (<span class="org-function-name">the-empty-termlist</span>) '())
  (<span class="org-keyword">define</span> (<span class="org-function-name">first-term</span> term-list) (car term-list))
  (<span class="org-keyword">define</span> (<span class="org-function-name">rest-terms</span> term-list) (cdr term-list))
  (<span class="org-keyword">define</span> (<span class="org-function-name">empty-termlist?</span> term-list) (null? term-list))
  (<span class="org-keyword">define</span> (<span class="org-function-name">make-term</span> order coeff) (list order coeff))
  (<span class="org-keyword">define</span> (<span class="org-function-name">order</span> term) (car term))
  (<span class="org-keyword">define</span> (<span class="org-function-name">coeff</span> term) (cadr term))
  (<span class="org-keyword">define</span> (<span class="org-function-name">tag</span> p) (attach-tag 'polynomial p))

  (<span class="org-keyword">define</span> (<span class="org-function-name">integerizing-factor</span> L1 L2)
    (<span class="org-keyword">let</span> ((o1 (order (first-term L1)))
          (o2 (order (first-term L2)))
          (c (coeff (first-term L2))))
      (expt c (+ 1 (- o1 o2)))))

  (<span class="org-keyword">define</span> (<span class="org-function-name">pseudoremainder-terms</span> variable L1 L2)
    (<span class="org-keyword">let</span> ((result (div (mul (integerizing-factor L1 L2)
                            (make-polynomial variable L1))
                       (make-polynomial variable L2))))
      (term-list (contents (cadr result)))))

  (<span class="org-keyword">define</span> (<span class="org-function-name">remove-common-factors</span> L)
    (<span class="org-keyword">let*</span> ((factors (<span class="org-keyword">map</span> coeff L))
           (gcd (fold greatest-common-divisor
                      <span class="org-comment-delimiter">;; </span><span class="org-comment">This is a little </span><span class="org-warning">hack</span><span class="org-comment">y; with out-of-the box</span>
                      <span class="org-comment-delimiter">;; </span><span class="org-comment">gcd, we could have given 0 as the seed.</span>
                      (car factors)
                      (cdr factors))))
      (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (term) (make-term (order term)
                                (div (coeff term) gcd))) L)))

  (<span class="org-keyword">define</span> (<span class="org-function-name">gcd-terms</span> variable L1 L2)
    (<span class="org-keyword">if</span> (<span class="org-keyword">or</span> (empty-termlist? L2)
            (=zero? (make-polynomial variable L2)))
        (<span class="org-keyword">if</span> (remove-common-factors?)
            (remove-common-factors L1)
            L1)
        (gcd-terms variable L2 (pseudoremainder-terms variable L1 L2))))

  (<span class="org-keyword">define</span> (<span class="org-function-name">gcd-poly</span> p1 p2)
    (<span class="org-keyword">if</span> (same-variable? (variable p1) (variable p2))
        (<span class="org-keyword">let</span> ((variable (variable p1)))
          (make-polynomial variable (gcd-terms variable
                                               (term-list p1)
                                               (term-list p2))))
        (error <span class="org-string">"Polys not in same var: GCD-POLY"</span>)))

  (<span class="org-keyword">define</span> (<span class="org-function-name">gcd-scheme-number</span> a b)
    (attach-tag 'scheme-number
                (<span class="org-keyword">if</span> (= b 0)
                    0
                    (gcd b (remainder a b)))))

  <span class="org-comment-delimiter">;; </span><span class="org-comment">This should be part of a general coercion; let's fill it in</span>
  <span class="org-comment-delimiter">;; </span><span class="org-comment">ad-hoc here, though. To make this more general, should probably</span>
  <span class="org-comment-delimiter">;; </span><span class="org-comment">also use e.g. adjoin-term instead of map (that would accomodate</span>
  <span class="org-comment-delimiter">;; </span><span class="org-comment">both sparse and dense representations).</span>
  (put 'mul
       '(scheme-number polynomial)
       (<span class="org-keyword">lambda</span> (n p)
         (make-polynomial
          (variable p)
          (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (term)
                 (make-term (order term)
                            (mul n (coeff term))))
               (term-list p)))))

  (put 'greatest-common-divisor
       '(polynomial polynomial)
       gcd-poly)

  (put 'greatest-common-divisor
       '(scheme-number scheme-number)
       gcd-scheme-number))

(install-scheme-number-package)
(install-rational-package)
(install-rational-simplifying-make-package)
(install-complex-package)
(install-negation-package)
(install-polynomial-package)
(install-polynomial-sub-package)
(install-polynomial-div-package)
(install-zero-package)
(install-greatest-common-divisor-package)

(<span class="org-keyword">let</span> ((p1 (make-polynomial 'x '((2 1) (1 -2) (0 1))))
      (p2 (make-polynomial 'x '((2 11) (0 7))))
      (p3 (make-polynomial 'x '((1 13) (0 5)))))
  (<span class="org-keyword">let</span> ((q1 (mul p1 p2))
        (q2 (mul p1 p3)))
    (test '(polynomial x (2 1458) (1 -2916) (0 1458))
          (greatest-common-divisor q1 q2))
    (parameterize ((remove-common-factors? #t))
      (test p1 (greatest-common-divisor q1 q2)))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-143" class="outline-2">
<h2 id="sec-143"><span class="section-number-2">143</span> <span class="done DONE">DONE</span> 2.97</h2>
<div class="outline-text-2" id="text-143">
<p>
In order to make this work, we generalized <code>integerizing-factor</code> but
still had to redefine the rational package to use the simplifying
<code>make-rational</code>.
</p>

<p>
We renamed the top-level procedure <code>reduce</code> to <code>simplify</code> so as not
to contradict SRFI-1.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp srfi-1 test)

(include <span class="org-string">"polynomial.scm"</span>)
(include <span class="org-string">"polynomial-sub.scm"</span>)
(include <span class="org-string">"polynomial-div.scm"</span>)
(include <span class="org-string">"rational-generic.scm"</span>)
(include <span class="org-string">"greatest-common-divisor.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">install-reduction-package</span>)
  <span class="org-comment-delimiter">;; </span><span class="org-comment">Copied, unfortunately, from the polynomial package</span>
  (<span class="org-keyword">define</span> (<span class="org-function-name">make-poly</span> variable term-list) (cons variable term-list))
  (<span class="org-keyword">define</span> (<span class="org-function-name">variable</span> p) (car p))
  (<span class="org-keyword">define</span> (<span class="org-function-name">term-list</span> p) (cdr p))
  (<span class="org-keyword">define</span> <span class="org-function-name">variable?</span> symbol?)

  (<span class="org-keyword">define</span> (<span class="org-function-name">same-variable?</span> v1 v2)
    (<span class="org-keyword">and</span> (variable? v1) (variable? v2) (eq? v1 v2)))
  (<span class="org-keyword">define</span> (<span class="org-function-name">adjoin-term</span> term term-list)
    (<span class="org-keyword">if</span> (=zero? (coeff term))
        term-list
        (cons term term-list)))
  (<span class="org-keyword">define</span> (<span class="org-function-name">the-empty-termlist</span>) '())
  (<span class="org-keyword">define</span> (<span class="org-function-name">first-term</span> term-list) (car term-list))
  (<span class="org-keyword">define</span> (<span class="org-function-name">rest-terms</span> term-list) (cdr term-list))
  (<span class="org-keyword">define</span> (<span class="org-function-name">empty-termlist?</span> term-list) (null? term-list))
  (<span class="org-keyword">define</span> (<span class="org-function-name">make-term</span> order coeff) (list order coeff))
  (<span class="org-keyword">define</span> (<span class="org-function-name">order</span> term) (car term))
  (<span class="org-keyword">define</span> (<span class="org-function-name">coeff</span> term) (cadr term))
  (<span class="org-keyword">define</span> (<span class="org-function-name">tag</span> p) (attach-tag 'polynomial p))

  (<span class="org-keyword">define</span> (<span class="org-function-name">integerizing-factor</span> o1 t2)
    (<span class="org-keyword">let</span> ((o2 (order t2))
          (c (coeff t2)))
      (expt c (+ 1 (- o1 o2)))))

  (<span class="org-keyword">define</span> (<span class="org-function-name">pseudoremainder-terms</span> variable L1 L2)
    (<span class="org-keyword">let</span> ((result (div (mul (integerizing-factor
                             (order (first-term L1))
                             (first-term L2))
                            (make-polynomial variable L1))
                       (make-polynomial variable L2))))
      (term-list (contents (cadr result)))))

  (<span class="org-keyword">define</span> (<span class="org-function-name">greatest-common-divisor-coefficients</span> L)
    (<span class="org-keyword">let</span> ((factors (<span class="org-keyword">map</span> coeff L)))
      (fold greatest-common-divisor
            (car factors)
            (cdr factors))))

  (<span class="org-keyword">define</span> (<span class="org-function-name">divide-through</span> factor L)
    (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (term) (make-term (order term)
                              (div (coeff term) factor)))
         L))

  (<span class="org-keyword">define</span> (<span class="org-function-name">remove-common-factors</span> L)
    (<span class="org-keyword">let</span> ((gcd (greatest-common-divisor-coefficients L)))      
      (divide-through gcd L)))

  (<span class="org-keyword">define</span> (<span class="org-function-name">gcd-terms</span> variable L1 L2)
    (<span class="org-keyword">if</span> (<span class="org-keyword">or</span> (empty-termlist? L2)
            (=zero? (make-polynomial variable L2)))
        (remove-common-factors L1)
        (gcd-terms variable L2 (pseudoremainder-terms variable L1 L2))))

  (<span class="org-keyword">define</span> (<span class="org-function-name">reduce-terms</span> variable L1 L2)
    (<span class="org-keyword">let*</span> ((gcd-terms (gcd-terms variable L1 L2))
           (factor (integerizing-factor
                    (max (order (first-term L1))
                         (order (first-term L2)))
                    (first-term gcd-terms))))
      (<span class="org-keyword">let</span> ((gcd-coefficients
             (greatest-common-divisor-coefficients
              (append L1 L2))))
        (<span class="org-keyword">let</span> ((reduce
               (<span class="org-keyword">lambda</span> (L)
                 (divide-through
                  gcd-coefficients
                  (term-list
                   (contents
                    (car
                     (div (mul factor (make-polynomial variable L))
                          (make-polynomial variable gcd-terms)))))))))
          (list (reduce L1)
                (reduce L2))))))

  (<span class="org-keyword">define</span> (<span class="org-function-name">reduce-poly</span> p1 p2)
    (<span class="org-keyword">if</span> (same-variable? (variable p1) (variable p2))
        (<span class="org-keyword">let*</span> ((variable (variable p1))
               (term-lists (reduce-terms variable
                                         (term-list p1)
                                         (term-list p2))))
          (list (make-polynomial variable (car term-lists))
                (make-polynomial variable (cadr term-lists))))
        (error <span class="org-string">"Polys not in same var: REDUCE-POLY"</span>)))

  (<span class="org-keyword">define</span> (<span class="org-function-name">gcd-poly</span> p1 p2)
    (<span class="org-keyword">if</span> (same-variable? (variable p1) (variable p2))
        (<span class="org-keyword">let</span> ((variable (variable p1)))
          (make-polynomial variable (gcd-terms variable
                                               (term-list p1)
                                               (term-list p2))))
        (error <span class="org-string">"Polys not in same var: GCD-POLY"</span>)))

  (<span class="org-keyword">define</span> (<span class="org-function-name">gcd-scheme-number</span> a b)
    (attach-tag 'scheme-number
                (<span class="org-keyword">if</span> (= b 0)
                    0
                    (gcd b (remainder a b)))))

  <span class="org-comment-delimiter">;; </span><span class="org-comment">This should be part of a general coercion; let's fill it in</span>
  <span class="org-comment-delimiter">;; </span><span class="org-comment">ad-hoc here, though. To make this more general, should probably</span>
  <span class="org-comment-delimiter">;; </span><span class="org-comment">also use e.g. adjoin-term instead of map (that would accomodate</span>
  <span class="org-comment-delimiter">;; </span><span class="org-comment">both sparse and dense representations).</span>
  (put 'mul
       '(scheme-number polynomial)
       (<span class="org-keyword">lambda</span> (n p)
         (make-polynomial
          (variable p)
          (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (term)
                 (make-term (order term)
                            (mul n (coeff term))))
               (term-list p)))))

  (put 'greatest-common-divisor
       '(polynomial polynomial)
       gcd-poly)

  (put 'greatest-common-divisor
       '(scheme-number scheme-number)
       gcd-scheme-number)

  (put 'simplify
       '(polynomial polynomial)
       reduce-poly)

  (put 'simplify
     '(scheme-number scheme-number)
     (<span class="org-keyword">lambda</span> (n d)
       (<span class="org-keyword">let</span> ((g (gcd n d)))
         (list (/ n g) (/ d g)))))) 

(<span class="org-keyword">define</span> (<span class="org-function-name">simplify</span> x y)
  (apply-generic 'simplify x y))

(<span class="org-keyword">define</span> (<span class="org-function-name">install-simplifying-rational-package</span>)
  <span class="org-comment-delimiter">;; </span><span class="org-comment">internal procedures</span>
  (<span class="org-keyword">define</span> (<span class="org-function-name">numer</span> x) (car x))
  (<span class="org-keyword">define</span> (<span class="org-function-name">denom</span> x) (cdr x))

  (<span class="org-keyword">define</span> (<span class="org-function-name">make-rat</span> n d)
    (apply cons (simplify n d)))
  (<span class="org-keyword">define</span> (<span class="org-function-name">add-rat</span> x y)
    (make-rat (add (mul (numer x) (denom y))
                   (mul (numer y) (denom x)))
              (mul (denom x) (denom y))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">sub-rat</span> x y)
    (make-rat (sub (mul (numer x) (denom y))
                   (mul (numer y) (denom x)))
              (mul (denom x) (denom y))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">mul-rat</span> x y)
    (make-rat (mul (numer x) (numer y))
              (mul (denom x) (denom y))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">div-rat</span> x y)
    (make-rat (mul (numer x) (denom y))
              (mul (denom x) (numer y))))
  <span class="org-comment-delimiter">;; </span><span class="org-comment">interface to rest of the system</span>
  (<span class="org-keyword">define</span> (<span class="org-function-name">tag</span> x) (attach-tag 'rational x))
  (put 'add '(rational rational)
       (<span class="org-keyword">lambda</span> (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (<span class="org-keyword">lambda</span> (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (<span class="org-keyword">lambda</span> (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (<span class="org-keyword">lambda</span> (x y) (tag (div-rat x y))))
  (put 'make 'rational
       (<span class="org-keyword">lambda</span> (n d) (tag (make-rat n d))))
  (put 'numer '(rational) numer)
  (put 'denom '(rational) denom)
  'done)

(install-scheme-number-package)
(install-rational-package)
(install-rational-simplifying-make-package)
(install-complex-package)
(install-negation-package)
(install-polynomial-package)
(install-polynomial-sub-package)
(install-polynomial-div-package)
(install-zero-package)
(install-reduction-package)
(install-simplifying-rational-package)

(<span class="org-keyword">let</span> ((p1 (make-polynomial 'x '((1 1) (0 1))))
      (p2 (make-polynomial 'x '((3 1) (0 -1))))
      (p3 (make-polynomial 'x '((1 1))))
      (p4 (make-polynomial 'x '((2 1) (0 -1)))))
  (<span class="org-keyword">let</span> ((rf1 (make-rational p1 p2))
        (rf2 (make-rational p3 p4)))
    (test '(rational
            (polynomial x (3 1) (2 2) (1 3) (0 1) (0 0))
            polynomial x (4 1) (3 1) (1 -1) (0 -1) (0 0))
          (add rf1 rf2))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-144" class="outline-2">
<h2 id="sec-144"><span class="section-number-2">144</span> <span class="done DONE">DONE</span> 3.1</h2>
<div class="outline-text-2" id="text-144">
<p>
We’re using the parameter in the procedure as our captured variable.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">make-accumulator</span> accumulatum)
  (<span class="org-keyword">lambda</span> (accumulandum)
    (set! accumulatum (+ accumulandum accumulatum))
    accumulatum))

(<span class="org-keyword">let</span> ((accumulator (make-accumulator 5)))
  (test 10 (accumulator 5))
  (test 15 (accumulator 5)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-145" class="outline-2">
<h2 id="sec-145"><span class="section-number-2">145</span> <span class="done DONE">DONE</span> 3.2</h2>
<div class="outline-text-2" id="text-145">
<p>
Let’s use the <a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%25_idx_114">case</a>-syntax.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">make-monitored</span> f)
  (<span class="org-keyword">let</span> ((calls 0))
    (<span class="org-keyword">lambda</span> (message)
      (<span class="org-keyword">case</span> message
        ((how-many-calls?) calls)
        ((reset-count) (set! calls 0))
        (<span class="org-keyword">else</span> (set! calls (+ calls 1))
              (f message))))))

(<span class="org-keyword">let</span> ((s (make-monitored sqrt)))
  (test 10.0 (s 100))
  (test 1 (s 'how-many-calls?)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-146" class="outline-2">
<h2 id="sec-146"><span class="section-number-2">146</span> <span class="done DONE">DONE</span> 3.3</h2>
<div class="outline-text-2" id="text-146">
<p>
Let’s start with the amount-lambda and do the logic therein.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">make-account</span> balance account-password)
  (<span class="org-keyword">lambda</span> (password message)
    (<span class="org-keyword">lambda</span> (amount)
      (<span class="org-keyword">if</span> (eq? account-password password)
          (<span class="org-keyword">case</span> message
            ((withdraw)
             (<span class="org-keyword">if</span> (&gt;= balance amount)
                 (<span class="org-keyword">begin</span> (set! balance (- balance amount))
                        balance)
                 <span class="org-string">"Insufficient funds"</span>))
            ((deposit)
             (set! balance (+ balance amount))
             balance)
            (<span class="org-keyword">else</span> (error <span class="org-string">"Unknown request: MAKE-ACCOUNT"</span> message)))
          <span class="org-string">"Incorrect password"</span>))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(include <span class="org-string">"make-account.scm"</span>)

(<span class="org-keyword">let</span> ((acc (make-account 100 'password)))
  (test 60 ((acc 'password 'withdraw) 40))
  (test <span class="org-string">"Incorrect password"</span> ((acc 'not-password 'withdraw) 40)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-147" class="outline-2">
<h2 id="sec-147"><span class="section-number-2">147</span> <span class="done DONE">DONE</span> 3.4</h2>
<div class="outline-text-2" id="text-147">
<div class="org-src-container">

<pre class="src src-scheme">(use miscmacros test)

(<span class="org-keyword">define</span> <span class="org-function-name">allowed-incorrect-accesses</span> (make-parameter 7))

(<span class="org-keyword">define</span> (<span class="org-function-name">make-account</span> balance account-password)
  (<span class="org-keyword">let</span> ((incorrect-accesses (allowed-incorrect-accesses)))
    (<span class="org-keyword">lambda</span> (password message)
      (<span class="org-keyword">lambda</span> (amount)
        (<span class="org-keyword">if</span> (eq? account-password password)
            (<span class="org-keyword">begin</span>
              (set! incorrect-accesses (allowed-incorrect-accesses))
              (<span class="org-keyword">case</span> message
                ((withdraw)
                 (<span class="org-keyword">if</span> (&gt;= balance amount)
                     (<span class="org-keyword">begin</span> (set! balance (- balance amount))
                            balance)
                     <span class="org-string">"Insufficient funds"</span>))
                ((deposit)
                 (set! balance (+ balance amount))
                 balance)
                (<span class="org-keyword">else</span> (error <span class="org-string">"Unknown request: MAKE-ACCOUNT"</span> message))))
            (<span class="org-keyword">begin</span>
              (set! incorrect-accesses (- incorrect-accesses 1))
              (<span class="org-keyword">if</span> (negative? incorrect-accesses)
                  <span class="org-string">"Call the cops"</span>
                  <span class="org-string">"Incorrect password"</span>)))))))

(<span class="org-keyword">let</span> ((acc (make-account 100 'password)))
  (dotimes (i 7)
    (test <span class="org-string">"Incorrect password"</span> ((acc 'not-password 'withdraw) 40)))
  (test <span class="org-string">"Call the cops"</span> ((acc 'not-password 'withdraw) 40)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-148" class="outline-2">
<h2 id="sec-148"><span class="section-number-2">148</span> <span class="done DONE">DONE</span> 3.5</h2>
<div class="outline-text-2" id="text-148">
<p>
We can simplify the <code>pi-predicate</code> to test \(x\) and \(y\) against 1.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use random-bsd sicp test)

(<span class="org-keyword">define</span> (<span class="org-function-name">random-in-range</span> low high)
  (<span class="org-keyword">let</span> ((range (- high low)))
    (+ low (* (random-real) range))))

(<span class="org-keyword">define</span> (<span class="org-function-name">monte-carlo</span> trials experiment)
  (<span class="org-keyword">let</span> <span class="org-function-name">iter</span> ((trials-remaining trials)
             (trials-passed 0))
    (<span class="org-keyword">cond</span> ((zero? trials-remaining)
           (/ trials-passed trials))
          ((experiment)
           (iter (- trials-remaining 1)
                 (+ trials-passed 1)))
          (<span class="org-keyword">else</span>
           (iter (- trials-remaining 1)
                 trials-passed)))))

(<span class="org-keyword">define</span> (<span class="org-function-name">estimate-integral</span> p x1 x2 y1 y2 trials)
  (monte-carlo
   trials
   (<span class="org-keyword">lambda</span> ()
     (<span class="org-keyword">let</span> ((x (random-in-range x1 x2))
           (y (random-in-range y1 y2)))
       (p x y)))))

(<span class="org-keyword">define</span> (<span class="org-function-name">pi-predicate</span> x y)
  <span class="org-comment-delimiter">;; </span><span class="org-comment">Can also test against x instead of 1 - x.</span>
  (&lt;= (+ (square (- 1 x))
         (square (- 1 y)))
      <span class="org-comment-delimiter">;; </span><span class="org-comment">Superfluous square</span>
      (square 1)))

(<span class="org-keyword">define</span> (<span class="org-function-name">estimate-pi</span> trials)
  (* 4 (estimate-integral pi-predicate 0 1 0 1 trials)))

(parameterize ((current-test-epsilon 0.01))
  (test 3.14 (estimate-pi 10000)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-149" class="outline-2">
<h2 id="sec-149"><span class="section-number-2">149</span> <span class="done DONE">DONE</span> 3.6</h2>
<div class="outline-text-2" id="text-149">
<p>
This uses the built-in <code>random</code> and <code>randomize</code> from Chicken.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use extras test)

(<span class="org-keyword">define</span> (<span class="org-function-name">rand</span> message)
  (<span class="org-keyword">lambda</span> (n)
    (<span class="org-keyword">case</span> message
      ((generate) (random n))
      ((reset) (randomize n)))))

((rand 'reset) 100)
(test 1 ((rand 'generate) 6))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-150" class="outline-2">
<h2 id="sec-150"><span class="section-number-2">150</span> <span class="done DONE">DONE</span> 3.7</h2>
<div class="outline-text-2" id="text-150">
<p>
We didn’t end up modifying the original <code>make-account</code> to accomodate
the <code>make-joint</code>.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(include <span class="org-string">"make-account.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">make-joint</span> account old-password new-password)
  (<span class="org-keyword">lambda</span> (password message)
    (<span class="org-keyword">if</span> (eq? password new-password)
        (account old-password message)
        (<span class="org-keyword">lambda</span> (amount) <span class="org-doc">"Incorrect password"</span>))))

(<span class="org-keyword">let*</span> ((peter (make-account 100 'old-password))
       (paul (make-joint peter 'old-password 'new-password)))
  (test 80 ((peter 'old-password 'withdraw) 20))
  (test 60 ((paul 'new-password 'withdraw) 20))
  (test <span class="org-string">"Incorrect password"</span> ((peter 'not-old-password 'withdraw) 20))
  (test <span class="org-string">"Incorrect password"</span> ((paul 'not-new-password 'withdraw) 20)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-151" class="outline-2">
<h2 id="sec-151"><span class="section-number-2">151</span> <span class="done DONE">DONE</span> 3.8</h2>
<div class="outline-text-2" id="text-151">
<p>
Does it defy “simple” to have a constructor for <code>f</code>?
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">make-f</span>)
  (<span class="org-keyword">let</span> ((init #f))
    (<span class="org-keyword">lambda</span> (x)
      (<span class="org-keyword">if</span> init
          0
          (<span class="org-keyword">begin</span>
            (set! init x)
            init)))))

<span class="org-comment-delimiter">;; </span><span class="org-comment">Left-to-right</span>
(<span class="org-keyword">let</span> ((f (make-f)))
  (test 0 (+ (f 0) (f 1))))

<span class="org-comment-delimiter">;; </span><span class="org-comment">Right-to-left</span>
(<span class="org-keyword">let</span> ((f (make-f)))
  (test 1 (+ (f 1) (f 0))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-152" class="outline-2">
<h2 id="sec-152"><span class="section-number-2">152</span> <span class="done DONE">DONE</span> 3.9</h2>
<div class="outline-text-2" id="text-152">
<p>
For completeness, should have included subtraction and addition;
only took factorial and multiplication into consideration.
</p>


<div class="figure">
<p><img src="./3.9-recursive.jpg" alt="3.9-recursive.jpg" />
</p>
<p><span class="figure-number">Figure 21:</span> Recursive factorial</p>
</div>


<div class="figure">
<p><img src="./3.9-iterative.jpg" alt="3.9-iterative.jpg" />
</p>
<p><span class="figure-number">Figure 22:</span> Iterative factorial</p>
</div>
</div>
</div>
<div id="outline-container-sec-153" class="outline-2">
<h2 id="sec-153"><span class="section-number-2">153</span> <span class="done DONE">DONE</span> 3.10</h2>
<div class="outline-text-2" id="text-153">

<div class="figure">
<p><img src="./3.10.jpg" alt="3.10.jpg" />
</p>
<p><span class="figure-number">Figure 23:</span> Environment model for <code>make-withdraw</code></p>
</div>
</div>
</div>
<div id="outline-container-sec-154" class="outline-2">
<h2 id="sec-154"><span class="section-number-2">154</span> <span class="done DONE">DONE</span> 3.11</h2>
<div class="outline-text-2" id="text-154">
<p>
The local state for <code>acc</code> is kept in <code>E1</code>; the local state for <code>acc2</code>
would be kept in a separate environment <code>E4</code> that resembles <code>E1</code>.
</p>

<p>
This is implementation-dependent; but the part of the environment
that would be shared between <code>acc</code> and <code>acc2</code> would be the body of
the code for the external and internal functions.
</p>


<div class="figure">
<p><img src="./3.11.jpg" alt="3.11.jpg" />
</p>
<p><span class="figure-number">Figure 24:</span> Environment model for <code>make-account</code></p>
</div>
</div>
</div>
<div id="outline-container-sec-155" class="outline-2">
<h2 id="sec-155"><span class="section-number-2">155</span> <span class="done DONE">DONE</span> 3.12</h2>
<div class="outline-text-2" id="text-155">

<div class="figure">
<p><img src="./3.12.jpg" alt="3.12.jpg" />
</p>
<p><span class="figure-number">Figure 25:</span> Box-and-pointer for <code>w</code>, <code>x</code>, <code>y</code> and <code>z</code></p>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">append!</span> x y)
  (set-cdr! (last-pair x) y)
  x)

(<span class="org-keyword">define</span> (<span class="org-function-name">last-pair</span> x)
  (<span class="org-keyword">if</span> (null? (cdr x)) x (last-pair (cdr x))))

(<span class="org-keyword">define</span> <span class="org-function-name">x</span> '(a b))
(<span class="org-keyword">define</span> <span class="org-function-name">y</span> '(c d))
(<span class="org-keyword">define</span> <span class="org-function-name">z</span> (append x y))
(test '(b) (cdr x))

(<span class="org-keyword">define</span> <span class="org-function-name">w</span> (append! x y))
(test '(b c d) (cdr x))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-156" class="outline-2">
<h2 id="sec-156"><span class="section-number-2">156</span> <span class="done DONE">DONE</span> 3.13</h2>
<div class="outline-text-2" id="text-156">

<div class="figure">
<p><img src="./3.13.jpg" alt="3.13.jpg" />
</p>
<p><span class="figure-number">Figure 26:</span> Box-and-pointer for cyclical <code>z</code></p>
</div>
</div>
</div>
<div id="outline-container-sec-157" class="outline-2">
<h2 id="sec-157"><span class="section-number-2">157</span> <span class="done DONE">DONE</span> 3.14</h2>
<div class="outline-text-2" id="text-157">

<div class="figure">
<p><img src="./3.14.jpg" alt="3.14.jpg" />
</p>
<p><span class="figure-number">Figure 27:</span> Box-and-pointer for mystery <code>v</code> and <code>w</code></p>
</div>
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">mystery</span> x)
  (<span class="org-keyword">let</span> <span class="org-function-name">loop</span> ((x x)
             (y '()))
    (<span class="org-keyword">if</span> (null? x)
        y
        (<span class="org-keyword">let</span> ((temp (cdr x)))
          (set-cdr! x y)
          (loop temp x)))))

(<span class="org-keyword">let*</span> ((v (list 'a 'b 'c 'd))
       (w (mystery v)))
  (test v '(a))
  (test w '(d c b a)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-158" class="outline-2">
<h2 id="sec-158"><span class="section-number-2">158</span> <span class="done DONE">DONE</span> 3.15</h2>
<div class="outline-text-2" id="text-158">

<div class="figure">
<p><img src="./3.15.jpg" alt="3.15.jpg" />  
</p>
<p><span class="figure-number">Figure 28:</span> Box-and-pointer for mystery <code>x</code>, <code>z1</code> and <code>z2</code> after <code>set-to-wow!</code></p>
</div>
</div>
</div>
<div id="outline-container-sec-159" class="outline-2">
<h2 id="sec-159"><span class="section-number-2">159</span> <span class="done DONE">DONE</span> 3.16</h2>
<div class="outline-text-2" id="text-159">
<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">count-pairs</span> x)
  (<span class="org-keyword">if</span> (not (pair? x))
      0
      (+ (count-pairs (car x))
         (count-pairs (cdr x))
         1)))

(test 3 (count-pairs '(1 2 3)))

(<span class="org-keyword">let*</span> ((x (cons 1 (cons 2 '()))))
  (test 5 (count-pairs (cons x x))))

(<span class="org-keyword">let*</span> ((x (cons 1 2))
       (y (cons x x)))
  (test 7 (count-pairs (cons y y))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-160" class="outline-2">
<h2 id="sec-160"><span class="section-number-2">160</span> <span class="done DONE">DONE</span> 3.17</h2>
<div class="outline-text-2" id="text-160">
<p>
Use hash-tables to check whether we’ve seen the node before.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use srfi-69 test)

(<span class="org-keyword">define</span> (<span class="org-function-name">count-pairs</span> x)
  (<span class="org-keyword">let</span> ((seen? (make-hash-table)))
    (<span class="org-keyword">let</span> <span class="org-function-name">iter</span> ((x x))
      (<span class="org-keyword">if</span> (not (pair? x))
          0
          (+ (iter (car x))
             (iter (cdr x))
             (<span class="org-keyword">if</span> (hash-table-ref/default seen? x #f)
                 0
                 (<span class="org-keyword">begin</span>
                   (hash-table-set! seen? x #t) 1)))))))

(<span class="org-keyword">let*</span> ((x (cons 1 2))
       (y (cons x x)))
  (test 3 (count-pairs (cons y y))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-161" class="outline-2">
<h2 id="sec-161"><span class="section-number-2">161</span> <span class="done DONE">DONE</span> 3.18</h2>
<div class="outline-text-2" id="text-161">
<div class="org-src-container">

<pre class="src src-scheme">(use srfi-1 srfi-69 test)

(<span class="org-keyword">define</span> (<span class="org-function-name">make-cycle</span> x)
  (set-cdr! (last-pair x) x)
  x)

(<span class="org-keyword">define</span> (<span class="org-function-name">cycle?</span> x)
  (<span class="org-keyword">let</span> ((seen? (make-hash-table)))
    (<span class="org-keyword">let</span> <span class="org-function-name">iter</span> ((x x))
      (<span class="org-keyword">and</span> (not (null? x))
           (<span class="org-keyword">or</span> (hash-table-ref/default seen? x #f)
               (<span class="org-keyword">begin</span>
                 (hash-table-set! seen? x #t)
                 (iter (cdr x))))))))

(test-assert (not (cycle? '(1 2 1))))
(test-assert (cycle? (make-cycle (list 1 2 1))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-162" class="outline-2">
<h2 id="sec-162"><span class="section-number-2">162</span> <span class="done DONE">DONE</span> 3.19</h2>
<div class="outline-text-2" id="text-162">
<p>
Use Floyd’s with the composition of <code>cdr</code>.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(<span class="org-keyword">define</span> (<span class="org-function-name">make-cycle</span> x)
  (set-cdr! (last-pair x) x)
  x)

(<span class="org-keyword">define</span> (<span class="org-function-name">cycle?</span> x)
  (<span class="org-keyword">let</span> <span class="org-function-name">iter</span> ((tortoise (cdr x))
             (hare (cddr x)))
    (<span class="org-keyword">and</span> (not (null? hare))
         (<span class="org-keyword">or</span> (eq? tortoise hare)
             (<span class="org-keyword">and</span> (not (null? (cdr hare)))
                  (iter (cdr tortoise) (cddr hare)))))))

(test-assert (not (cycle? '(1 2 1))))
(test-assert (cycle? (make-cycle (list 1 2 1))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-163" class="outline-2">
<h2 id="sec-163"><span class="section-number-2">163</span> <span class="done DONE">DONE</span> 3.20</h2>
<div class="outline-text-2" id="text-163">
<ul class="org-ul">
<li>CLOSING NOTE <span class="timestamp-wrapper"><span class="timestamp">[2014-10-13 Mon 16:19]</span></span> <br  />
    This doesn’t feel complete.
</li>
</ul>

<div class="figure">
<p><img src="./3.20.jpg" alt="3.20.jpg" />
</p>
<p><span class="figure-number">Figure 29:</span> Environment diagram for <code>set-car!</code> and <code>car</code></p>
</div>
</div>
</div>
<div id="outline-container-sec-164" class="outline-2">
<h2 id="sec-164"><span class="section-number-2">164</span> <span class="done DONE">DONE</span> 3.21</h2>
<div class="outline-text-2" id="text-164">
<div class="org-src-container">

<pre class="src src-scheme">(use ports sicp test)

(<span class="org-keyword">define</span> <span class="org-function-name">print-queue</span> (compose display car))

(<span class="org-keyword">define</span> <span class="org-function-name">q1</span> (make-queue))
(test <span class="org-string">"(a)"</span>
      (with-output-to-string (<span class="org-keyword">lambda</span> () (print-queue (insert-queue! q1 'a)))))
(test <span class="org-string">"(a b)"</span>
      (with-output-to-string (<span class="org-keyword">lambda</span> () (print-queue (insert-queue! q1 'b)))))
(test <span class="org-string">"(b)"</span>
      (with-output-to-string (<span class="org-keyword">lambda</span> () (print-queue (delete-queue! q1)))))
(test <span class="org-string">"()"</span>
      (with-output-to-string (<span class="org-keyword">lambda</span> () (print-queue (delete-queue! q1)))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-165" class="outline-2">
<h2 id="sec-165"><span class="section-number-2">165</span> <span class="done DONE">DONE</span> 3.22</h2>
<div class="outline-text-2" id="text-165">
<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">make-queue</span>)
  (<span class="org-keyword">let</span> ((front-ptr '())
        (rear-ptr '()))
    (<span class="org-keyword">define</span> (<span class="org-function-name">set-front-ptr!</span> new-front-ptr)
      (set! front-ptr new-front-ptr))
    (<span class="org-keyword">define</span> (<span class="org-function-name">set-rear-ptr!</span> new-rear-ptr)
      (set! rear-ptr new-rear-ptr))
    (<span class="org-keyword">define</span> (<span class="org-function-name">empty-queue?</span>)
      (null? front-ptr))
    (<span class="org-keyword">lambda</span> (message)
      (<span class="org-keyword">case</span> message
        ((front-ptr) front-ptr)
        ((rear-ptr) rear-ptr)
        ((set-front-ptr!) set-front-ptr!)
        ((set-rear-ptr!) set-rear-ptr!)
        ((empty?) empty-queue?)
        ((front)
         (<span class="org-keyword">if</span> (empty-queue?)
             (error <span class="org-string">"FRONT called with an empty queue"</span>)
             (car front-ptr)))
        ((insert!)
         (<span class="org-keyword">lambda</span> (item)
           (<span class="org-keyword">let</span> ((new-pair (cons item '())))
             (<span class="org-keyword">cond</span> ((empty-queue?)
                    (set-front-ptr! new-pair)
                    (set-rear-ptr! new-pair))
                   (<span class="org-keyword">else</span>
                    (set-cdr! rear-ptr new-pair)
                    (set-rear-ptr! new-pair))))))
        ((delete!)
         (<span class="org-keyword">cond</span> ((empty-queue?)
                (error <span class="org-string">"DELETE! called with an empty queue"</span>))
               (<span class="org-keyword">else</span> (set-front-ptr! (cdr front-ptr)))))
        ((print) (display front-ptr))))))

(<span class="org-keyword">define</span> (<span class="org-function-name">front-ptr</span> queue) (queue 'front-ptr))
(<span class="org-keyword">define</span> (<span class="org-function-name">rear-ptr</span> queue) (queue 'rear-ptr))
(<span class="org-keyword">define</span> (<span class="org-function-name">set-front-ptr!</span> queue item)
  ((queue 'set-front-ptr!) item))
(<span class="org-keyword">define</span> (<span class="org-function-name">set-rear-ptr!</span> queue item)
  ((queue 'set-rear-ptr!) item))
(<span class="org-keyword">define</span> (<span class="org-function-name">empty-queue?</span> queue) (queue 'empty?))
(<span class="org-keyword">define</span> (<span class="org-function-name">front-queue</span> queue) (queue 'front))

(<span class="org-keyword">define</span> (<span class="org-function-name">insert-queue!</span> queue item)
  ((queue 'insert!) item))

(<span class="org-keyword">define</span> (<span class="org-function-name">delete-queue!</span> queue)
  (queue 'delete!))

(<span class="org-keyword">define</span> (<span class="org-function-name">print-queue</span> queue) (queue 'print))

(<span class="org-keyword">define</span> <span class="org-function-name">q1</span> (make-queue))
(test <span class="org-string">"(a)"</span>
      (with-output-to-string (<span class="org-keyword">lambda</span> () (insert-queue! q1 'a) (print-queue q1))))
(test <span class="org-string">"(a b)"</span>
      (with-output-to-string (<span class="org-keyword">lambda</span> () (insert-queue! q1 'b) (print-queue q1))))
(test <span class="org-string">"(b)"</span>
      (with-output-to-string (<span class="org-keyword">lambda</span> () (delete-queue! q1) (print-queue q1))))
(test <span class="org-string">"()"</span>
      (with-output-to-string (<span class="org-keyword">lambda</span> () (delete-queue! q1) (print-queue q1))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-166" class="outline-2">
<h2 id="sec-166"><span class="section-number-2">166</span> <span class="done DONE">DONE</span> 3.23</h2>
<div class="outline-text-2" id="text-166">
<p>
Implemented deques with something like a ternary cons cell (see <a href="https://groups.google.com/forum/?hl=en#!topic/alt.folklore.computers/ocLEir5Gfzw">car,
cdr, csr (cooser)</a>) to represent doubly-linked lists.
</p>


<div class="figure">
<p><img src="./3.23.jpg" alt="3.23.jpg" />
</p>
<p><span class="figure-number">Figure 30:</span> Deques with (quasi-ternary) conses</p>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use srfi-1 srfi-69 test)

(<span class="org-keyword">define</span> <span class="org-function-name">make-cell</span>
  (case-lambda ((payload) (make-cell #f #f payload))
          ((forward backward payload)
           (cons* forward backward payload))))

(<span class="org-keyword">define</span> <span class="org-function-name">cell-forward</span> car)
(<span class="org-keyword">define</span> <span class="org-function-name">cell-backward</span> cadr)
(<span class="org-keyword">define</span> <span class="org-function-name">cell-payload</span> cddr)

(<span class="org-keyword">define</span> (<span class="org-function-name">cell-set-forward!</span> cell forward)
  (set-car! cell forward))
(<span class="org-keyword">define</span> (<span class="org-function-name">cell-set-backward!</span> cell backward)
  (set-car! (cdr cell) backward))
(<span class="org-keyword">define</span> (<span class="org-function-name">cell-set-payload!</span> cell payload)
  (set-cdr! (cdr cell) payload))

(<span class="org-keyword">define</span> (<span class="org-function-name">cell-&gt;list</span> front)
  (<span class="org-keyword">let</span> <span class="org-function-name">iter</span> ((cell (cell-backward front))
             (payloads '()))
    (<span class="org-keyword">if</span> (eq? cell front)
        (cons (cell-payload cell) payloads)
        (iter (cell-backward cell)
              (cons (cell-payload cell) payloads)))))

(<span class="org-keyword">define</span> (<span class="org-function-name">make-deque</span>)
  (<span class="org-keyword">let</span> ((front '())
        (rear '()))
    (<span class="org-keyword">define</span> (<span class="org-function-name">empty?</span>) (null? front))
    (<span class="org-keyword">lambda</span> (message)
      (<span class="org-keyword">case</span> message
        ((front)
         (<span class="org-keyword">if</span> (empty?)
             (error <span class="org-string">"FRONT called with an empty deque."</span>)
             (cell-payload front)))
        ((rear)
         (<span class="org-keyword">if</span> (empty?)
             (error <span class="org-string">"REAR called with an empty deque."</span>)
             (cell-payload rear)))
        ((front-insert!)
         (<span class="org-keyword">lambda</span> (payload)
           (<span class="org-keyword">let</span> ((cell (make-cell payload)))
             (when (empty?)
               (set! front cell)
               (set! rear cell))
             (cell-set-forward! cell front)
             (cell-set-backward! cell rear)
             (cell-set-backward! front cell)
             (cell-set-forward! rear cell)
             (set! front cell))))
        ((rear-insert!)
         (<span class="org-keyword">lambda</span> (payload)
           (<span class="org-keyword">let</span> ((cell (make-cell payload)))
             (when (empty?)
               (set! front cell)
               (set! rear cell))
             (cell-set-backward! cell rear)
             (cell-set-forward! cell front)
             (cell-set-forward! rear cell)
             (cell-set-backward! front cell)
             (set! rear cell))))
        ((front-delete!)
         (<span class="org-keyword">if</span> (empty?)
             (error <span class="org-string">"FRONT-DELETE! called with empty deque."</span>)
             (<span class="org-keyword">let</span> ((new-front (cell-forward front)))
               (<span class="org-keyword">if</span> (eq? front new-front)
                   <span class="org-comment-delimiter">;; </span><span class="org-comment">Deque is empty.</span>
                   (<span class="org-keyword">begin</span>
                     (set! front '())
                     (set! rear '()))
                   (<span class="org-keyword">begin</span>
                     (cell-set-backward! new-front rear)
                     (cell-set-forward! rear new-front)
                     (set! front new-front))))))
        ((rear-delete!)
         (<span class="org-keyword">if</span> (empty?)
             (error <span class="org-string">"REAR-DELETE! called with empty deque."</span>)
             (<span class="org-keyword">let</span> ((new-rear (cell-backward rear)))
               (<span class="org-keyword">if</span> (eq? rear new-rear)
                   <span class="org-comment-delimiter">;; </span><span class="org-comment">Deque is empty.</span>
                   (<span class="org-keyword">begin</span>
                     (set! front '())
                     (set! rear '()))
                   (<span class="org-keyword">begin</span>
                     (cell-set-backward! front new-rear)
                     (cell-set-forward! new-rear front)
                     (set! rear new-rear))))))
        ((-&gt;list) (<span class="org-keyword">if</span> (empty?) '() (cell-&gt;list front)))))))

(<span class="org-keyword">let</span> ((deque (make-deque)))
  (test '() (deque '-&gt;list))
  ((deque 'front-insert!) 'b)
  (test '(b) (deque '-&gt;list))
  ((deque 'front-insert!) 'a)
  (test '(a b) (deque '-&gt;list))
  ((deque 'rear-insert!) 'c)
  (test '(a b c) (deque '-&gt;list))
  (deque 'front-delete!)
  (test '(b c) (deque '-&gt;list))
  (deque 'rear-delete!)
  (test '(b) (deque '-&gt;list)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-167" class="outline-2">
<h2 id="sec-167"><span class="section-number-2">167</span> <span class="done DONE">DONE</span> 3.24</h2>
<div class="outline-text-2" id="text-167">
<p>
Let’s demonstrate tolerant keys using a tunable epsilon.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> <span class="org-function-name">make-table</span>
  (case-lambda
   (() (make-table equal?))
   ((same-key?)
    (<span class="org-keyword">let</span> ((table (list '*table*)))
      (<span class="org-keyword">define</span> (<span class="org-function-name">assoc</span> key records)
        (<span class="org-keyword">cond</span> ((null? records) #f)
              ((same-key? key (caar records)) (car records))
              (<span class="org-keyword">else</span> (assoc key (cdr records)))))
      (<span class="org-keyword">lambda</span> (message)
        (<span class="org-keyword">case</span> message
          ((lookup)
           (<span class="org-keyword">lambda</span> (key)
             (<span class="org-keyword">let</span> ((record (assoc key (cdr table))))
               (<span class="org-keyword">and</span> record (cdr record)))))
          ((insert!)
           (<span class="org-keyword">lambda</span> (key value)
             (<span class="org-keyword">let</span> ((record (assoc key (cdr table))))
               (<span class="org-keyword">if</span> record
                   (set-cdr! record value)
                   (set-cdr! table
                             (cons (cons key value)
                                   (cdr table)))))))
          ((table) table)))))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use test)

(include <span class="org-string">"table.scm"</span>)

(<span class="org-keyword">define</span> <span class="org-function-name">epsilon</span> (make-parameter 0.1))

<span class="org-comment-delimiter">;; </span><span class="org-comment">Bad design to use a dynamic variable: could change the semantics of</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">the table during usage; define at `make-approx-equal?'?</span>
(<span class="org-keyword">define</span> (<span class="org-function-name">approx-equal?</span> x y)
  (&lt; (abs (- x y)) (epsilon)))

(<span class="org-keyword">let</span> ((table (make-table approx-equal?)))
  ((table 'insert!) 1.0 'hello)
  (test 'hello ((table 'lookup) 0.99)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-168" class="outline-2">
<h2 id="sec-168"><span class="section-number-2">168</span> <span class="done DONE">DONE</span> 3.25</h2>
<div class="outline-text-2" id="text-168">
<p>
We created a new data-structure, <code>table-or-value</code>; the
implementation consists of <code>table-or-values</code> indexed by key.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use debug test)

(include <span class="org-string">"table.scm"</span>)

(<span class="org-keyword">define</span> <span class="org-function-name">no-value</span> (cons #f #f))
(<span class="org-keyword">define</span> (<span class="org-function-name">no-value?</span> object) (eq? no-value object))

(<span class="org-keyword">define</span> <span class="org-function-name">make-table-or-value</span> cons)
(<span class="org-keyword">define</span> <span class="org-function-name">table-or-value-table</span> car)
(<span class="org-keyword">define</span> <span class="org-function-name">table-or-value-table-set!</span> set-car!)
(<span class="org-keyword">define</span> <span class="org-function-name">table-or-value-value</span> cdr)
(<span class="org-keyword">define</span> <span class="org-function-name">table-or-value-value-set!</span> set-cdr!)

(<span class="org-keyword">define</span> (<span class="org-function-name">make-deep-table</span>)
  (<span class="org-keyword">let</span> ((table (make-table)))
    (<span class="org-keyword">lambda</span> (message)
      (<span class="org-keyword">case</span> message
        ((lookup)
         (<span class="org-keyword">lambda</span> (keys)
           (<span class="org-keyword">let</span> <span class="org-function-name">iter</span> ((keys keys)
                      (table table))
             (<span class="org-keyword">let*</span> ((key (car keys))
                    (subtable-or-value ((table 'lookup) key)))
               (<span class="org-keyword">and</span> subtable-or-value
                    (<span class="org-keyword">if</span> (null? (cdr keys)) <span class="org-comment-delimiter">; </span><span class="org-comment">Terminal case</span>
                        (table-or-value-value subtable-or-value)
                        (iter (cdr keys)
                              (table-or-value-table subtable-or-value))))))))
        ((insert!)
         (<span class="org-keyword">lambda</span> (keys value)
           (<span class="org-keyword">let</span> <span class="org-function-name">iter</span> ((keys keys)
                      (table table))
             (<span class="org-keyword">let*</span> ((key (car keys))
                    (subtable-or-value ((table 'lookup) key)))
               (<span class="org-keyword">if</span> (null? (cdr keys))   <span class="org-comment-delimiter">; </span><span class="org-comment">Terminal case</span>
                   (<span class="org-keyword">if</span> subtable-or-value
                       (table-or-value-value-set! subtable-or-value value)
                       ((table 'insert!)
                        key
                        (make-table-or-value (make-table) value)))
                   (<span class="org-keyword">if</span> subtable-or-value
                       (iter (cdr keys)
                             (table-or-value-table subtable-or-value))
                       (<span class="org-keyword">let</span> ((subtable-or-value
                              (make-table-or-value (make-table) no-value)))
                         ((table 'insert!)
                          key
                          subtable-or-value)
                         (iter (cdr keys)
                               (table-or-value-table subtable-or-value)))))))))
        ((table) (table 'table))))))

(<span class="org-keyword">let</span> ((table (make-deep-table)))
  ((table 'insert!) '(a) 1)
  ((table 'insert!) '(a b) 2)
  (test 1 ((table 'lookup) '(a)))
  (test 2 ((table 'lookup) '(a b))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-169" class="outline-2">
<h2 id="sec-169"><span class="section-number-2">169</span> <span class="done DONE">DONE</span> 3.26</h2>
<div class="outline-text-2" id="text-169">
<p>
Let’s reuse tree-sets, but distinguishing between the key and the
value; in the previous implementation, keys were values.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(include <span class="org-string">"tree-sets.scm"</span>)

(<span class="org-keyword">define</span> <span class="org-function-name">key-value</span> cons)
(<span class="org-keyword">define</span> <span class="org-function-name">key</span> car)
(<span class="org-keyword">define</span> <span class="org-function-name">value</span> cdr)

(<span class="org-keyword">define</span> (<span class="org-function-name">element-of-set?</span> x set)
  (<span class="org-keyword">cond</span> ((null? set) #f)
        ((= (key x) (key (entry set))) #t)
        ((&lt; (key x) (key (entry set)))
         (element-of-set? x (left-branch set)))
        ((&gt; (key x) (key (entry set)))
         (element-of-set? x (right-branch set)))))

(<span class="org-keyword">define</span> (<span class="org-function-name">adjoin-set</span> x set)
  (<span class="org-keyword">cond</span> ((null? set) (make-tree x '() '()))
        ((= (key x) (key (entry set))) set)
        ((&lt; (key x) (key (entry set)))
         (make-tree (entry set)
                    (adjoin-set x (left-branch set))
                    (right-branch set)))
        ((&gt; x (entry set))
         (make-tree (entry set) (left-branch set)
                    (adjoin-set x (right-branch set))))))

(<span class="org-keyword">define</span> (<span class="org-function-name">lookup</span> lookup-key tree)
  (<span class="org-keyword">if</span> (null? tree)
      #f
      (<span class="org-keyword">let</span> ((entry (entry tree)))
        (<span class="org-keyword">cond</span> ((= lookup-key (key entry)) (value entry))
              ((&lt; lookup-key (key entry))
               (lookup lookup-key (left-branch tree)))
              (<span class="org-keyword">else</span> (lookup lookup-key (right-branch tree)))))))

(<span class="org-keyword">let</span> ((tree (list-&gt;tree (list (key-value 1 'a)
                              (key-value 3 'b)
                              (key-value 6 'c)
                              (key-value 10 'd)))))
  (test 'c (lookup 6 tree))
  (test-assert (not (lookup 5 tree))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-170" class="outline-2">
<h2 id="sec-170"><span class="section-number-2">170</span> <span class="done DONE">DONE</span> 3.27</h2>
<div class="outline-text-2" id="text-170">
<ul class="org-ul">
<li>CLOSING NOTE <span class="timestamp-wrapper"><span class="timestamp">[2014-11-10 Mon 14:15]</span></span> <br  />
    We should redo this one to be a little clearer.
</li>
</ul>

<div class="figure">
<p><img src="./3.27.jpg" alt="3.27.jpg" />
</p>
<p><span class="figure-number">Figure 31:</span> Environment diagram for <code>memo-fib</code></p>
</div>
</div>
</div>
<div id="outline-container-sec-171" class="outline-2">
<h2 id="sec-171"><span class="section-number-2">171</span> <span class="done DONE">DONE</span> 3.28</h2>
<div class="outline-text-2" id="text-171">
<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">logical-or</span> s t)
  (<span class="org-keyword">cond</span> ((<span class="org-keyword">and</span> (= s 1) (= t 1)) 1)
        ((<span class="org-keyword">and</span> (= s 1) (= t 0)) 1)
        ((<span class="org-keyword">and</span> (= s 0) (= t 1)) 1)
        ((<span class="org-keyword">and</span> (= s 0) (= t 0)) 0)
        (<span class="org-keyword">else</span> (error <span class="org-string">"Invalid signal"</span> s))))

(<span class="org-keyword">define</span> (<span class="org-function-name">or-gate</span> a1 a2 output)
  (<span class="org-keyword">define</span> (<span class="org-function-name">or-action-procedure</span>)
    (<span class="org-keyword">let</span> ((new-value
           (logical-or (get-signal a1) (get-signal a2))))
      (after-delay
       (or-gate-delay)
       (<span class="org-keyword">lambda</span> () (set-signal! output new-value)))))
  (add-action! a1 or-action-procedure)
  (add-action! a2 or-action-procedure)
  'ok)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(include <span class="org-string">"or-gate.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">test-or-gate</span> test-or-gate)
  (<span class="org-keyword">let</span> ((a (make-wire))
        (b (make-wire))
        (c (make-wire)))
    (or-gate a b c)
    (test-or-gate a b c)))

(test-or-gate
 (<span class="org-keyword">lambda</span> (a b c)
   (propagate)
   (test 0 (get-signal c))))

(test-or-gate
 (<span class="org-keyword">lambda</span> (a b c)
   (set-signal! a 1)
   (propagate)
   (test 1 (get-signal c))))

(test-or-gate
 (<span class="org-keyword">lambda</span> (a b c)
   (set-signal! b 1)
   (propagate)
   (test 1 (get-signal c))))

(test-or-gate
 (<span class="org-keyword">lambda</span> (a b c)
   (set-signal! a 1)
   (set-signal! b 1)
   (propagate)
   (test 1 (get-signal c))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-172" class="outline-2">
<h2 id="sec-172"><span class="section-number-2">172</span> <span class="done DONE">DONE</span> 3.29</h2>
<div class="outline-text-2" id="text-172">
<p>
On analogy with \(\lnot (\lnot (x \lor y)) \equiv \lnot (\lnot x
  \land \lnot y)\), the compound or-gate might look like:
</p>


<div class="figure">
<p><img src="./3.29.jpg" alt="3.29.jpg" />
</p>
<p><span class="figure-number">Figure 32:</span> Compound or-gate</p>
</div>

<p>
whose delay is \(2\,\text{inverterDelay} + \text{andGateDelay}\).
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(<span class="org-keyword">define</span> (<span class="org-function-name">or-gate</span> a1 a2 output)
  (<span class="org-keyword">let</span> ((a3 (make-wire))
        (a4 (make-wire))
        (a5 (make-wire)))
    (inverter a1 a3)
    (inverter a2 a4)
    (and-gate a3 a4 a5)
    (inverter a5 output)
    'ok))

(<span class="org-keyword">define</span> (<span class="org-function-name">test-or-gate</span> test-or-gate)
  (<span class="org-keyword">let</span> ((a (make-wire))
        (b (make-wire))
        (c (make-wire)))
    (or-gate a b c)
    (test-or-gate a b c)))

(test-or-gate
 (<span class="org-keyword">lambda</span> (a b c)
   (propagate)
   (test 0 (get-signal c))))

(test-or-gate
 (<span class="org-keyword">lambda</span> (a b c)
   (set-signal! a 1)
   (propagate)
   (test 1 (get-signal c))))

(test-or-gate
 (<span class="org-keyword">lambda</span> (a b c)
   (set-signal! b 1)
   (propagate)
   (test 1 (get-signal c))))

(test-or-gate
 (<span class="org-keyword">lambda</span> (a b c)
   (set-signal! a 1)
   (set-signal! b 1)
   (propagate)
   (test 1 (get-signal c))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-173" class="outline-2">
<h2 id="sec-173"><span class="section-number-2">173</span> <span class="done DONE">DONE</span> 3.30</h2>
<div class="outline-text-2" id="text-173">
<p>
A full adder is two half adders plus an or-gate; whereas a half
adder is an or-gate, two and-gates and an inverter.
</p>

<p>
The total cost of a ripple-carry adder for \(n\) bits is therefore:
</p>

\begin{align}
n \times (2 \times (\text{orGateDelay} + 2\,\text{andGateDelay} + \text{inverterDelay}) + \\
\text{orGateDelay})
\end{align}

<div class="org-src-container">

<pre class="src src-scheme">(use sicp srfi-26 test)

(<span class="org-keyword">define</span> (<span class="org-function-name">ripple-carry-adder</span> a b s c-out)
  (<span class="org-keyword">let</span> <span class="org-function-name">iter</span> ((a a)
             (b b)
             (s s)
             (c-in (make-wire)))
    (unless (null? a)
      (<span class="org-keyword">let</span> ((c-out (<span class="org-keyword">if</span> (null? (cdr a)) c-out (make-wire))))
        (full-adder (car a) (car b) c-in (car s) c-out)
        (iter (cdr a) (cdr b) (cdr s) c-out)))))

(<span class="org-keyword">let</span> ((a (list (make-wire 1)
               (make-wire 1)
               (make-wire 1)
               (make-wire 1)))
      (b (list (make-wire 1)
               (make-wire 1)
               (make-wire 1)
               (make-wire 1)))
      (s (list (make-wire)
               (make-wire)
               (make-wire)
               (make-wire)))
      (c (make-wire)))
  (ripple-carry-adder a b s c)
  (propagate)
  (test <span class="org-string">"15 + 15 = 30 in binary"</span>
        '(1 1 1 1 0)
        (<span class="org-keyword">map</span> get-signal (cons c (reverse s)))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-174" class="outline-2">
<h2 id="sec-174"><span class="section-number-2">174</span> <span class="todo TODO">TODO</span> 3.31</h2>
<div class="outline-text-2" id="text-174">
<p>
The first call to <code>proc</code> scheduled the action; interestingly,
however, don’t see a difference in the half-adder example.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use debug sicp test)

(parameterize ((the-agenda (make-agenda)))
  (<span class="org-keyword">let</span> ((input-1 (make-wire))
        (input-2 (make-wire))
        (sum (make-wire))
        (carry (make-wire)))
    (probe 'sum sum)
    (probe 'carry carry)
    (half-adder input-1 input-2 sum carry)
    (set-signal! input-1 1)
    (propagate)))

(<span class="org-keyword">define</span> <span class="org-function-name">make-wire-no-proc</span>
  (case-lambda
   (() (make-wire 0))
   ((signal-value)
    (<span class="org-keyword">let</span> ((action-procedures '()))
      (<span class="org-keyword">define</span> (<span class="org-function-name">set-my-signal!</span> new-value)
        (<span class="org-keyword">if</span> (not (= signal-value new-value))
            (<span class="org-keyword">begin</span> (set! signal-value new-value)
                   (call-each action-procedures))
            'done))
      (<span class="org-keyword">define</span> (<span class="org-function-name">accept-action-procedure!</span> proc)
        (set! action-procedures
              (cons proc action-procedures)))
      (<span class="org-keyword">define</span> (<span class="org-function-name">dispatch</span> m)
        (<span class="org-keyword">cond</span> ((eq? m 'get-signal) signal-value)
              ((eq? m 'set-signal!) set-my-signal!)
              ((eq? m 'add-action!) accept-action-procedure!)
              (<span class="org-keyword">else</span> (error <span class="org-string">"Unknown operation: WIRE"</span> m))))
      dispatch))))

(parameterize ((the-agenda (make-agenda)))
  (<span class="org-keyword">let</span> ((input-1 (make-wire-no-proc))
        (input-2 (make-wire-no-proc))
        (sum (make-wire-no-proc))
        (carry (make-wire-no-proc)))
    (probe 'sum sum)
    (probe 'carry carry)
    (half-adder input-1 input-2 sum carry)
    (set-signal! input-1 1)
    (propagate)
    (get-signal sum)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-175" class="outline-2">
<h2 id="sec-175"><span class="section-number-2">175</span> <span class="todo TODO">TODO</span> 3.32</h2>
<div class="outline-text-2" id="text-175">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp test)

(<span class="org-keyword">define</span> (<span class="org-function-name">remove-first-agenda-item!</span> agenda)
  (<span class="org-keyword">let</span> ((q (segment-queue (first-segment agenda))))
    (set! q (cdr q))
    (<span class="org-keyword">if</span> (null? q)
        (set-segments! agenda (rest-segments agenda)))))

(<span class="org-keyword">define</span> (<span class="org-function-name">first-agenda-item</span> agenda)
  (<span class="org-keyword">if</span> (empty-agenda? agenda)
      (error <span class="org-string">"Agenda is empty: FIRST-AGENDA-ITEM"</span>)
      (<span class="org-keyword">let</span> ((first-seg (first-segment agenda)))
        (set-current-time! agenda
                           (segment-time first-seg))
        (car (segment-queue first-seg)))))

(<span class="org-keyword">define</span> (<span class="org-function-name">add-to-agenda!</span> time action agenda)
  (<span class="org-keyword">define</span> (<span class="org-function-name">belongs-before?</span> segments)
    (<span class="org-keyword">or</span> (null? segments)
        (&lt; time (segment-time (car segments)))))
  (<span class="org-keyword">define</span> (<span class="org-function-name">make-new-time-segment</span> time action)
    (<span class="org-keyword">let</span> ((q (list)))
      (set! q (cons action q))
      (make-time-segment time q)))
  (<span class="org-keyword">define</span> (<span class="org-function-name">add-to-segments!</span> segments)
    (<span class="org-keyword">if</span> (= (segment-time (car segments)) time)
        (set-cdr! (car segments)
                  (cons action (segment-queue (car segments))))
        <span class="org-comment-delimiter">;; </span><span class="org-comment">(insert-queue! (segment-queue (car segments))</span>
        <span class="org-comment-delimiter">;;                </span><span class="org-comment">action)</span>
        (<span class="org-keyword">let</span> ((rest (cdr segments)))
          (<span class="org-keyword">if</span> (belongs-before? rest)
              (set-cdr!
               segments
               (cons (make-new-time-segment time action)
                     (cdr segments)))
              (add-to-segments! rest)))))
  (<span class="org-keyword">let</span> ((segments (segments agenda)))
    (<span class="org-keyword">if</span> (belongs-before? segments)
        (set-segments!
         agenda
         (cons (make-new-time-segment time action)
               segments))
        (add-to-segments! segments))))

(<span class="org-keyword">let</span> ((a (make-wire 0))
      (b (make-wire 1))
      (c (make-wire))
      (d (make-wire))
      (e (make-wire)))
  (inverter a c)
  (inverter b d)
  (and-gate c d e)
  (propagate)
  (get-signal e))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-176" class="outline-2">
<h2 id="sec-176"><span class="section-number-2">176</span> <span class="done DONE">DONE</span> 3.33</h2>
<div class="outline-text-2" id="text-176">

<div class="figure">
<p><img src="./3.33.jpg" alt="3.33.jpg" />
</p>
<p><span class="figure-number">Figure 33:</span> The average-relation (\(2c = a + b\)) as a constraint network</p>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp-constraints test)

(<span class="org-keyword">define</span> (<span class="org-function-name">averager</span> a b c)
  (<span class="org-keyword">let</span> ((x (make-connector))
        (y (make-connector)))
    (adder a b x)
    (multiplier c y x)
    (constant 2 y)
    'ok))

(<span class="org-keyword">define</span> <span class="org-function-name">a</span> (make-connector))
(<span class="org-keyword">define</span> <span class="org-function-name">b</span> (make-connector))
(<span class="org-keyword">define</span> <span class="org-function-name">c</span> (make-connector))

(averager a b c)
(set-value! a 3 'user)
(set-value! b 5 'user)

(test 4 (get-value c))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-177" class="outline-2">
<h2 id="sec-177"><span class="section-number-2">177</span> <span class="done DONE">DONE</span> 3.34</h2>
<div class="outline-text-2" id="text-177">

<div class="figure">
<p><img src="./3.34.jpg" alt="3.34.jpg" />
</p>
<p><span class="figure-number">Figure 34:</span> A pathological square-relation</p>
</div>

<p>
If \(b\) is set and neither \(m_1\) nor \(m_2\) are set, it will not
square (there is not enough information); if \(a\) is set, on the
other hand, both \(m_1\) and \(m_2\) are also set and it will square.
</p>

<p>
(Not to mention the problem of generating solutions for \(m_1\) and
\(m_2\) when there is not enough information.)
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp-constraints test)

(<span class="org-keyword">define</span> (<span class="org-function-name">squarer</span> a b)
  (multiplier a a b))

(<span class="org-keyword">let</span> ((a (make-connector))
      (b (make-connector)))
  (squarer a b)

  (set-value! b 4 'user)
  (test-assert <span class="org-string">"a has not been set."</span> (not (has-value? a)))

  (forget-value! b 'user)
  (set-value! a 2 'user)
  (test <span class="org-string">"b is 4."</span> 4 (get-value b)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-178" class="outline-2">
<h2 id="sec-178"><span class="section-number-2">178</span> <span class="done DONE">DONE</span> 3.35</h2>
<div class="outline-text-2" id="text-178">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp-constraints test)

(<span class="org-keyword">define</span> (<span class="org-function-name">squarer</span> a b)
  (<span class="org-keyword">define</span> (<span class="org-function-name">process-new-value</span>)
    (<span class="org-keyword">if</span> (has-value? b)
        (<span class="org-keyword">if</span> (&lt; (get-value b) 0)
            (error <span class="org-string">"square less than 0: SQUARER"</span>
                   (get-value b))
            (set-value! a (sqrt (get-value b)) me))
        (set-value! b (* (get-value a) (get-value a)) me)))
  (<span class="org-keyword">define</span> (<span class="org-function-name">process-forget-value</span>)
    (forget-value! a me)
    (forget-value! b me)
    (process-new-value))
  (<span class="org-keyword">define</span> (<span class="org-function-name">me</span> request)
    (<span class="org-keyword">case</span> request
      ((I-have-a-value) (process-new-value))
      ((I-lost-my-value) (process-forget-value))
      (<span class="org-keyword">else</span> (error <span class="org-string">"Unknown request: SQUARER"</span> request))))
  (connect a me)
  (connect b me)
  me)

(<span class="org-keyword">let</span> ((a (make-connector))
      (b (make-connector)))
  (squarer a b)
  (set-value! b 2 'user)
  (test 1.4142135623731 (get-value a)))

(<span class="org-keyword">let</span> ((a (make-connector))
      (b (make-connector)))
  (squarer a b)
  (set-value! a 2 'user)
  (test 4 (get-value b)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-179" class="outline-2">
<h2 id="sec-179"><span class="section-number-2">179</span> <span class="done DONE">DONE</span> 3.36</h2>
<div class="outline-text-2" id="text-179">

<div class="figure">
<p><img src="./3.36.jpg" alt="3.36.jpg" />
</p>
<p><span class="figure-number">Figure 35:</span> Environment diagram for <code>(for-each-except setter inform-about-value constraints)</code></p>
</div>
</div>
</div>
<div id="outline-container-sec-180" class="outline-2">
<h2 id="sec-180"><span class="section-number-2">180</span> <span class="done DONE">DONE</span> 3.37</h2>
<div class="outline-text-2" id="text-180">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp-constraints test)

(<span class="org-keyword">define</span> (<span class="org-function-name">c+</span> x y)
  (<span class="org-keyword">let</span> ((z (make-connector)))
    (adder x y z)
    z))

(<span class="org-keyword">define</span> (<span class="org-function-name">c*</span> x y)
  (<span class="org-keyword">let</span> ((z (make-connector)))
    (multiplier x y z)
    z))

(<span class="org-keyword">define</span> (<span class="org-function-name">c/</span> x y)
  (<span class="org-keyword">let</span> ((z (make-connector)))
    (multiplier y z x)
    z))

(<span class="org-keyword">define</span> (<span class="org-function-name">cv</span> x)
  (<span class="org-keyword">let</span> ((y (make-connector)))
    (constant x y)
    y))

(<span class="org-keyword">define</span> (<span class="org-function-name">celsius-fahrenheit-converter</span> x)
  (c+ (c* (c/ (cv 9) (cv 5))
          x)
      (cv 32)))

(<span class="org-keyword">define</span> <span class="org-function-name">C</span> (make-connector))
(<span class="org-keyword">define</span> <span class="org-function-name">F</span> (celsius-fahrenheit-converter C))

(set-value! F 212 'user)
(test 100.0 (get-value C))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-181" class="outline-2">
<h2 id="sec-181"><span class="section-number-2">181</span> <span class="done DONE">DONE</span> 3.38</h2>
<div class="outline-text-2" id="text-181">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-bottom"><span class="table-number">Table 1:</span> Different values for <code>balance</code> given sequential operations</caption>

<colgroup>
<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="right">\(balance_0\)</th>
<th scope="col" class="right">\(op_0\)</th>
<th scope="col" class="right">\(op_1\)</th>
<th scope="col" class="right">\(op_2\)</th>
<th scope="col" class="right">\(balance_4\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="right">100</td>
<td class="right">+10</td>
<td class="right">-20</td>
<td class="right">/2</td>
<td class="right">45</td>
</tr>

<tr>
<td class="right">100</td>
<td class="right">+10</td>
<td class="right">/2</td>
<td class="right">-20</td>
<td class="right">35</td>
</tr>

<tr>
<td class="right">100</td>
<td class="right">-20</td>
<td class="right">+10</td>
<td class="right">/2</td>
<td class="right">45</td>
</tr>

<tr>
<td class="right">100</td>
<td class="right">-20</td>
<td class="right">/2</td>
<td class="right">+10</td>
<td class="right">50</td>
</tr>

<tr>
<td class="right">100</td>
<td class="right">/2</td>
<td class="right">-20</td>
<td class="right">+10</td>
<td class="right">40</td>
</tr>

<tr>
<td class="right">100</td>
<td class="right">/2</td>
<td class="right">+10</td>
<td class="right">-20</td>
<td class="right">40</td>
</tr>
</tbody>
</table>

<p>
Whereas sequential operations can result in any permutation of
operations (for \(n!\) possibilites); interleaved operations, on the
other hand, can result (due to preëmption) in any power-permutation
of operations excluding the empty set (for \(\sum_{i=1}^n P_{n,i}\)
possibilities).
</p>

<p>
The new possibilities in the interleaved case are 30, 55, 60, 80,
90, 110.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-bottom"><span class="table-number">Table 2:</span> Different values for <code>balance</code> given interleaved operations</caption>

<colgroup>
<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="left" />

<col  class="right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="right">\(balance_0\)</th>
<th scope="col" class="right">\(op_0\)</th>
<th scope="col" class="right">\(op_1\)</th>
<th scope="col" class="left">\(op_2\)</th>
<th scope="col" class="right">\(balance_4\)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="right">100</td>
<td class="right">/2</td>
<td class="right">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="right">50</td>
</tr>

<tr>
<td class="right">100</td>
<td class="right">+10</td>
<td class="right">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="right">110</td>
</tr>

<tr>
<td class="right">100</td>
<td class="right">-20</td>
<td class="right">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="right">80</td>
</tr>

<tr>
<td class="right">100</td>
<td class="right">/2</td>
<td class="right">+10</td>
<td class="left">&#xa0;</td>
<td class="right">60</td>
</tr>

<tr>
<td class="right">100</td>
<td class="right">/2</td>
<td class="right">-20</td>
<td class="left">&#xa0;</td>
<td class="right">30</td>
</tr>

<tr>
<td class="right">100</td>
<td class="right">+10</td>
<td class="right">/2</td>
<td class="left">&#xa0;</td>
<td class="right">55</td>
</tr>

<tr>
<td class="right">100</td>
<td class="right">+10</td>
<td class="right">-20</td>
<td class="left">&#xa0;</td>
<td class="right">90</td>
</tr>

<tr>
<td class="right">100</td>
<td class="right">-20</td>
<td class="right">/2</td>
<td class="left">&#xa0;</td>
<td class="right">40</td>
</tr>

<tr>
<td class="right">100</td>
<td class="right">-20</td>
<td class="right">+10</td>
<td class="left">&#xa0;</td>
<td class="right">90</td>
</tr>

<tr>
<td class="right">100</td>
<td class="right">+10</td>
<td class="right">-20</td>
<td class="left">/2</td>
<td class="right">45</td>
</tr>

<tr>
<td class="right">100</td>
<td class="right">+10</td>
<td class="right">/2</td>
<td class="left">-20</td>
<td class="right">35</td>
</tr>

<tr>
<td class="right">100</td>
<td class="right">-20</td>
<td class="right">+10</td>
<td class="left">/2</td>
<td class="right">45</td>
</tr>

<tr>
<td class="right">100</td>
<td class="right">-20</td>
<td class="right">/2</td>
<td class="left">+10</td>
<td class="right">50</td>
</tr>

<tr>
<td class="right">100</td>
<td class="right">/2</td>
<td class="right">-20</td>
<td class="left">+10</td>
<td class="right">40</td>
</tr>

<tr>
<td class="right">100</td>
<td class="right">/2</td>
<td class="right">+10</td>
<td class="left">-20</td>
<td class="right">40</td>
</tr>
</tbody>
</table>

<p>
The timing might look something this:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="right">Time</th>
<th scope="col" class="left">Bank</th>
<th scope="col" class="left">Peter</th>
<th scope="col" class="left">Paul</th>
<th scope="col" class="left">Mary</th>
</tr>
</thead>
<tbody>
<tr>
<td class="right">0</td>
<td class="left"><code>(get-balance) =&gt; 100</code></td>
<td class="left"><code>(get-balance) =&gt; 100</code></td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="right">1</td>
<td class="left">&#xa0;</td>
<td class="left"><code>(set-balance! 90)</code></td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="right">2</td>
<td class="left"><code>(set-balance! 110)</code></td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left"><code>(get-balance) =&gt; 110</code></td>
</tr>

<tr>
<td class="right">3</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
<td class="left"><code>(set-balance! 55)</code></td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-sec-182" class="outline-2">
<h2 id="sec-182"><span class="section-number-2">182</span> <span class="done DONE">DONE</span> 3.39</h2>
<div class="outline-text-2" id="text-182">
<dl class="org-dl">
<dt> 101 </dt><dd>\(P_1\) sets \(x\) to 100, \(P_2\) increments \(x\) to 101.
</dd>
<dt> 100 </dt><dd>\(P_1\) accesses \(x\), \(P_2\) sets \(x\) to 11, \(P_1\) sets \(x\)
           to 100.
</dd>
<dt> 121 </dt><dd>\(P_2\) increments \(x\) to 11, \(P_1\) sets \(x\) to 121.
</dd>
</dl>
</div>
</div>
<div id="outline-container-sec-183" class="outline-2">
<h2 id="sec-183"><span class="section-number-2">183</span> <span class="done DONE">DONE</span> 3.40</h2>
<div class="outline-text-2" id="text-183">
<p>
If there are six atomic operations: <code>p1-access</code>, <code>p1-multiply</code>,
<code>p1-set!</code>, <code>p2-access</code>, <code>p2-multiply</code>, <code>p2-set!</code>; one can think of
this as an interleaving sequence problem where \(P_1 = \{access,
  multiply, set!\}\) and \(P_2 = \{access, multiply, multiply, set!\}\).
</p>

<p>
The <a href="http://math.stackexchange.com/questions/666288/number-of-ways-to-interleave-two-ordered-sequences">number of ways</a> to interleave the sequences are
\(\binom{|P_1| + |P_2|}{|P_1|} = 35\); we can simulate the order of
operations in the machine to see that the possibilities are 100,
1000, 10000, 100000, 1000000 and which sequences of operations
generate them.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use combinatorics srfi-69 srfi-95 vector-lib)

(<span class="org-keyword">define</span> (<span class="org-function-name">operations-set!</span> operations
                         combination
                         access
                         multiply
                         set!)
  (<span class="org-keyword">let</span> <span class="org-function-name">iter</span> ((access? #t)
             (combination combination))
    (unless (null? combination)
      (<span class="org-keyword">let</span> ((operation (car combination)))
        (<span class="org-keyword">cond</span> (access?
               (vector-set! operations operation access))
              ((null? (cdr combination))
               (vector-set! operations operation set!))
              (<span class="org-keyword">else</span>
               (vector-set! operations operation multiply))))
      (iter #f (cdr combination)))))

(<span class="org-keyword">define</span> (<span class="org-function-name">combination-&gt;operations</span> combinations combination)
  (<span class="org-keyword">let</span> ((operations (make-vector 7))
        (anti-combination (lset-difference = combinations combination)))
    (operations-set! operations
                     (sort combination &lt;)
                     'p1-access
                     'p1-multiply
                     'p1-set!)
    (operations-set! operations
                     (sort anti-combination &lt;)
                     'p2-access
                     'p2-multiply
                     'p2-set!)
    operations))

(<span class="org-keyword">define</span> (<span class="org-function-name">apply-operations</span> x operations)
  (<span class="org-keyword">let</span> ((x1 #f)
        (x2 #f))
    (vector-for-each
     (<span class="org-keyword">lambda</span> (i operation)
       (<span class="org-keyword">case</span> operation
         ((p1-access) (set! x1 x))
         ((p1-multiply) (set! x1 (* x1 x)))
         ((p1-set!) (set! x x1))
         ((p2-access) (set! x2 x))
         ((p2-multiply) (set! x2 (* x2 x)))
         ((p2-set!) (set! x x2))
         (<span class="org-keyword">else</span> (error <span class="org-string">"Unknown operation"</span>))))
     operations))
  x)

(<span class="org-keyword">let</span> ((x-&gt;operations (make-hash-table))
      (combinations (iota 7)))
  (unordered-subset-for-each
   (<span class="org-keyword">lambda</span> (combination)
     (<span class="org-keyword">let</span> ((x 10))
       (<span class="org-keyword">let*</span> ((operations
               (combination-&gt;operations combinations combination))
              (x (apply-operations x operations)))
         (hash-table-update!/default x-&gt;operations
                                     x
                                     (<span class="org-keyword">lambda</span> (x-operations)
                                       (cons operations x-operations))
                                     '()))))
   combinations
   3)
  (sort (hash-table-&gt;alist x-&gt;operations) &lt; car))
</pre>
</div>

<p>
yields:
</p>

<div class="org-src-container">

<pre class="src src-scheme">((100
  #(p2-access p2-multiply p2-multiply p1-access p1-multiply p2-set! p1-set!)
  #(p2-access p2-multiply p1-access p2-multiply p1-multiply p2-set! p1-set!)
  #(p2-access p2-multiply p1-access p1-multiply p2-multiply p2-set! p1-set!)
  #(p2-access p1-access p2-multiply p2-multiply p1-multiply p2-set! p1-set!)
  #(p2-access p1-access p2-multiply p1-multiply p2-multiply p2-set! p1-set!)
  #(p2-access p1-access p1-multiply p2-multiply p2-multiply p2-set! p1-set!)
  #(p1-access p2-access p2-multiply p2-multiply p1-multiply p2-set! p1-set!)
  #(p1-access p2-access p2-multiply p1-multiply p2-multiply p2-set! p1-set!)
  #(p1-access p2-access p1-multiply p2-multiply p2-multiply p2-set! p1-set!)
  #(p1-access p1-multiply p2-access p2-multiply p2-multiply p2-set! p1-set!))
 (1000
  #(p2-access p2-multiply p2-multiply p1-access p1-multiply p1-set! p2-set!)
  #(p2-access p2-multiply p1-access p2-multiply p1-multiply p1-set! p2-set!)
  #(p2-access p2-multiply p1-access p1-multiply p2-multiply p1-set! p2-set!)
  #(p2-access p1-access p2-multiply p2-multiply p1-multiply p1-set! p2-set!)
  #(p2-access p1-access p2-multiply p1-multiply p2-multiply p1-set! p2-set!)
  #(p2-access p1-access p1-multiply p2-multiply p2-multiply p1-set! p2-set!)
  #(p1-access p2-access p2-multiply p2-multiply p1-multiply p1-set! p2-set!)
  #(p1-access p2-access p2-multiply p1-multiply p2-multiply p1-set! p2-set!)
  #(p1-access p2-access p1-multiply p2-multiply p2-multiply p1-set! p2-set!)
  #(p1-access p1-multiply p2-access p2-multiply p2-multiply p1-set! p2-set!))
 (10000
  #(p2-access p2-multiply p2-multiply p1-access p2-set! p1-multiply p1-set!)
  #(p2-access p2-multiply p1-access p2-multiply p2-set! p1-multiply p1-set!)
  #(p2-access p2-multiply p1-access p1-multiply p1-set! p2-multiply p2-set!)
  #(p2-access p1-access p2-multiply p2-multiply p2-set! p1-multiply p1-set!)
  #(p2-access p1-access p2-multiply p1-multiply p1-set! p2-multiply p2-set!)
  #(p2-access p1-access p1-multiply p2-multiply p1-set! p2-multiply p2-set!)
  #(p1-access p2-access p2-multiply p2-multiply p2-set! p1-multiply p1-set!)
  #(p1-access p2-access p2-multiply p1-multiply p1-set! p2-multiply p2-set!)
  #(p1-access p2-access p1-multiply p2-multiply p1-set! p2-multiply p2-set!)
  #(p1-access p1-multiply p2-access p2-multiply p1-set! p2-multiply p2-set!))
 (100000
  #(p2-access p1-access p1-multiply p1-set! p2-multiply p2-multiply p2-set!)
  #(p1-access p2-access p1-multiply p1-set! p2-multiply p2-multiply p2-set!)
  #(p1-access p1-multiply p2-access p1-set! p2-multiply p2-multiply p2-set!))
 (1000000
  #(p2-access p2-multiply p2-multiply p2-set! p1-access p1-multiply p1-set!)
  #(p1-access
    p1-multiply
    p1-set!
    p2-access
    p2-multiply
    p2-multiply
    p2-set!)))
</pre>
</div>

<p>
Serially, the only possibility is 1000000.
</p>
</div>
</div>
<div id="outline-container-sec-184" class="outline-2">
<h2 id="sec-184"><span class="section-number-2">184</span> <span class="todo TODO">TODO</span> 3.41</h2>
<div class="outline-text-2" id="text-184">
<p>
If there are processor-level interlocks on memory operations (where
it is impossible to read a value quicker than it is written),
accessing the balance unprotected balance should be ok.
</p>

<p>
TODO: Think about accessing balance in the middle of <code>withdraw</code>.
</p>
</div>
</div>
<div id="outline-container-sec-185" class="outline-2">
<h2 id="sec-185"><span class="section-number-2">185</span> <span class="done DONE">DONE</span> 3.42</h2>
<div class="outline-text-2" id="text-185">
<p>
<a href="https://github.com/klutometis/sicp-chicken/blob/master/sicp-concurrency-core.scm">As implemented</a>, this is a safe change to make; <code>dynamic-wind</code> will
take care of the details.
</p>
</div>
</div>
<div id="outline-container-sec-186" class="outline-2">
<h2 id="sec-186"><span class="section-number-2">186</span> <span class="done DONE">DONE</span> 3.43</h2>
<div class="outline-text-2" id="text-186">
<p>
The only source of indeterminate results would be concurrent access
followed by out-of-order operations; with sequential access, the
balances $10, $20 and $30 should be preserved because access and
mutation are serialized.
</p>

<p>
Imagine something like <code>(exchange a1 a2), =(exchange a2 a3)</code> using
the first version of <code>exchange</code>:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">a1</th>
<th scope="col" class="left">a2</th>
<th scope="col" class="left">a3</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">\(access_1\): 10</td>
<td class="left">\(access_1\): 20</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">\(access_2\): 20</td>
<td class="left">\(access_2\):30</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">\(set!_2\): 30</td>
<td class="left">\(set!_2\): 20</td>
</tr>

<tr>
<td class="left">\(set!_1\): 20</td>
<td class="left">\(set!_1\): 20</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>
<p>
Since it calculates deltas, it should preserve cash-in, cash-out;
and, therefore, the totals will remain the same.
</p>

<p>
Imagine if it did not serialize the transactions on individual
accounts:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">a1</th>
<th scope="col" class="left">a2</th>
<th scope="col" class="left">a3</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">\(access_1\): 10</td>
<td class="left">\(access_1\): 20</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">\(access_2\): 20</td>
<td class="left">\(access_2\):30</td>
</tr>

<tr>
<td class="left">\(set!_1\): 20</td>
<td class="left">\(set!_1\): 10</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">\(set!_2\): 30</td>
<td class="left">\(set!_2\): 20</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-sec-187" class="outline-2">
<h2 id="sec-187"><span class="section-number-2">187</span> <span class="done DONE">DONE</span> 3.44</h2>
<div class="outline-text-2" id="text-187">
<p>
One still has the same problem of interleaved access and setting as
<a href="#sec-186">186</a>, despite serialized deposit and withdraw; external
serialization is necessary like the implementation of <code>exchange</code>.
</p>
</div>
</div>
<div id="outline-container-sec-188" class="outline-2">
<h2 id="sec-188"><span class="section-number-2">188</span> <span class="done DONE">DONE</span> 3.45</h2>
<div class="outline-text-2" id="text-188">
<p>
This results in deadlock: <code>serialized-exchange</code> grabs the mutices,
but so does <code>withdraw</code> and <code>deposit</code>.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use debug test sicp-concurrency)

(<span class="org-keyword">define</span> (<span class="org-function-name">make-account-and-serializer</span> balance)
  (<span class="org-keyword">define</span> (<span class="org-function-name">withdraw</span> amount)
    (<span class="org-keyword">if</span> (&gt;= balance amount)
        (<span class="org-keyword">begin</span> (set! balance (- balance amount)) balance)
        <span class="org-string">"Insufficient funds"</span>))
  (<span class="org-keyword">define</span> (<span class="org-function-name">deposit</span> amount)
    (set! balance (+ balance amount)) balance)
  (<span class="org-keyword">let</span> ((balance-serializer (make-serializer)))
    (<span class="org-keyword">define</span> (<span class="org-function-name">dispatch</span> m)
      (<span class="org-keyword">cond</span> ((eq? m 'withdraw) (balance-serializer withdraw))
            ((eq? m 'deposit) (balance-serializer deposit))
            ((eq? m 'balance) balance)
            ((eq? m 'serializer) balance-serializer)
            (<span class="org-keyword">else</span> (error <span class="org-string">"Unknown request: MAKE-ACCOUNT"</span> m))))
    dispatch))

(<span class="org-keyword">define</span> (<span class="org-function-name">exchange</span> account1 account2)
  (<span class="org-keyword">let</span> ((difference (- (account1 'balance)
                       (account2 'balance))))
    ((account1 'withdraw) difference)
    ((account2 'deposit) difference)))

(<span class="org-keyword">define</span> (<span class="org-function-name">serialized-exchange</span> account1 account2)
  (<span class="org-keyword">let</span> ((serializer1 (account1 'serializer))
        (serializer2 (account2 'serializer)))
    ((serializer1 (serializer2 exchange))
     account1
     account2)))

(<span class="org-keyword">let</span> ((a1 (make-account-and-serializer 10))
      (a2 (make-account-and-serializer 10)))
  <span class="org-comment-delimiter">;; </span><span class="org-comment">Deadlocks!</span>
  (test-error (serialized-exchange a1 a2)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-189" class="outline-2">
<h2 id="sec-189"><span class="section-number-2">189</span> <span class="done DONE">DONE</span> 3.46</h2>
<div class="outline-text-2" id="text-189">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">p1</th>
<th scope="col" class="left">p2</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>(car cell) =&gt; #t</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left"><code>(car cell) =&gt; #t</code></td>
</tr>

<tr>
<td class="left"><code>(set-car! cell #f)</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left"><code>(set-car! cell #f)</code></td>
</tr>

<tr>
<td class="left"><code>(apply p args)</code></td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left"><code>(apply p args)</code></td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-sec-190" class="outline-2">
<h2 id="sec-190"><span class="section-number-2">190</span> <span class="done DONE">DONE</span> 3.47</h2>
<div class="outline-text-2" id="text-190">
<p>
Let’s use a mutex with a condition-variable to wake sleeping threads
(instead of e.g. idling and polling); we did not implement the
<code>test-and-set!</code> version, since we lack the equivalent of
MIT-Scheme’s <code>without-interrupts</code>.
</p>

<p>
The basic idea is that, if the capacity goes to 0, the thread sleeps
on the condition until a condition-variable broadcast wakes it up;
it then tries to re-acquire the semaphore (and so do all other
sleeping threads).<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>
</p>

<p>
If the capacity is positive, it decrements the capacity and proceeds
unhindered.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp-concurrency srfi-18 test)

(<span class="org-keyword">define</span> (<span class="org-function-name">make-semaphore</span> capacity)
  (<span class="org-keyword">let</span> ((protect-capacity (make-mutex))
        (capacity-increased (make-condition-variable)))
    (<span class="org-keyword">define</span> (<span class="org-function-name">release!</span>)
      (with-mutex-locked protect-capacity
        (<span class="org-keyword">lambda</span> ()
          (set! capacity (+ capacity 1))
          (condition-variable-broadcast! capacity-increased))))
    (<span class="org-keyword">define</span> (<span class="org-function-name">acquire!</span>)
      (mutex-lock! protect-capacity)
      (<span class="org-keyword">if</span> (zero? capacity)
          (<span class="org-keyword">begin</span>
            (mutex-unlock! protect-capacity capacity-increased)
            (acquire!))
          (<span class="org-keyword">begin</span>
            (set! capacity (- capacity 1))
            (mutex-unlock! protect-capacity))))
    (<span class="org-keyword">lambda</span> (message)
      (<span class="org-keyword">case</span> message
        ((release!) (release!))
        ((acquire!) (acquire!))
        (<span class="org-keyword">else</span> (error <span class="org-string">"Unknown message"</span> message))))))

(<span class="org-keyword">define</span> (<span class="org-function-name">semaphore-acquire!</span> semaphore)
  (semaphore 'acquire!))

(<span class="org-keyword">define</span> (<span class="org-function-name">semaphore-release!</span> semaphore)
  (semaphore 'release!))

(<span class="org-keyword">define</span> (<span class="org-function-name">with-semaphore-acquired</span> semaphore thunk)
  (dynamic-wind
      (<span class="org-keyword">lambda</span> () (semaphore-acquire! semaphore))
      thunk
      (<span class="org-keyword">lambda</span> () (semaphore-release! semaphore))))

(<span class="org-keyword">let</span> ((semaphore (make-semaphore 2))
      (result '()))
  (parallel-execute
   (<span class="org-keyword">lambda</span> () (with-semaphore-acquired semaphore
           (<span class="org-keyword">lambda</span> ()
             (thread-sleep! 0.1)
             (set! result (cons 2 result)))))
   <span class="org-comment-delimiter">;; </span><span class="org-comment">This should run last.</span>
   (<span class="org-keyword">lambda</span> () (with-semaphore-acquired semaphore
           (<span class="org-keyword">lambda</span> ()
             (thread-sleep! 0.2)
             (test result '(1 2)))))
   (<span class="org-keyword">lambda</span> () (with-semaphore-acquired semaphore
           (<span class="org-keyword">lambda</span> ()
             (set! result (cons 1 result)))))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-191" class="outline-2">
<h2 id="sec-191"><span class="section-number-2">191</span> <span class="done DONE">DONE</span> 3.48</h2>
<div class="outline-text-2" id="text-191">
<p>
There are four cases of locking order, two of which result in
deadlock:
</p>

<table id="tab:deadlock" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-bottom"><span class="table-number">Table 3:</span> Locking order and deadlock</caption>

<colgroup>
<col  class="right" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="right">Scenario</th>
<th scope="col" class="left">\(Peter_1\)</th>
<th scope="col" class="left">\(Paul_1\)</th>
<th scope="col" class="left">\(Peter_2\)</th>
<th scope="col" class="left">\(Paul_2\)</th>
<th scope="col" class="left">Deadlock?</th>
</tr>
</thead>
<tbody>
<tr>
<td class="right">1</td>
<td class="left">\(a1\)</td>
<td class="left">\(a2\)</td>
<td class="left">\(a2\)</td>
<td class="left">\(a1\)</td>
<td class="left">Yes</td>
</tr>

<tr>
<td class="right">2</td>
<td class="left">\(a1\)</td>
<td class="left">\(a1\)</td>
<td class="left">\(a2\)</td>
<td class="left">\(a2\)</td>
<td class="left">No</td>
</tr>

<tr>
<td class="right">3</td>
<td class="left">\(a2\)</td>
<td class="left">\(a1\)</td>
<td class="left">\(a1\)</td>
<td class="left">\(a2\)</td>
<td class="left">Yes</td>
</tr>

<tr>
<td class="right">4</td>
<td class="left">\(a2\)</td>
<td class="left">\(a2\)</td>
<td class="left">\(a1\)</td>
<td class="left">\(a1\)</td>
<td class="left">No</td>
</tr>
</tbody>
</table>

<p>
Enforcing a locking order based on the account number constrains the
locking order to scenarios 2 and 4; we’ve implemented this by
sorting serializers by account number, composing them and finally
applying them to the accounts:
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">serialized-exchange</span> account1 account2)
  (<span class="org-keyword">let</span> ((serializers (sort-serializers account1 account2)))
    (((apply compose serializers) exchange)
     account1
     account2)))
</pre>
</div>

<p>
Here is the complete code:
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use data-structures sicp-concurrency srfi-95 test)

(<span class="org-keyword">define</span> <span class="org-function-name">current-account-number</span> (make-parameter 0))

(<span class="org-keyword">define</span> (<span class="org-function-name">exchange</span> account1 account2)
  (<span class="org-keyword">let</span> ((difference (- (account1 'balance)
                       (account2 'balance))))
    ((account1 'withdraw) difference)
    ((account2 'deposit) difference)))

(<span class="org-keyword">define</span> (<span class="org-function-name">make-account-and-serializer</span> balance)
  (<span class="org-keyword">define</span> <span class="org-function-name">account-number</span>
    (current-account-number (+ (current-account-number) 1)))
  (<span class="org-keyword">define</span> (<span class="org-function-name">withdraw</span> amount)
    (<span class="org-keyword">if</span> (&gt;= balance amount)
        (<span class="org-keyword">begin</span> (set! balance (- balance amount))
               balance)
        <span class="org-string">"Insufficient funds"</span>))
  (<span class="org-keyword">define</span> (<span class="org-function-name">deposit</span> amount)
    (set! balance (+ balance amount))
    balance)
  (<span class="org-keyword">let</span> ((balance-serializer (make-serializer)))
    (<span class="org-keyword">define</span> (<span class="org-function-name">dispatch</span> m)
      (<span class="org-keyword">cond</span> ((eq? m 'withdraw) withdraw)
            ((eq? m 'deposit) deposit)
            ((eq? m 'balance) balance)
            ((eq? m 'serializer) balance-serializer)
            ((eq? m 'account-number) account-number)
            (<span class="org-keyword">else</span> (error <span class="org-string">"Unknown request: MAKE-ACCOUNT"</span> m))))
    dispatch))

(<span class="org-keyword">define</span> (<span class="org-function-name">deposit</span> account amount)
  (<span class="org-keyword">let</span> ((s (account 'serializer))
        (d (account 'deposit)))
    ((s d) amount)))

(<span class="org-keyword">define</span> (<span class="org-function-name">account-number</span> account)
  (account 'account-number))

(<span class="org-keyword">define</span> (<span class="org-function-name">serializer</span> account)
  (account 'serializer))

(<span class="org-keyword">define</span> (<span class="org-function-name">sort-accounts</span> accounts)
  (sort accounts &lt; account-number))

(<span class="org-keyword">define</span> (<span class="org-function-name">sort-serializers</span> . accounts)
  (<span class="org-keyword">map</span> serializer (sort-accounts accounts)))

<span class="org-comment-delimiter">;; </span><span class="org-comment">This works by sorting the serializers by account-number of the</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">adherent accounts, composing and finally applying them to the</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">accounts.</span>
(<span class="org-keyword">define</span> (<span class="org-function-name">serialized-exchange</span> account1 account2)
  (<span class="org-keyword">let</span> ((serializers (sort-serializers account1 account2)))
    (((apply compose serializers) exchange)
     account1
     account2)))

(<span class="org-keyword">let</span> ((peter (make-account-and-serializer 100))
      (paul (make-account-and-serializer 10)))
  (exchange peter paul)
  (test 10 (peter 'balance)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-192" class="outline-2">
<h2 id="sec-192"><span class="section-number-2">192</span> <span class="done DONE">DONE</span> 3.49</h2>
<div class="outline-text-2" id="text-192">
<p>
In the <a href="#sec-191">implementation above</a>, the account-numbers are constants whose
read-write interlocks are governed by the operating-system itself;
one could imagine a scenario, however, in which the account-numbers
can change and access to them needs to be serialized.
</p>

<p>
In such a scenario, the <a href="#tab:deadlock">deadlock table</a> still applies; but the
problem has been pushed one level higher.
</p>
</div>
</div>
<div id="outline-container-sec-193" class="outline-2">
<h2 id="sec-193"><span class="section-number-2">193</span> <span class="done DONE">DONE</span> 3.50</h2>
<div class="outline-text-2" id="text-193">
<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">stream-map</span> proc . argstreams)
  (<span class="org-keyword">if</span> (any stream-null? argstreams)
      stream-null
      (cons-stream
       (apply proc (<span class="org-keyword">map</span> stream-car argstreams))
       (apply stream-map
              (cons proc (<span class="org-keyword">map</span> stream-cdr argstreams))))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp-streams test)

(include <span class="org-string">"stream-map.scm"</span>)

(<span class="org-keyword">let</span> ((iota (stream-enumerate-interval 0 2))
      (kappa (stream-enumerate-interval 2 4)))
  (test '(0 3 8) (stream-&gt;list (stream-map * iota kappa))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-194" class="outline-2">
<h2 id="sec-194"><span class="section-number-2">194</span> <span class="done DONE">DONE</span> 3.51</h2>
<div class="outline-text-2" id="text-194">
<p>
Because the <code>car</code> of the stream is not lazy, <code>stream-map</code> generates
a 0; <code>(stream-ref x 5)</code> consumes the next four numbers (since 0 was
memoized), plus a non-lazy 5th (the <code>car</code> of the next cell); and
similarly <code>(stream-ref x 7)</code>: 0 through 5 are memoized, it consumes
6 plus the next one.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use ports sicp-streams test)

(<span class="org-keyword">define</span> (<span class="org-function-name">show</span> x) (display x) x)

(<span class="org-keyword">let</span> ((x (make-parameter #f)))
  (test <span class="org-string">"0"</span>
        (with-output-to-string
          (<span class="org-keyword">lambda</span> ()
            (x (stream-map show (stream-enumerate-interval 0 10))))))
  (test <span class="org-string">"12345"</span>
        (with-output-to-string
          (<span class="org-keyword">lambda</span> () (stream-ref (x) 5))))
  (test <span class="org-string">"67"</span>
        (with-output-to-string
          (<span class="org-keyword">lambda</span> () (stream-ref (x) 7)))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-195" class="outline-2">
<h2 id="sec-195"><span class="section-number-2">195</span> <span class="done DONE">DONE</span> 3.52</h2>
<div class="outline-text-2" id="text-195">
<p>
Since the first element of streams are non-lazy, <code>stream-map</code>
produces 1; <code>stream-filter</code> produces 6, since it eagerly evaluates
to the first even number and then one (i.e., it contains a
<code>cons-stream</code>); the second <code>stream-filter</code> produces 10 and stops
(i.e., it does not contains a <code>cons-stream</code>).
</p>

<p>
<code>(Stream-ref y 7)</code> consumes to 14, ignoring elements already
consumed (i.e., memoized); and <code>display-stream</code> consumes the rest.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp-streams test)

(<span class="org-keyword">define</span> <span class="org-function-name">sum</span> 0)

(<span class="org-keyword">define</span> (<span class="org-function-name">accum</span> x) (set! sum (+ x sum)) sum)

(<span class="org-keyword">define</span> <span class="org-function-name">seq</span>
  (stream-map accum
              (stream-enumerate-interval 1 20)))

(test 1 sum)

(<span class="org-keyword">define</span> <span class="org-function-name">y</span> (stream-filter even? seq))

(test 6 sum)

(<span class="org-keyword">define</span> <span class="org-function-name">z</span>
  (stream-filter (<span class="org-keyword">lambda</span> (x) (= (remainder x 5) 0))
                 seq))

(test 10 sum)

(stream-ref y 7)

(test 136 sum)

(display-stream z)

(test 210 sum)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-196" class="outline-2">
<h2 id="sec-196"><span class="section-number-2">196</span> <span class="done DONE">DONE</span> 3.53</h2>
<div class="outline-text-2" id="text-196">
<p>
The elements of the stream should be powers of two, e.g. \(1, 2, 4,
  8, ..., n^2\).
</p>

<p>
The first element is one; the second is one plus one; the third, one
plus one plus one plus one; etc.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(include <span class="org-string">"stream-map.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">add-streams</span> s1 s2) (stream-map + s1 s2))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use debug sicp-streams test)

(include <span class="org-string">"add-streams.scm"</span>)

(<span class="org-keyword">define</span> <span class="org-function-name">s</span> (cons-stream 1 (add-streams s s)))

(test '(1 2 4 8) (stream-&gt;list s 4))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-197" class="outline-2">
<h2 id="sec-197"><span class="section-number-2">197</span> <span class="done DONE">DONE</span> 3.54</h2>
<div class="outline-text-2" id="text-197">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp-streams test)

(include <span class="org-string">"stream-map.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">mul-streams</span> s1 s2) (stream-map * s1 s2))

(<span class="org-keyword">define</span> <span class="org-function-name">factorial</span>
  (cons-stream 1 (mul-streams factorial integers)))

(test '(1 1 2 6 24 120) (stream-&gt;list factorial 6))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-198" class="outline-2">
<h2 id="sec-198"><span class="section-number-2">198</span> <span class="done DONE">DONE</span> 3.55</h2>
<div class="outline-text-2" id="text-198">
<p>
Interestingly, this is not correct (where the precedence of
<code>partial-sums</code> over <code>add-streams</code> has been swapped in the
recursion):
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">partial-sums</span> stream)
  (cons-stream (stream-car stream)
               (partial-sums (add-streams (stream-cdr stream)
                                          stream))))
</pre>
</div>

<p>
It yields instead <code>(1 3 8 20 48)</code>; why?
</p>

<div class="org-src-container">

<pre class="src src-scheme">(include <span class="org-string">"add-streams.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">partial-sums</span> stream)
  (cons-stream (stream-car stream)
               (add-streams (stream-cdr stream)
                            (partial-sums stream))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp-streams test)

(include <span class="org-string">"partial-sums.scm"</span>)

(test '(1 3 6 10 15)
      (stream-&gt;list (partial-sums integers) 5))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-199" class="outline-2">
<h2 id="sec-199"><span class="section-number-2">199</span> <span class="done DONE">DONE</span> 3.56</h2>
<div class="outline-text-2" id="text-199">
<p>
<a href="http://en.wikipedia.org/wiki/Regular_number">Regular numbers</a>, e.g. Hamming numbers; also \(k\)-smooth, where \(k =
  5\). See <a href="http://www.cs.utexas.edu/users/EWD/ewd07xx/EWD792.PDF">Dijkstra's solution</a>.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp-streams test)

(<span class="org-keyword">define</span> <span class="org-function-name">hamming-numbers</span>
  (cons-stream 1 (merge (scale-stream hamming-numbers 2)
                        (merge (scale-stream hamming-numbers 3)
                               (scale-stream hamming-numbers 5)))))

(test '(1 2 3 4 5 6 8 9 10 12 15 16 18 20 24 25 27 30 32 36)
      (stream-&gt;list hamming-numbers 20))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-200" class="outline-2">
<h2 id="sec-200"><span class="section-number-2">200</span> <span class="done DONE">DONE</span> 3.57</h2>
<div class="outline-text-2" id="text-200">
<p>
<code>Fibs</code> provides 0 and 1; and every subsequent call thereafter to
<code>add-streams</code> only does one new addition on <code>(stream-cdr fibs)</code>, the
rest are memoized.
</p>

<p>
For the \(n^th\) Fibonacci number, therefore, there are \(n - 1\)
additions; an unmemoized Fibonacci would suffer the same exponential
complexity as the naïve recursive formulation.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp-streams test)

(include <span class="org-string">"stream-map.scm"</span>)

(<span class="org-keyword">define</span> <span class="org-function-name">additions</span> (make-parameter 0))

(<span class="org-keyword">define</span> (<span class="org-function-name">add</span> x y) (additions (+ (additions) 1))
  (+ x y))

(<span class="org-keyword">define</span> (<span class="org-function-name">add-streams</span> s1 s2) (stream-map add s1 s2))

(<span class="org-keyword">define</span> <span class="org-function-name">fibs</span>
  (cons-stream
   0
   (cons-stream 1 (add-streams (stream-cdr fibs) fibs))))

(stream-&gt;list fibs 10)

(test 9 (additions))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-201" class="outline-2">
<h2 id="sec-201"><span class="section-number-2">201</span> <span class="done DONE">DONE</span> 3.58</h2>
<div class="outline-text-2" id="text-201">
<p>
<code>Expand</code> is the decimal expansion in some radix of
\(\frac{num}{den}\); it works by consing the quotient (like a <code>car</code>)
to the remainder (like a <code>cdr</code>) recursively.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp-streams test)

(<span class="org-keyword">define</span> (<span class="org-function-name">expand</span> num den radix)
  (cons-stream
   (quotient (* num radix) den)
   (expand (remainder (* num radix) den) den radix)))

(test '(1 4 2 8 5 7 1 4 2 8 5 7)
      (stream-&gt;list (expand 1 7 10) 12))
(test '(3 7 5 0 0 0 0)
      (stream-&gt;list (expand 3 8 10) 7))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-202" class="outline-2">
<h2 id="sec-202"><span class="section-number-2">202</span> <span class="done DONE">DONE</span> 3.59</h2>
<div class="outline-text-2" id="text-202">
<div class="org-src-container">

<pre class="src src-scheme">(include <span class="org-string">"stream-map.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">integrate-series</span> coefficients)
  (stream-map (<span class="org-keyword">lambda</span> (integral coefficient)
                (* (/ 1 integral) coefficient))
              integers
              coefficients))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp-streams test)

(include <span class="org-string">"integrate-series.scm"</span>)

(<span class="org-keyword">define</span> <span class="org-function-name">ones</span> (cons-stream 1 ones))

(test '(1 1/2 1/3 1/4 1/5)
      (stream-&gt;list (integrate-series ones) 5))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(include <span class="org-string">"integrate-series.scm"</span>)

(<span class="org-keyword">define</span> <span class="org-function-name">cosine-series</span>
  (cons-stream 1 (stream-map - (integrate-series sine-series))))

(<span class="org-keyword">define</span> <span class="org-function-name">sine-series</span>
  (cons-stream 0 (integrate-series cosine-series)))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use numbers sicp-streams test)

(include <span class="org-string">"trig-series.scm"</span>)

(test '(1 0 -1/2 0 1/24) (stream-&gt;list cosine-series 5))
(test '(0 1 0 -1/6 0) (stream-&gt;list sine-series 5))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-203" class="outline-2">
<h2 id="sec-203"><span class="section-number-2">203</span> <span class="done DONE">DONE</span> 3.60</h2>
<div class="outline-text-2" id="text-203">
<div class="org-src-container">

<pre class="src src-scheme">(include <span class="org-string">"add-streams.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">mul-series</span> s1 s2)
  (cons-stream (* (stream-car s1) (stream-car s2))
               (add-streams
                (scale-stream (stream-cdr s2) (stream-car s1))
                (mul-series (stream-cdr s1) s2))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp-streams test)

(include <span class="org-string">"add-streams.scm"</span>)
(include <span class="org-string">"mul-series.scm"</span>)
(include <span class="org-string">"trig-series.scm"</span>)

(test 1.0
      (apply
       +
       (stream-&gt;list
        (add-streams (mul-series sine-series sine-series)
                     (mul-series cosine-series cosine-series))
        10)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-204" class="outline-2">
<h2 id="sec-204"><span class="section-number-2">204</span> <span class="done DONE">DONE</span> 3.61</h2>
<div class="outline-text-2" id="text-204">
<div class="org-src-container">

<pre class="src src-scheme">(include <span class="org-string">"mul-series.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">invert-unit-series</span> series)
  (cons-stream 1 (stream-map - (mul-series (stream-cdr series)
                                           (invert-unit-series series)))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp-streams test)

(include <span class="org-string">"invert-unit-series.scm"</span>)
(include <span class="org-string">"mul-series.scm"</span>)
(include <span class="org-string">"trig-series.scm"</span>)

(test 1.0
      (apply +
             (stream-&gt;list (mul-series cosine-series
                                       (invert-unit-series cosine-series))
                           5)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-205" class="outline-2">
<h2 id="sec-205"><span class="section-number-2">205</span> <span class="done DONE">DONE</span> 3.62</h2>
<div class="outline-text-2" id="text-205">
<p>
Since \(\tan \theta = \frac{\sin \theta}{\cos \theta}\); and since the
<a href="http://en.wikipedia.org/wiki/Taylor_series#List_of_Maclaurin_series_of_some_common_functions">Maclaurin series of tan</a> is \(x + \frac{x^3}{3} + \frac{2x^5}{15} +
  \dots\):
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp-streams test)

(include <span class="org-string">"mul-series.scm"</span>)
(include <span class="org-string">"invert-unit-series.scm"</span>)
(include <span class="org-string">"trig-series.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">div-series</span> s1 s2)
  (<span class="org-keyword">if</span> (zero? (stream-car s2))
      (error <span class="org-string">"Division by zero: DIV-SERIES"</span>)
      (mul-series s1 (invert-unit-series s2))))

(<span class="org-keyword">define</span> <span class="org-function-name">tan-series</span> (div-series sine-series cosine-series))

(parameterize ((current-test-epsilon 0.001))
  (test
   (tan 1)
   (apply + (stream-&gt;list tan-series 16))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-206" class="outline-2">
<h2 id="sec-206"><span class="section-number-2">206</span> <span class="done DONE">DONE</span> 3.63</h2>
<div class="outline-text-2" id="text-206">
<p>
<code>Guesses</code> is a recursive stream that itself depends upon <code>guesses</code>;
this gives <code>memo-proc</code> a chance to reify the stream, which would not
be the case of it called <code>sqrt-stream</code> again.
</p>
</div>
</div>
<div id="outline-container-sec-207" class="outline-2">
<h2 id="sec-207"><span class="section-number-2">207</span> <span class="done DONE">DONE</span> 3.64</h2>
<div class="outline-text-2" id="text-207">
<p>
Contrary to the footnote in SICP, it’s possible to use <code>letrec</code>
instead of <code>define</code> in <code>sqrt-stream</code>.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">stream-limit</span> stream tolerance)
  (<span class="org-keyword">let</span> <span class="org-function-name">iter</span> ((car (stream-car stream))
             (cdr (stream-cdr stream))
             (iterations 0))
    (<span class="org-keyword">let</span> ((cadr (stream-car cdr)))
      (<span class="org-keyword">if</span> (&lt; (abs (- cadr car)) tolerance)
          (values cadr iterations)
          (iter cadr (stream-cdr cdr) (+ iterations 1))))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp sicp-streams test)

(include <span class="org-string">"stream-limit.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">sqrt-improve</span> guess x)
  (average guess (/ x guess)))

(<span class="org-keyword">define</span> (<span class="org-function-name">sqrt-stream</span> x)
  (<span class="org-keyword">letrec</span> ((guesses
            (cons-stream 1.0
                         (stream-map
                          (<span class="org-keyword">lambda</span> (guess) (sqrt-improve guess x))
                          guesses))))
    guesses))

(test (sqrt 2) (stream-limit (sqrt-stream 2) 0.001))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-208" class="outline-2">
<h2 id="sec-208"><span class="section-number-2">208</span> <span class="done DONE">DONE</span> 3.65</h2>
<div class="outline-text-2" id="text-208">
<p>
It takes seven iterations to get to within \(10e-14\) of \(\ln 2\).
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp sicp-streams test)

(include <span class="org-string">"partial-sums.scm"</span>)
(include <span class="org-string">"stream-limit.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">ln2-summands</span> n)
  (cons-stream (/ 1.0 n)
               (stream-map - (ln2-summands (+ n 1)))))

(<span class="org-keyword">define</span> <span class="org-function-name">ln2-stream</span>
  (partial-sums (ln2-summands 1)))

(receive (ln2 iterations)
  (stream-limit
   (accelerated-sequence euler-transform ln2-stream) 1e-14)
  (test ln2 (log 2))
  (test 7 iterations))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-209" class="outline-2">
<h2 id="sec-209"><span class="section-number-2">209</span> <span class="todo TODO">TODO</span> 3.66</h2>
<div class="outline-text-2" id="text-209">
<p>
Each row \(i\) (\(R_i\)) of the matrix grows by \(\log^i_2 |R_0|\); such
that, for instance, if \(R_0\) grows by \(n\) (i.e., \(\log^0_2 |R_0|\)),
row \(i\) grows by \(\log^i_2 n\).
</p>

<p>
Here are the first fifteen elements up to <code>(3 3)</code>:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />
</colgroup>

<colgroup>
<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="right">&#xa0;</th>
<th scope="col" class="right">0</th>
<th scope="col" class="right">1</th>
<th scope="col" class="right">2</th>
<th scope="col" class="right">3</th>
<th scope="col" class="right">4</th>
<th scope="col" class="right">5</th>
<th scope="col" class="right">6</th>
<th scope="col" class="right">7</th>
</tr>
</thead>
<tbody>
<tr>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">2</td>
<td class="right">4</td>
<td class="right">6</td>
<td class="right">8</td>
<td class="right">10</td>
<td class="right">12</td>
<td class="right">14</td>
</tr>

<tr>
<td class="right">1</td>
<td class="right">&#xa0;</td>
<td class="right">3</td>
<td class="right">5</td>
<td class="right">9</td>
<td class="right">13</td>
<td class="right">&#xa0;</td>
<td class="right">&#xa0;</td>
<td class="right">&#xa0;</td>
</tr>

<tr>
<td class="right">2</td>
<td class="right">&#xa0;</td>
<td class="right">&#xa0;</td>
<td class="right">7</td>
<td class="right">11</td>
<td class="right">&#xa0;</td>
<td class="right">&#xa0;</td>
<td class="right">&#xa0;</td>
<td class="right">&#xa0;</td>
</tr>

<tr>
<td class="right">3</td>
<td class="right">&#xa0;</td>
<td class="right">&#xa0;</td>
<td class="right">&#xa0;</td>
<td class="right">15</td>
<td class="right">&#xa0;</td>
<td class="right">&#xa0;</td>
<td class="right">&#xa0;</td>
<td class="right">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
For a pair \((x, y)\), there are \(\max(x, \log_2 y)\) number of rows;
the total number of elements is at least \(\sum_{i=0}^{\max(x, \log_2
  y) - 1} 2^i\).
</p>

<p>
This is, incidentally, an exact guess for the number of pairs
preceding a diagonal.
</p>

<p>
TODO: It would be nice to get a better bound for non-diagonals!
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp-streams srfi-1 test)

(<span class="org-keyword">define</span> (<span class="org-function-name">stream-index</span> pred . streams)
  (<span class="org-keyword">let</span> <span class="org-function-name">iter</span> ((index 0)
             (streams streams))
    (<span class="org-keyword">if</span> (any stream-null? streams)
        #f
        (<span class="org-keyword">if</span> (apply pred (<span class="org-keyword">map</span> stream-car streams))
            index
            (iter (+ index 1) (<span class="org-keyword">map</span> stream-cdr streams))))))

(<span class="org-keyword">define</span> (<span class="org-function-name">pair-index</span> pair stream)
  (stream-index (cute equal? &lt;&gt; pair) stream))

(<span class="org-keyword">define</span> (<span class="org-function-name">lower-bound</span> pair)
  (<span class="org-keyword">let</span> ((x (car pair))
        (y (cadr pair)))
    (<span class="org-keyword">let</span> <span class="org-function-name">iter</span> ((row (- (max x (/ (log y) (log 2))) 1))
               (lower-bound 0))
      (<span class="org-keyword">if</span> (<span class="org-keyword">or</span> (zero? row) (negative? row))
          (inexact-&gt;exact (floor lower-bound))
          (iter (- row 1) (+ lower-bound (expt 2 row)))))))

(<span class="org-keyword">let</span> ((integer-pairs (<span class="org-keyword">lambda</span> () (pairs integers integers))))
  (test '((1 1) (1 2) (2 2) (1 3) (2 3) (1 4) (3 3) (1 5)
          (2 4) (1 6) (3 4) (1 7) (2 5) (1 8) (4 4))
    (stream-&gt;list (integer-pairs) 15))

  (test <span class="org-string">"The lower bound is exact on diagonals"</span>
        (pair-index '(10 10) (integer-pairs))
        (lower-bound '(10 10)))

  <span class="org-comment-delimiter">;; </span><span class="org-comment">For the case where y = 10.</span>
  (<span class="org-keyword">let</span> ((pair-indexes
         (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (x) (pair-index (list x 10) (integer-pairs)))
              (iota 10 1)))
        (lower-bounds
         (<span class="org-keyword">map</span> (<span class="org-keyword">lambda</span> (x) (lower-bound (list x 10)))
              (iota 10 1))))
    (test
     pair-indexes
     '(17 32 58 102 174 286 446 638 766 1022))

    (test
     lower-bounds
     '(8 8 8 14 30 62 126 254 510 1022))

    (test-assert (every &lt;= lower-bounds pair-indexes))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-210" class="outline-2">
<h2 id="sec-210"><span class="section-number-2">210</span> <span class="done DONE">DONE</span> 3.67</h2>
<div class="outline-text-2" id="text-210">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp-streams test)

(<span class="org-keyword">define</span> (<span class="org-function-name">all-pairs</span> s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (interleave
    (stream-map (<span class="org-keyword">lambda</span> (x) (list (stream-car s) x))
                (stream-cdr t))
    (interleave
     (stream-map (<span class="org-keyword">lambda</span> (y) (list (stream-car t) y))
                 (stream-cdr s))
     (all-pairs (stream-cdr s) (stream-cdr t))))))

(<span class="org-keyword">define</span> (<span class="org-function-name">stream-index</span> pred . streams)
  (<span class="org-keyword">let</span> <span class="org-function-name">iter</span> ((index 0)
             (streams streams))
    (<span class="org-keyword">if</span> (any stream-null? streams)
        #f
        (<span class="org-keyword">if</span> (apply pred (<span class="org-keyword">map</span> stream-car streams))
            index
            (iter (+ index 1) (<span class="org-keyword">map</span> stream-cdr streams))))))

(<span class="org-keyword">define</span> (<span class="org-function-name">pair-index</span> pair stream)
  (stream-index (cute equal? &lt;&gt; pair) stream))

(<span class="org-keyword">let</span> ((pairs (all-pairs integers integers)))
   (test 17 (pair-index '(1 10) pairs))
   (test 64 (pair-index '(2 10) pairs))
   (test 228 (pair-index '(3 10) pairs)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-211" class="outline-2">
<h2 id="sec-211"><span class="section-number-2">211</span> <span class="done DONE">DONE</span> 3.68</h2>
<div class="outline-text-2" id="text-211">
<p>
Louis’s definition of <code>pairs</code> goes into an infinite recursion with
<code>(pairs integers integers)</code>, since the recursive case forces the
streams.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use sicp-streams test)

(<span class="org-keyword">define</span> (<span class="org-function-name">pairs</span> s t)
  (interleave
   (stream-map (<span class="org-keyword">lambda</span> (x) (list (stream-car s) x))
               t)
   (pairs (stream-cdr s) (stream-cdr t))))

(test-assert (not (terminates? (<span class="org-keyword">lambda</span> () (pairs integers integers)))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-212" class="outline-2">
<h2 id="sec-212"><span class="section-number-2">212</span> <span class="done DONE">DONE</span> 3.69</h2>
<div class="outline-text-2" id="text-212">
<p>
The third element of the triples is still generated much more
quickly than the first two; is there a way to homogenize them?
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use bindings debug sicp sicp-streams test)

(<span class="org-keyword">define</span> (<span class="org-function-name">triples</span> s t u)
  (cons-stream (list (stream-car s) (stream-car t) (stream-car u))
               (interleave
                (interleave
                 <span class="org-comment-delimiter">;; </span><span class="org-comment">Generate along x.</span>
                 (stream-map (<span class="org-keyword">lambda</span> (z) (list (stream-car s)
                                          (stream-car t)
                                          z))
                             (stream-cdr u))
                 <span class="org-comment-delimiter">;; </span><span class="org-comment">Generate along x and y.</span>
                 (stream-map (<span class="org-keyword">lambda</span> (pair)
                               (list (stream-car s)
                                     (car pair)
                                     (cadr pair)))
                             (pairs (stream-cdr t)
                                    (stream-cdr u))))
                (triples (stream-cdr s)
                         (stream-cdr t)
                         (stream-cdr u)))))

(test '((3 4 5) (6 8 10) (5 12 13))
      (stream-&gt;list
       (stream-filter
        (bind-lambda (i j k)
                (= (+ (square i) (square j)) (square k)))
        (triples integers integers integers))
       3))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-213" class="outline-2">
<h2 id="sec-213"><span class="section-number-2">213</span> <span class="done DONE">DONE</span> 3.70</h2>
<div class="outline-text-2" id="text-213">
<p>
We borrowed the definition of Hamming numbers from <a href="#sec-199">199</a>.
</p>

<div class="org-src-container">

<pre class="src src-scheme">(<span class="org-keyword">define</span> (<span class="org-function-name">weighted-merge</span> weight s1 s2)
  (<span class="org-keyword">cond</span> ((stream-null? s1) s2)
        ((stream-null? s2) s1)
        (<span class="org-keyword">else</span>
         (<span class="org-keyword">let</span> ((s1car (stream-car s1))
               (s2car (stream-car s2)))
           (<span class="org-keyword">cond</span> ((&lt; (weight s1car) (weight s2car))
                  (cons-stream
                   s1car
                   (weighted-merge weight (stream-cdr s1) s2)))
                 (<span class="org-keyword">else</span>
                  (cons-stream
                   s2car
                   (weighted-merge weight s1 (stream-cdr s2)))))))))

(<span class="org-keyword">define</span> (<span class="org-function-name">weighted-pairs</span> weight s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (weighted-merge
    weight
    (stream-map (<span class="org-keyword">lambda</span> (x) (list (stream-car s) x))
                (stream-cdr t))
    (weighted-pairs weight (stream-cdr s) (stream-cdr t)))))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-scheme">(use bindings sicp-streams srfi-1 test)

(include <span class="org-string">"weighted-pairs.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">test-weighted-pairs</span> weight pairs)
  (<span class="org-keyword">let</span> ((pairs (stream-&gt;list pairs 16)))
    (every (<span class="org-keyword">lambda</span> (p1 p2) (&lt;= (weight p1) (weight p2)))
         pairs
         (cdr pairs))))

(<span class="org-keyword">let*</span> ((addition-weight (cut apply + &lt;&gt;))
       (addition-weighted-integer-pairs
        (weighted-pairs addition-weight integers integers)))
  (test-assert (test-weighted-pairs
                addition-weight
                addition-weighted-integer-pairs))
  (test '((1 1) (1 2) (2 2) (1 3) (2 3) (1 4) (3 3) (2 4) (1 5) (3 4) (2 5)
          (1 6) (4 4) (3 5) (2 6) (1 7))
        (stream-&gt;list addition-weighted-integer-pairs 16)))

(<span class="org-keyword">letrec</span> ((hamming-numbers
          (cons-stream 1 (merge (scale-stream hamming-numbers 2)
                                (merge (scale-stream hamming-numbers 3)
                                       (scale-stream hamming-numbers 5))))))
  (<span class="org-keyword">let*</span> ((weight (bind-lambda (i j) (+ (* 2 i) (* 3 j) (* 5 i j))))
         (weighted-hamming-pairs
          (weighted-pairs weight hamming-numbers hamming-numbers)))
    (test-assert (test-weighted-pairs weight weighted-hamming-pairs))
    (test '((1 1) (1 2) (1 3) (2 2) (1 4) (1 5) (2 3) (1 6) (2 4) (3 3)
            (1 8) (2 5) (1 9) (3 4) (2 6) (1 10))
          (stream-&gt;list weighted-hamming-pairs 16))))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-214" class="outline-2">
<h2 id="sec-214"><span class="section-number-2">214</span> <span class="done DONE">DONE</span> 3.71</h2>
<div class="outline-text-2" id="text-214">
<p>
We had to resort to some type-puns to get around the fact that we
don’t have a multi-value <code>stream-filter</code> (a <code>stream-map</code>, namely,
that either returns the first of equals pairs or <code>#f</code>).
</p>

<div class="org-src-container">

<pre class="src src-scheme">(use bindings sicp-streams test)

(include <span class="org-string">"stream-map.scm"</span>)
(include <span class="org-string">"weighted-pairs.scm"</span>)

(<span class="org-keyword">let*</span> ((weight (bind-lambda (i j) (+ (expt i 3) (expt j 3))))
       (weighted-pairs (stream-map weight (weighted-pairs weight integers integers))))
  (test '(1729 4104 13832 20683 32832 39312)
        (stream-&gt;list
         (stream-filter
          identity
          (stream-map (<span class="org-keyword">lambda</span> (x y) (<span class="org-keyword">and</span> (= x y) x))
                      weighted-pairs
                      (stream-cdr weighted-pairs)))
         6)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-215" class="outline-2">
<h2 id="sec-215"><span class="section-number-2">215</span> <span class="done DONE">DONE</span> 3.72</h2>
<div class="outline-text-2" id="text-215">
<div class="org-src-container">

<pre class="src src-scheme">(use bindings sicp sicp-streams test)

(include <span class="org-string">"stream-map.scm"</span>)
(include <span class="org-string">"weighted-pairs.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">square-pair</span> p)
  (+ (square (car p))
     (square (cadr p))))

(<span class="org-keyword">let*</span> ((weight (bind-lambda (i j) (+ (expt i 2) (expt j 2))))
       (weighted-pairs (weighted-pairs weight integers integers)))
  (test '(((10 15) (6 17) (1 18))
          ((13 16) (8 19) (5 20))
          ((17 19) (11 23) (5 25))
          ((14 23) (10 25) (7 26))
          ((19 22) (13 26) (2 29))
          ((15 25) (11 27) (3 29)))
        (stream-&gt;list
         (stream-filter
          identity
          (stream-map (<span class="org-keyword">lambda</span> (p1 p2 p3)
                        (<span class="org-keyword">and</span> (= (square-pair p1)
                                (square-pair p2))
                             (= (square-pair p2)
                                (square-pair p3))
                             (list p1 p2 p3)))
                      weighted-pairs
                      (stream-cdr weighted-pairs)
                      (stream-cdr (stream-cdr weighted-pairs))))
         6)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-216" class="outline-2">
<h2 id="sec-216"><span class="section-number-2">216</span> <span class="done DONE">DONE</span> 3.73</h2>
<div class="outline-text-2" id="text-216">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp-streams test)

(include <span class="org-string">"add-streams.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">integral</span> integrand initial-value dt)
  (<span class="org-keyword">define</span> <span class="org-function-name">int</span>
    (cons-stream initial-value
                 (add-streams (scale-stream integrand dt)
                              int)))
  int)

(<span class="org-keyword">define</span> (<span class="org-function-name">RC</span> R C dt)
  (<span class="org-keyword">lambda</span> (i v0)
    (add-streams (scale-stream i R)
                 (integral (scale-stream i (/ 1 C))
                           v0
                           dt))))

(<span class="org-keyword">let</span> ((RC1 (RC 5 1 0.5)))
  (test '(5 10.5 16.5 23.0 30.0 37.5)
        (stream-&gt;list (RC1 integers 0) 6)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-217" class="outline-2">
<h2 id="sec-217"><span class="section-number-2">217</span> <span class="done DONE">DONE</span> 3.74</h2>
<div class="outline-text-2" id="text-217">
<div class="org-src-container">

<pre class="src src-scheme">(use sicp-streams test)

(include <span class="org-string">"stream-map.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">sign-change-detector</span> x y)
  (<span class="org-keyword">cond</span> ((<span class="org-keyword">or</span> (zero? x)
             (zero? y)
             (= (signum x) (signum y))) 0)
        ((positive? y) 1)
        (<span class="org-keyword">else</span> -1)))

(<span class="org-keyword">define</span> <span class="org-function-name">sense-data</span>
  (list-&gt;stream '(1 2 1.5 1 0.5 -0.1 -2 -3 -2 -0.5 0.2 3 4)))

(<span class="org-keyword">define</span> <span class="org-function-name">zero-crossings</span>
  (stream-map sign-change-detector sense-data (stream-cdr sense-data)))

(test '(0 0 0 0 -1 0 0 0 0 1 0 0) (stream-&gt;list zero-crossings))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-218" class="outline-2">
<h2 id="sec-218"><span class="section-number-2">218</span> <span class="todo TODO">TODO</span> 3.75</h2>
<div class="outline-text-2" id="text-218">
<div class="org-src-container">

<pre class="src src-scheme">(use debug sicp-streams test)

(include <span class="org-string">"stream-map.scm"</span>)

(<span class="org-keyword">define</span> (<span class="org-function-name">sign-change-detector</span> x y)
  (<span class="org-keyword">cond</span> ((<span class="org-keyword">or</span> (zero? x) (zero? y) (= (signum x) (signum y))) 0)
        ((positive? y) 1)
        (<span class="org-keyword">else</span> -1)))

(<span class="org-keyword">define</span> <span class="org-function-name">sense-data</span>
  (list-&gt;stream '(1 2 1.5 1 0.5 -0.1 -2 -3 -2 -0.5 0.2 3 4)))

(<span class="org-keyword">define</span> (<span class="org-function-name">make-zero-crossings</span> input-stream last-value)
  (<span class="org-keyword">if</span> (stream-null? input-stream)
      stream-null
      (<span class="org-keyword">let</span> ((avpt (/ (+ (stream-car input-stream) last-value) 2)))
        (debug (stream-&gt;list input-stream)
               avpt
               last-value
               (sign-change-detector avpt last-value))
        (cons-stream
         (sign-change-detector avpt last-value)
         (make-zero-crossings
          (stream-cdr input-stream) avpt)))))

(<span class="org-keyword">define</span> <span class="org-function-name">zero-crossings</span>
  (make-zero-crossings sense-data 0))

(stream-&gt;list zero-crossings)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-219" class="outline-2">
<h2 id="sec-219"><span class="section-number-2">219</span> Notes</h2>
<div class="outline-text-2" id="text-219">
</div><div id="outline-container-sec-219-1" class="outline-3">
<h3 id="sec-219-1"><span class="section-number-3">219.1</span> 1</h3>
<div class="outline-text-3" id="text-219-1">
<ul class="org-ul">
<li>Scheme: <code>chicken-bin</code>, <code>racket</code>, <code>mit-scheme</code>.
</li>
<li>“Conjure the spirits of the computer with our spells.”
</li>
<li>Procedures as data
</li>
<li>Prefix notation: convention of placing the operator to the left
of the operands
</li>
<li>Evaluate a combination
<ul class="org-ul">
<li>Evaluate subexpressions of the combination
</li>
<li>Apply the operator to the operands
</li>
</ul>
</li>
<li>Tree accumulation, percolate values upward
</li>
<li>Special forms
</li>
<li><code>(define (square x) (* x x)</code>
</li>
<li>Substitution model
<ul class="org-ul">
<li>Evaluate the body of the procedure with each formal parametr
replaced by the corresponding argument.
</li>
</ul>
</li>
<li>Applicative vs. normal order
<ul class="org-ul">
<li>Applicative: evaluate the arguments then apply (greedy)
</li>
<li>Normal: fully expand, then reduce (lazy, macros, streams)
</li>
</ul>
</li>
<li>Expansion occurs as the process bulids up a chain of deferred
operations; the contraction occurs as the operations are actually
performed.
</li>
<li>Process, characterized by a chain of deferred operations:
recursive process.
</li>
<li>Recursive process, recursive procedure
</li>
<li>In general, the number of steps required by a tree-recursive
process will be proportional to the number of nodes in the tree,
whil the space required will be proportional to the maximum depth
of the tree.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-219-2" class="outline-3">
<h3 id="sec-219-2"><span class="section-number-3">219.2</span> 2</h3>
<div class="outline-text-3" id="text-219-2">
<ul class="org-ul">
<li>It would be much better if we could “glue together” a numerator
and denominator to from a pair—a compound data object–that our
programs could manipulate in a way that would be consistent with
regarding a rational number as a single conceptual unit.
</li>
<li>Isolating how data objects are represented: data abstraction.
</li>
<li>Data abstraction enables us to erect suitable abstraction
barriers between different parts of a program.
</li>
<li>Data-directed programming
</li>
<li>Data abstraction enables us to isolate how a compound data object
is used from the details of how it is constructed.
</li>
<li>We are using here a powerful strategy of synthesis: wishful
thinking.
</li>
<li>List-structured data
</li>
<li>Data abstraction is to identify for each type of data object a
basic set of operations in terms of which all manipulations of
data objects of that type will be expressed.
</li>
<li>The closure property of cons
</li>
<li>See <a href="./papers/waters-method-for-analyzing-loop-programs.pdf">Water's paper</a> on analyzing loops: “plan building methods.”
</li>
<li>In building up a complex image in this manner we are exploiting
the fact that painters are closed under the language’s means of
combination.
</li>
<li>In general, if we want to distinguish \(n\) different symbols, we
will need to use \(log_2n\) bits per symbol.
</li>
<li>Variable vs. fixed-length codes
</li>
<li>At each non-leaf node of the tree there is a set containing all
the symbols in the leaves that lie below.
</li>
<li>Each symbol at a leaf is assigned a weight (which is its relative
frequency).
</li>
<li>Each time we move down a left branch we add a 0; right branch, 1.
</li>
<li>Abstraction barrier
<ul class="org-ul">
<li>Procedures that perform e.g. arithmetic from the procedures
that use e.g. rational numbers.
</li>
</ul>
</li>
<li>Controlling complexity
</li>
<li>Type-tags
</li>
<li>Data-directed programming
</li>
<li>When a generic selector operates on thee e.g. polar type, it
strips off the tag.
</li>
<li>Conversely, when .. constructs a number for general use, .. tag     
it with a type.
</li>
<li>Dispatch on type has each operation takes care of own dispatching,
decomposing the operation-and-type table into rows, with each
generic operation procedure representing a row of the table.
</li>
<li>Alternatively, organize into columns and, instead of using
“intelligent operations” that dispatch on data types, work with
“intelligent data objects” that dispatch on names.
</li>
<li>We can get by with fewer than \(n^2\) coercion procedures. If we
are willing to build the required amount of sophistication into
our system, we can have it search the “graph” of relations among
types and automatically generate those coercion procedures that
can be inferred from the ones that are supplied explicitly.
</li>
<li>Sum of terms: either a coefficint, power of indeterminate,
product of coefficient and power of indeterminate.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-219-3" class="outline-3">
<h3 id="sec-219-3"><span class="section-number-3">219.3</span> 3</h3>
<div class="outline-text-3" id="text-219-3">
<ul class="org-ul">
<li>The language must provide an assignment operator.
</li>
<li>Bang for mutation; quiz for predicates.
</li>
<li>As soon as we introduce assignment into our language, substitution
is no longuer an adequate model of procedure application.
</li>
<li>Environment is a sequence of frames; frame is a table of
bindings.
</li>
<li>Value of variable: value given by the binding of the variable in
the first frame in the environment that contains a binding.
</li>
<li>Unbound: no binding.
</li>
<li>Environmental model: replaces substitution model in specifying
what it means to apply a compound procedure to arguments.
</li>
</ul>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
This is an alternative to wastefully idling and polling, for
instance.
</p></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: Peter Danenberg</p>
<p class="email">Email: <a href="mailto:danenberg@google.com">danenberg@google.com</a></p>
<p class="date">Created: 2015-01-21 Wed 07:15</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.7b)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
