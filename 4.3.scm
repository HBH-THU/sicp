#!/usr/bin/env chicken-scheme

(use debug sicp sicp-eval test)

(put 'eval 'quote (lambda (exp env)
                    (text-of-quotation exp)))
(put 'eval 'set! eval-assignment)
(put 'eval 'define eval-definition)
(put 'eval 'if eval-if)
(put 'eval 'lambda (lambda (exp env)
                (make-procedure (lambda-parameters exp)
                                (lambda-body exp)
                                env)))
(put 'eval 'begin (lambda (exp env)
                    (eval-sequence (begin-actions exp) env)))
(put 'eval 'cond (lambda (exp env)
                   (eval* (cond->if exp) env)))
(put 'eval 'application (lambda (exp env)
                          (apply* (eval* (operator exp) env)
                                  (list-of-values (operands exp) env))))

(define (eval* exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((pair? exp)
         (let ((dispatch (or (get 'eval (car exp))
                             (get 'eval 'application))))
           (dispatch exp env)))))

(parameterize ((primitive-procedures
                (cons `(= ,=) primitive-procedures)))
  (let ((env (setup-environment)))
    (test "Self-evaluation" 2 (eval* 2 env))
    (eval* '(define x 3) env)
    (test "Variable-lookup/definition" 3 (eval* 'x env))
    (eval* '(set! x 2) env)
    (test "Variable-lookup/assignment" 2 (eval* 'x env))
    (test "If/true" 1 (eval* '(if true 1 2) env))
    (test "If/false" 2 (eval* '(if false 1 2) env))
    (test "Lambda" 4 (eval* '((lambda (x) x) 4) env))
    (test "Begin" 5 (eval* '(begin (define y 5) y) env))
    (test "Cond" 3 (eval* '(cond ((= 3 3) 3) (else 2)) env))
    (test-assert "Application" (eval* '(= 3 3) env))))
