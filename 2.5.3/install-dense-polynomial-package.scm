;;; Solutions copyright (C) 2007, Peter Danenberg; http://wizardbook.org
;;; Source code copyright (C) 1996, MIT; http://mitpress.mit.edu/sicp

(load "tag-dense.scm")
(load "add.scm")
(load "mul.scm")
(load "put.scm")
(load "negate.scm")
(load "=zero?.scm")
(load "make-sparse-polynomial.scm")

(define (install-dense-polynomial-package)
  (define tag tag-dense)
  (define (empty-orders? orders) (null? orders))
  (define (first-order orders) (car orders))
  (define (rest-orders orders) (cdr orders))
  (define (make-poly variable orders)
    (list variable orders))
  (define (variable p) (car p))
  (define (orders p) (cadr p))
  (define (add-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (add-orders (orders p1)
                               (orders p2)))
        (error "Polys not in same var -- ADD-POLY"
               (list p1 p2))))

  (define (dense-term-list poly)
    (let ((enumeranda-init (orders poly)))
      (let enumerate-terms ((enumeranda enumeranda-init)
                            (order (- (length enumeranda-init) 1)))
        (if (empty-orders? enumeranda)
            (empty-orders)
            (let ((enumerata (enumerate-terms (rest-orders enumeranda) (- order 1)))
                  (enumerandum (first-order enumeranda)))
              (if (=zero? enumerandum)
                  enumerata
                  (adjoin-order (make-term order (first-order enumeranda)) enumerata)))))))

  (define (add-orders augenda addenda)
    (cond ((empty-orders? augenda) addenda)
          ((empty-orders? addenda) augenda)
          (else
           (let ((length-augenda (length augenda))
                 (length-addenda (length addenda)))
             (cond ((> length-augenda length-addenda)
                    (adjoin-order (first-order augenda)
                                  (add-orders (rest-orders augenda) addenda)))
                   ((> length-addenda length-augenda)
                    (adjoin-order (first-order addenda)
                                  (add-orders (rest-orders addenda) augenda)))
                   (else (adjoin-order (add (first-order augenda) (first-order addenda))
                                       (add-orders (rest-orders augenda)
                                                   (rest-orders addenda)))))))))

  (define (empty-orders) '())

  (define (negate-poly negandum)
    (make-poly (variable negandum) (negate-orders (orders negandum))))

  (define (negate-orders neganda)
    (if (empty-orders? neganda)
        (empty-orders)
        (adjoin-order (negate (first-order neganda)) (negate-orders (rest-orders neganda)))))

  (define (sub-poly minuendum subtrahendum)
    (if (same-variable? (variable minuendum) (variable subtrahendum))
        (add-poly minuendum (negate-poly subtrahendum))
        (error "Polys not in same var -- SUB-POLY"
               (list minuendum subtrahendum))))

  (define (mul-poly multiplicandum multiplicans)
    (if (same-variable? (variable multiplicandum) (variable multiplicans))
        (make-poly (variable multiplicandum)
                   (mul-orders (orders multiplicandum)
                               (orders multiplicans)))
        (error "Polys not in same var -- MUL-POLY"
               (list multiplicandum multiplicans))))

  (define (mul-orders multiplicanda multiplicantes)
    (if (empty-orders? multiplicanda)
        (empty-orders)
        (let ((rest (rest-orders multiplicanda)))
          (add-orders (mul-order-by-all-orders (first-order multiplicanda)
                                               multiplicantes
                                               (length rest))
                      (mul-orders rest multiplicantes)))))

  (define (mul-order-by-all-orders multiplicandum multiplicantes order)
    (if (empty-orders? multiplicantes)
        (empty-orders)
        (let mul-orders ((multipliers multiplicantes))
          (if (empty-orders? multipliers)
              (make-list order 0)
              (adjoin-order (mul multiplicandum (first-order multipliers))
                            (mul-orders (rest-orders multipliers)))))))

  (define (adjoin-order order orders)
    (cons order orders))

  (put 'make-dense 'dense (lambda (variable orders) (tag (make-poly variable orders))))
  (put 'add '(dense dense)
       (lambda (addend augend) (tag (add-poly addend augend))))
  (put 'sub '(dense dense)
       (lambda (minuend subtrahend) (tag (sub-poly minuend subtrahend))))
  (put 'mul '(dense dense)
       (lambda (multiplicand multiplier) (tag (mul-poly multiplicand multiplier))))
  (put 'term-list '(dense) dense-term-list)
  'done)
