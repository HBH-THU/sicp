;; Sehr imperativish; but autonomizeth and worketh.
(define (permutations elements)
  (define (vector-interchange! elements j k)
    (let ((aj (vector-ref elements j))
          (ak (vector-ref elements k)))
      (vector-set! elements j ak)
      (vector-set! elements k aj)))
  (define (next-permutation elements)
    (let* ((n (vector-length elements))
           (j (-1+ n)))
      (let last-non-decreasing-adjacents ((elements elements))
        (let ((n (vector-length elements)))
          (if (< n 2)
              j
              (let ((aj (vector-first elements))
                    (aj+1 (vector-second elements)))
                (if (< aj aj+1)
                    (set! j (-1+ j)))
                (last-non-decreasing-adjacents (vector-tail elements 1))))))
      (write-line j)
      (let ((k n)
            (aj (vector-ref elements (-1+ j))))
        (let smallest-aj>ak ((elements (vector-tail elements j)))
          (let ((n (vector-length elements)))
            (if (zero? n)
                k
                (let ((ak (vector-ref elements (-1+ n))))
                  (if (> aj ak)
                      (set! k (-1+ k)))
                  (smallest-aj>ak (vector-head elements (-1+ n)))))))
        (vector-interchange! elements (-1+ j) (-1+ k)))
      (let vector-shift! ((r n)
                          (s (1+ j)))
        (if (> r s)
            (begin (vector-interchange! elements (-1+ r) (-1+ s))
                   (vector-shift! (-1+ r) (1+ s)))
            elements))))
  (next-permutation (list->vector elements)))
